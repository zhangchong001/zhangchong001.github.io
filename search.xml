<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hadoop配置</title>
    <url>/Hadoop%E9%85%8D%E7%BD%AE.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、<img src="/images/2020/07/03/89c58bcb-7005-4107-963a-4818a9d87378.png" alt="image.png"></h1><p><img src="/images/2020/07/03/f985fbbe-cc19-4f1b-a070-1a3a63e19ff1.png" alt="image.png"></p>
<h1 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、<img src="/images/2020/07/03/27f61d1d-9f53-4e81-8fd0-919147ce889b.png" alt="image.png"></h1><p><img src="/images/2020/07/03/dd0f5b09-389c-4229-a41f-a867c3b300ae.png" alt="image.png"><br><strong>2.关闭防火墙</strong><br><img src="/images/2020/07/03/cb331296-db7d-4d9b-bec1-64a54b42da28.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/741a605e-d70c-42fc-8d66-5bfe7a9311ed.png" alt="image.png"></p>
<p><strong>3.配置虚拟机网络环境</strong><br><img src="/images/2020/07/03/65ce14e7-e0b3-4082-be24-e043e7340899.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/0a7320b4-c498-4274-b734-587f01c7de88.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/0d9213d0-e906-45b3-b832-98e643952669.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/80a16bac-af4a-45d8-b2ee-6f7e1ed0418a.png" alt="image.png"></p>
<h1 id="三-xshell安装配置"><a href="#三-xshell安装配置" class="headerlink" title="三.xshell安装配置"></a>三.xshell安装配置</h1><p><img src="/images/2020/07/03/f2747501-d293-4a5c-ba13-e917d75fa80b.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/5537a7b9-5318-48e5-b6bc-82b63da3b404.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/b1315770-6265-42ec-a459-678debd94a41.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/65d91729-d99d-44e9-8d09-6e869de69356.png" alt="image.png"></p>
<h1 id="四-JDK安装配置"><a href="#四-JDK安装配置" class="headerlink" title="四.JDK安装配置"></a>四.JDK安装配置</h1><p><img src="/images/2020/07/03/d3e5a86f-ec54-4d76-a781-f939cdef09cf.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/75113af8-934b-4fb7-86c0-588c4ce6e524.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/f973a403-bb87-458e-8dae-e0b3666b1fff.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/ef6eae9d-a980-45e1-a01b-a04fea19d6b2.png" alt="image.png"></p>
<h1 id="五、Hadoop安装配置"><a href="#五、Hadoop安装配置" class="headerlink" title="五、Hadoop安装配置"></a>五、Hadoop安装配置</h1><p><img src="/images/2020/07/03/6a52d7e2-cf40-408d-be84-6b18b43d4fb7.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/5e81d27a-55c5-485d-bec9-0e7b42300813.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/70d01996-1827-4561-a175-19079df584fd.png" alt="image.png"></p>
<h4 id="核心配置"><a href="#核心配置" class="headerlink" title="核心配置"></a>核心配置</h4><p><img src="/images/2020/07/03/eab231bb-6918-49bc-800b-74e93d064514.png" alt="image.png"><br><img src="/images/2020/07/03/bd956cd4-97f9-4b2a-9c93-0ff306de3a84.png" alt="image.png"><br><img src="/images/2020/07/03/e14d4b26-08e3-457d-9379-82ead80d0b84.png" alt="image.png"><br><img src="/images/2020/07/03/550b467b-2ad8-4785-8fd8-275fbd22ffc6.png" alt="image.png"><br><img src="/images/2020/07/03/dc88e51b-0b47-4358-a9d9-d839fcfff117.png" alt="image.png"><br><img src="/images/2020/07/03/3ac3e723-5b7d-45e2-a8c4-a73e4a2f8c54.png" alt="image.png"></p>
<h4 id="格式化DFS分布式文件系统"><a href="#格式化DFS分布式文件系统" class="headerlink" title="格式化DFS分布式文件系统"></a>格式化DFS分布式文件系统</h4><p><img src="/images/2020/07/03/43b01c4e-f227-4965-b221-6af47634f160.png" alt="image.png"></p>
<h4 id="启动Hadoop服务"><a href="#启动Hadoop服务" class="headerlink" title="启动Hadoop服务"></a>启动Hadoop服务</h4><p><img src="/images/2020/07/03/939ff4bc-620e-431e-a070-295b05ae84e0.png" alt="image.png"><br><img src="/images/2020/07/03/94247f8b-ab5e-4f67-ab94-805130f28788.png" alt="image.png"></p>
<h4 id="Hadoop-hdfs文件系统操作"><a href="#Hadoop-hdfs文件系统操作" class="headerlink" title="Hadoop hdfs文件系统操作"></a>Hadoop hdfs文件系统操作</h4><p><img src="/images/2020/07/03/50368444-86f5-45ec-90c4-8155bf8ca5ae.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/fe28a1ed-65be-4a3f-b791-55834035d74e.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/faf00ca8-5a99-452b-85b8-4229aa4c569b.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/32f4b62a-a867-4bc7-84da-29a052a96b6b.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/94b59784-cede-432e-bd6a-91c82ac4f99b.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/d401bf31-4875-4580-9336-8c5c313a94ca.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/903ab773-cb5f-49ff-b3b5-7e2e7862491b.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/1bed0a03-6033-440b-8880-9818b00e1f76.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/3ec18416-3119-49b3-9333-92c9222deb51.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/6a696449-91d9-4673-9355-a2dc5969869b.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/a779d505-232a-4f21-9c45-4ee1ccd90ace.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/167c54dd-32a4-426b-8973-3b2b10ea1eb8.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/337cd306-0f2d-4063-84f1-806c94553baf.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/03bbce7d-073d-4669-84f6-98e249087cfa.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/3ff071fa-cc6d-41c2-a0bd-ffc4b1573fcd.png" alt="image.png"></p>
<h3 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h3><p><img src="/images/2020/07/03/b9982165-48e0-493c-8c77-8c7c6f96e542.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/14dbd06e-e52b-4883-b01b-5682999c7b2f.png" alt="image.png">)<img src="/images/2020/07/03/b87a4719-92df-45cd-8382-74326e34128d.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive部署</title>
    <url>/Hive%E9%83%A8%E7%BD%B2.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="1、下载并安装"><a href="#1、下载并安装" class="headerlink" title="1、下载并安装"></a>1、下载并安装</h1><p><img src="/images/2020/07/04/32c23f68-7a62-45ac-a037-45d0637446c9.png" alt="image.png"></p>
<h1 id="2、设置环境变量"><a href="#2、设置环境变量" class="headerlink" title="2、设置环境变量"></a>2、设置环境变量</h1><p><img src="/images/2020/07/04/b588bf95-83d8-47b1-bac5-35c17b11b09f.png" alt="image.png"></p>
<h1 id="3、修改配置文件"><a href="#3、修改配置文件" class="headerlink" title="3、修改配置文件"></a>3、修改配置文件</h1><p><img src="/images/2020/07/04/a19daca3-5db6-4f3e-9898-7272f9eb0cc1.png" alt="image.png"></p>
<p><img src="/images/2020/07/04/6b6ca0f5-17b4-4f60-b32c-f294591618d5.png" alt="image.png"></p>
<p><img src="/images/2020/07/04/590acc3d-4d5c-4e8d-b5d0-212f37219230.png" alt="image.png"></p>
<p><img src="/images/2020/07/04/14573a1b-e560-4b9b-a6e6-e5192b1ebf8f.png" alt="image.png"></p>
<p><img src="/images/2020/07/04/f8ee6630-cf61-4e30-ae2a-a42aa1453d0e.png" alt="image.png"></p>
<p><img src="/images/2020/07/04/a1bdd668-39a3-4fa5-b720-b95a5b331498.png" alt="image.png"></p>
<p><img src="/images/2020/07/04/5be6617f-223b-44a0-98d4-7dc47ef5d55b.png" alt="image.png"><br>ive</p>
<h1 id="4、初始化元数据库"><a href="#4、初始化元数据库" class="headerlink" title="4、初始化元数据库"></a>4、初始化元数据库</h1><p><img src="/images/2020/07/04/845cd393-33cd-4261-8621-6cd22f1b9a9a.png" alt="image.png"></p>
<h1 id="5、启动Hive"><a href="#5、启动Hive" class="headerlink" title="5、启动Hive"></a>5、启动Hive</h1><p><img src="/images/2020/07/04/d485b0c7-c205-48b2-a8d0-de4cee435270.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>HIve</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux查看硬件信息</title>
    <url>/Linux%E6%9F%A5%E7%9C%8B%E7%A1%AC%E4%BB%B6%E4%BF%A1%E6%81%AF.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>系统</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. # uname -a               # 查看内核&#x2F;操作系统&#x2F;CPU信息</span><br><span class="line">2. # head -n 1 &#x2F;etc&#x2F;issue   # 查看操作系统版本</span><br><span class="line">3. # cat &#x2F;proc&#x2F;cpuinfo      # 查看CPU信息</span><br><span class="line">4. # hostname               # 查看计算机名</span><br><span class="line">5. # lspci -tv              # 列出所有PCI设备（yum install pciutils）</span><br><span class="line">6. # lsusb -tv              # 列出所有USB设备</span><br><span class="line">7. # lsmod                  # 列出加载的内核模块</span><br><span class="line">8. # env                    # 查看环境变量</span><br></pre></td></tr></table></figure>
<p>资源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. # free -m                # 查看内存使用量和交换区使用量</span><br><span class="line">2. # df -h                  # 查看各分区使用情况</span><br><span class="line">3. # du -sh &lt;目录名&gt;        # 查看指定目录的大小</span><br><span class="line">4. # grep MemTotal &#x2F;proc&#x2F;meminfo   # 查看内存总量</span><br><span class="line">5. # grep MemFree &#x2F;proc&#x2F;meminfo    # 查看空闲内存量</span><br><span class="line">6. # uptime                 # 查看系统运行时间、用户数、负载</span><br><span class="line">7. # cat &#x2F;proc&#x2F;loadavg      # 查看系统负载</span><br></pre></td></tr></table></figure>
<p>磁盘和分区</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. # mount | column -t      # 查看挂接的分区状态</span><br><span class="line">2. # fdisk -l               # 查看所有分区</span><br><span class="line">3. # swapon -s              # 查看所有交换分区</span><br><span class="line">4. # hdparm -i &#x2F;dev&#x2F;hda     # 查看磁盘参数(仅适用于IDE设备)</span><br><span class="line">5. # dmesg | grep IDE       # 查看启动时IDE设备检测状况</span><br></pre></td></tr></table></figure>

<p>网络</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. # ifconfig               # 查看所有网络接口的属性</span><br><span class="line">2. # iptables -L            # 查看防火墙设置</span><br><span class="line">3. # route -n               # 查看路由表</span><br><span class="line">4. # netstat -lntp          # 查看所有监听端口</span><br><span class="line">5. # netstat -antp          # 查看所有已经建立的连接</span><br><span class="line">6. # netstat -s             # 查看网络统计信息</span><br></pre></td></tr></table></figure>

<p>进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ps -ef                 # 查看所有进程</span><br><span class="line"># top                    # 实时显示进程状态</span><br></pre></td></tr></table></figure>




<p>用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># w                      # 查看活动用户</span><br><span class="line"># id &lt;用户名&gt;            # 查看指定用户信息</span><br><span class="line"># last                   # 查看用户登录日志</span><br><span class="line"># cut -d: -f1 &#x2F;etc&#x2F;passwd   # 查看系统所有用户</span><br><span class="line"># cut -d: -f1 &#x2F;etc&#x2F;group    # 查看系统所有组</span><br><span class="line"># crontab -l             # 查看当前用户的计划任务</span><br></pre></td></tr></table></figure>




<p>服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. # chkconfig --list       # 列出所有系统服务</span><br><span class="line">2. # chkconfig --list | grep on    # 列出所有启动的系统服务</span><br></pre></td></tr></table></figure>




<p>程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. # rpm -qa                # 查看所有安装的软件包</span><br></pre></td></tr></table></figure>

<p>查看网卡型号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># lspci | grep Ethernet</span><br></pre></td></tr></table></figure>

<p>查看内存和cpu最直接最常用的命令</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. # free</span><br><span class="line">2. # cat &#x2F;proc&#x2F;cpuinfo</span><br></pre></td></tr></table></figure>

<p>查看硬盘信息（查看硬盘型号和硬盘序列号）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># df -h</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome 浏览器扩展神器暴力猴</title>
    <url>/Chrome-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A9%E5%B1%95%E7%A5%9E%E5%99%A8%E6%9A%B4%E5%8A%9B%E7%8C%B4.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>我平常工作最常用的浏览器就是 Chrome 了，Google 出品，值得信赖，用 Chrome 就不得不提浏览器扩展了，有了各种 Chrome 扩展，可以让你浏览器网页更方便，工作更高效。<br>Chrome 扩展可以在 Google 应用商店下载<a href="https://chrome.google.com/webstore/category/extensions?hl=zh-CN这里可以搜索安装你喜欢的各种扩展。" target="_blank" rel="noopener">https://chrome.google.com/webstore/category/extensions?hl=zh-CN这里可以搜索安装你喜欢的各种扩展。</a><br><img src="/images/2020/07/06/8524a9de-6cd2-4bd9-8540-939cd94f9e25.png" alt="image.png"><br>比如我装了很多扩展。<img src="/images/2020/07/06/7b140c9e-c0a3-4f05-becc-34c96ffa092d.png" alt="image.png"><br>扩展这么多，其中的油猴<a href="Tampermonkey">Tampermonkey</a> 是必须推荐的一个，它是扩展中的王者，最强大的浏览器扩展。</p>
<h3 id="安装暴力猴扩展"><a href="#安装暴力猴扩展" class="headerlink" title="安装暴力猴扩展"></a>安装暴力猴扩展</h3><p>可以在谷歌商店直接安装<a href="https://chrome.google.com/webstore/detail/violentmonkey/jinjaccalgkegednnccohejagnlnfdag?hl=zh-CN" target="_blank" rel="noopener">暴力猴</a><img src="/images/2020/07/06/e9021617-1ff3-495d-b62b-8a872b985f20.png" alt="image.png"><br>也可以再扩展迷下载<a href="https://www.extfans.com/productivity/jinjaccalgkegednnccohejagnlnfdag" target="_blank" rel="noopener">暴力猴</a><br><img src="/images/2020/07/06/7763c5c1-ef7d-4733-b2ca-9e34b81065af.png" alt="image.png"><br>如果上不了Google，可以在国内第三方Chrome 插件网站<br><a href="https://www.crx4chrome.com/" target="_blank" rel="noopener">https://www.crx4chrome.com/</a><br><a href="http://chromecj.com/" target="_blank" rel="noopener">http://chromecj.com/</a><br><a href="http://www.cnplugins.com/" target="_blank" rel="noopener">http://www.cnplugins.com/</a><br><a href="https://www.chromefor.com/" target="_blank" rel="noopener">https://www.chromefor.com/</a><br>等搜索下载。下载的是个 crx 文件，然后打开 Chrome 扩展chrome://extensions/，打开开发者模式，将下载的crx文件拖进去，如果出错提示程序包无效。<br><img src="/images/2020/07/06/3877d52f-f1ad-4602-8f54-5ec4ffd317fd.png" alt="image.png"><br>将 crx 后缀改为 zip 再拖进去就能安装成功了，浏览器右上角可以看到图标。<img src="/images/2020/07/06/c3c6cef5-c7c5-4a2a-8ada-ac6fff1ee0a8.png" alt="image.png"></p>
<h3 id="脚本网站"><a href="#脚本网站" class="headerlink" title="脚本网站"></a>脚本网站</h3><p>有了暴力猴扩展，还需要配上脚本。<br>安装完扩展后点击图标，选择 获取新脚本<br>会进入网站<a href="https://www.tampermonkey.net/scripts.php" target="_blank" rel="noopener">https://www.tampermonkey.net/scripts.php</a><br>这里可以获取脚本来源，有3个来源网站<br><a href="http://userscripts-mirror.org/" target="_blank" rel="noopener">http://userscripts-mirror.org/</a><br><a href="https://openuserjs.org/" target="_blank" rel="noopener">https://openuserjs.org/</a><br><a href="https://greasyfork.org/" target="_blank" rel="noopener">https://greasyfork.org/</a><br>这里推荐 greasyfork ，因为它支持中文。</p>
<p>打开网站首页<a href="https://greasyfork.org/zh-CN" target="_blank" rel="noopener">https://greasyfork.org/zh-CN</a> 可以看到很多脚本。<img src="/images/2020/07/06/4307fa08-a4ac-4e5a-a0e2-e7f98cd80765.png" alt="image.png">安装脚本也很简单，找到需要的脚本，进入页面，点击安装，然后管理面板即可看到已安装的脚本。</p>
<p>下面推荐些实用的脚本，开始打开新世界的大门。</p>
<h4 id="搜索去广告"><a href="#搜索去广告" class="headerlink" title="搜索去广告"></a>搜索去广告</h4><p>功能介绍：<br>去掉百度、搜狗、谷歌搜索结果的重定向，回归为网站的原始网址—附带有去除百度的广告 包括百度顶部和底部的垃圾广告，脚本地址<a href="https://greasyfork.org/zh-CN/scripts/14178" target="_blank" rel="noopener">https://greasyfork.org/zh-CN/scripts/14178</a></p>
<p>安装脚本前搜索 浏览器 前面3个是广告<img src="/images/2020/07/06/62003585-644d-4bd4-a899-b3821ccfc40b.png" alt="image.png">)安装脚本后的效果，广告没有了，你还可以自定义设置。<img src="/images/2020/07/06/c22f76d3-5a21-43fa-b3cc-7b6b0237e47e.png" alt="image.png"></p>
<h4 id="知乎网页助手"><a href="#知乎网页助手" class="headerlink" title="知乎网页助手"></a>知乎网页助手</h4><p>功能介绍：<br>1、知乎站外链接直接跳转至目标网址；<br>2、自动展开问题全部信息，同时展示所有回答；<br>3、去除知乎网页中的广告；<br>4、知乎网页中短视频下载；<br>5、解除知乎复制限制-划词复制（鼠标左键划词自动添加到剪切板）</p>
<p>脚本地址 <a href="https://greasyfork.org/zh-CN/scripts/384172" target="_blank" rel="noopener">https://greasyfork.org/zh-CN/scripts/384172</a></p>
<p>比如这个周杰伦的视频回答 <a href="https://www.zhihu.com/question/35123246/answer/585795363" target="_blank" rel="noopener">https://www.zhihu.com/question/35123246/answer/585795363</a><br>安装脚本前<img src="/images/2020/07/06/f64e33d3-7f79-4570-b208-7a335dc3976a.png" alt="image.png">)安装后视频可以直接下载了。<img src="/images/2020/07/06/17bf28b9-2213-4443-90a5-3805ecd077a2.png" alt="image.png"></p>
<h4 id="全网VIP视频免费破解"><a href="#全网VIP视频免费破解" class="headerlink" title="全网VIP视频免费破解"></a>全网VIP视频免费破解</h4><p>功能介绍：<br>懒人专用，全网VIP视频免费破解去广告、全网音乐直接下载、百度网盘直接下载、知乎视频下载等多合一版。<br>脚本地址<a href="https://greasyfork.org/zh-CN/scripts/370634" target="_blank" rel="noopener">https://greasyfork.org/zh-CN/scripts/370634</a></p>
<p>打开优酷看《 长安十二时辰》，16集开始需要VIP<a href="https://v.youku.com/v_show/id_XNDI2NTAzNzQzNg==.html![image.png](/images/2020/07/06/8e985a7b-ed25-4744-b70d-0c4d784406ae.png)安装脚本后，点击左侧的VIP可以跳转到VIP解析网站观看。![image.png](/images/2020/07/06/4a667e1e-ef18-483c-baa7-b0821f256fdd.png)![image.png](/images/2020/07/06/3f377402-00cc-4fda-8c52-63070bfb8d1f.png)" target="_blank" rel="noopener">https://v.youku.com/v_show/id_XNDI2NTAzNzQzNg==.html![image.png](/images/2020/07/06/8e985a7b-ed25-4744-b70d-0c4d784406ae.png)安装脚本后，点击左侧的VIP可以跳转到VIP解析网站观看。![image.png](/images/2020/07/06/4a667e1e-ef18-483c-baa7-b0821f256fdd.png)![image.png](/images/2020/07/06/3f377402-00cc-4fda-8c52-63070bfb8d1f.png)</a><br>如果看不了，换接口解析。<img src="/images/2020/07/06/6474c638-585e-41d0-875b-5d30f07683ea.png" alt="image.png"></p>
<h4 id="豆瓣资源下载大师"><a href="#豆瓣资源下载大师" class="headerlink" title="豆瓣资源下载大师"></a>豆瓣资源下载大师</h4><p>功能介绍：<br>聚合数百家资源网站，通过右侧边栏1秒告诉你哪些网站能下载豆瓣页面上的电影|电视剧|纪录片|综艺|动画|音乐|图书等，有资源的网站显示绿色，没资源的网站显示黄色，就这么直观。</p>
<p>脚本地址 <a href="https://greasyfork.org/zh-CN/scripts/329484" target="_blank" rel="noopener">https://greasyfork.org/zh-CN/scripts/329484</a></p>
<p>看看最近上映的电影《蜘蛛侠：英雄远征》 <a href="https://movie.douban.com/subject/26931786/?from=showing" target="_blank" rel="noopener">https://movie.douban.com/subject/26931786/?from=showing</a><br>右侧可以看到 中文影视字幕和影视精准匹配，可以到对应网站查看。</p>
<p><img src="/images/2020/07/06/556df42d-3f60-4f3c-b929-c2b8c97870ed.png" alt="image.png">更多其他脚本自己搜索吧，有什么问题可以评论交流。</p>
]]></content>
      <categories>
        <category>插件</category>
      </categories>
      <tags>
        <tag>暴力猴</tag>
      </tags>
  </entry>
  <entry>
    <title>Python开发者必备的神器----pycharm</title>
    <url>/Python%E5%BC%80%E5%8F%91%E8%80%85%E5%BF%85%E5%A4%87%E7%9A%84%E7%A5%9E%E5%99%A8-pycharm.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>众所周知，Python语言是当下最热门的编程语言，广泛应用于数据分析、爬虫、机器学习等领域，当然了，IDE首选pychram了。Python编程语言是由荷兰计算机程序员von Rosen于1991年设计的。面向对象，解释器，高级和通用这种编程语言的特性是可读性和编写程序从其生产目标中相当好的可读性。JetBrains PyCharm Professional是最好的Python开发环境之一，在编辑，故障排除和纠正，自动完成等方面具有出色的能力和智能。</p>
<p>不多哔哔了，直接进入主题！<img src="/images/2020/07/06/4b5b7a04-fdb2-47a9-b4c8-7fb0bcd64359.png" alt="image.png"></p>
<h1 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h1><p>1、编码协助<br>PyCharm Pro 2020提供了一个带编码补全，代码片段，支持代码折叠和分割窗口的智能、可配置的编辑器，可帮助用户更快更轻松的完成编码工作。<br>2、项目代码导航<br>该IDE可帮助用户即时从一个文件导航至另一个，从一个方法至其申明或者用法甚至可以穿过类的层次。若用户学会使用其提供的快捷键的话甚至能更快。<br>3、代码分析<br>用户可使用其编码语法，错误高亮，智能检测以及一键式代码快速补全建议，使得编码更优化。<br>4、Python重构<br>有了该功能，用户便能在项目范围内轻松进行重命名，提取方法/超类，导入域/变量/常量，移动和前推/后退重构。<br>5、支持Django<br>有了它自带的HTML,CSS和 JavaScript编辑器 ，用户可以更快速的通过Djang框架进行Web开发。此外，其还能支持CoffeeScript, Mako 和 Jinja2。<br>6、支持Google App引擎<br>用户可选择使用Python 2.5或者2.7运行环境，为Google APp引擎进行应用程序的开发，并执行例行程序部署工作。<br>7、集成版本控制<br>登入，录出，视图拆分与合并–所有这些功能都能在其统一的VCS用户界面(可用于Mercurial, Subversion, Git, Perforce 和其他的 SCM)中得到。<br>8、图形页面调试器<br>用户可以用其自带的功能全面的调试器对Python或者Django应用程序以及测试单元进行调整，该调试器带断点，步进，多画面视图，窗口以及评估表达式。<br>9、集成的单元测试<br>用户可以在一个文件夹运行一个测试文件，单个测试类，一个方法或者所有测试项目。<br>10、可自定义&amp;可扩展<br>可绑定了 Textmate, NetBeans, Eclipse &amp; Emacs 键盘主盘，以及 Vi/Vim仿真插件。</p>
<h1 id="安装破解教程："><a href="#安装破解教程：" class="headerlink" title="安装破解教程："></a>安装破解教程：</h1><p>1.先下载安装包和破解补丁压缩包，然后安装安装包，启动你的IDE，如果上来就需要注册，选择：试用（Evaluate for free）进入IDE；</p>
<p>官方安装包链接：<a href="https://download.jetbrains.com/python/pycharm-professional-2020.1.exe?_ga=2.189228526.416209632.1587296965-1436667435.1584533140" target="_blank" rel="noopener">https://download.jetbrains.8686c.com/python/pycharm-professional-2020.1.exe?_ga=2.189228526.416209632.1587296965-1436667435.1584533140</a><br>2.下载破解补丁压缩包解压后得到jetbrains-agent.jar。<br>下载页面（点击普通下载即可）：<a href="https://pan.baidu.com/s/1v102Y3iLqvgqSk-3QtaTjQ" target="_blank" rel="noopener">链接</a>：<br>提取码：73ao<br>3. 启动你的IDE，如果上来就需要注册，选择：试用（Evaluate for free）进入IDE。<br>如果你的IDE试用已过期可以使用reset_eval文件夹内的脚本重置一下。<img src="/images/2020/07/06/40dfdeae-98d7-416a-a8ae-313752712d07.png" alt="image.png"><br>4. 将 jetbrains-agent.jar 拖进IDE窗口（或者当作IDE插件安装），点 “Restart” 按钮重启IDE。<br>（第二种方法，事实上你拖 jetbrains-agent-latest.zip 进去IDE窗口也没问题）<img src="/images/2020/07/06/ebfc0887-a2ff-4087-a12d-2d2c472fdd3d.png" alt="image.png"><br><img src="/images/2020/07/06/3eabb124-f4bf-4a63-b8e8-e44c83b2d78d.png" alt="image.png">更详细的具体使用方法已写在压缩包的 README.pdf / README.txt内，也可以忽视README.pdf / README.txt。<br>5.弹出激活方式，选择activation code后，点击为PyCharm安装，然后再点击是重启软件。<img src="/images/2020/07/06/46aa500c-0d5c-4669-9ef6-a0a8caae2c52.png" alt="image.png"><br>6.重启IDE，搞定，完美破解。<br><img src="/images/2020/07/06/b646d010-8933-4453-ae85-f28922315dd5.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>pycharm</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop编程入门</title>
    <url>/Hadoop%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>Hadoop编程入门</p>
<p>一、准备软件<br>（1）IntelliJ IDEA Community<br><a href="https://www.jetbrains.com/idea/download/#section=windows" target="_blank" rel="noopener">https://www.jetbrains.com/idea/download/#section=windows</a>!<br>（2）Hadoop<br><a href="https://hadoop.apache.org/releases.html" target="_blank" rel="noopener">https://hadoop.apache.org/releases.html</a><br>（3）Winutils<br>链接：<a href="https://pan.baidu.com/s/15xizRvY17-m-gqPH5YapXw" target="_blank" rel="noopener">https://pan.baidu.com/s/15xizRvY17-m-gqPH5YapXw</a><br>提取码：qw0j<br>（4）Java JDK 1.8<br>链接：<a href="https://pan.baidu.com/s/1hMad9dATs3MpZka3QXgIZA" target="_blank" rel="noopener">https://pan.baidu.com/s/1hMad9dATs3MpZka3QXgIZA</a><br>提取码：q59l</p>
<p>二、安装软件<br>（1）IntelliJ IDEA Community<br><img src="/images/2020/07/12/b475d6f2-87e0-469f-82a8-4ac25dc582bf.png" alt="image.png"><br>（2）Hadoop解压到D盘<br> <img src="/images/2020/07/12/219edf4c-0daf-4a68-8839-69767e0661ce.png" alt="image.png"></p>
<p>并配置环境变量</p>
<p> <img src="/images/2020/07/12/4160701e-7f76-4b1f-b8bb-15c6b52f793f.png" alt="image.png">)<img src="/images/2020/07/12/ae2d738b-fe84-4ecb-a99a-0464468bffcb.png" alt="image.png"></p>
<p>（3）将winutils解压后放到hadoop目录中的bin下面<br><img src="/images/2020/07/12/7549f2db-b6fc-4e6a-aba4-9048e15f6dfe.png" alt="image.png"></p>
<p>（4）JDK环境变量配置<br> <img src="/images/2020/07/12/2c6e8f90-2ea6-483d-bba0-72239a32283e.png" alt="image.png"><br> <img src="/images/2020/07/12/e10da524-6336-4c9a-8a0d-a4aefd573d96.png" alt="image.png"></p>
<p>三、创建项目<br>（1）创建maven项目<br> <img src="/images/2020/07/12/fe7a0e31-0442-4371-9f85-0dd8f2715432.png" alt="image.png"><br>为项目起名（mapreduce）<br> <img src="/images/2020/07/12/26be2c4f-7bad-4b44-83e3-6ac36c53f5cc.png" alt="image.png"><br> <img src="/images/2020/07/12/815f55dc-d203-42b5-b69a-8194bc696016.png" alt="image.png"><br>项目结构<br> <img src="/images/2020/07/12/7503a628-274e-45c6-be2b-79e07741a77b.png" alt="image.png"></p>
<p>（2）配置pom文件</p>
<p><img src="/images/2020/07/12/a759a198-0161-4353-96ee-877fcb513348.png" alt="image.png"><br>（3）创建WordCount程序<br> <img src="/images/2020/07/12/e3c7c10d-80ff-44fb-8e26-984d742f06c5.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.hmy.mr;</span><br><span class="line"></span><br><span class="line">import org.apache.hadoop.conf.Configuration;</span><br><span class="line">import org.apache.hadoop.fs.Path;</span><br><span class="line">import org.apache.hadoop.io.IntWritable;</span><br><span class="line">import org.apache.hadoop.io.Text;</span><br><span class="line">import org.apache.hadoop.mapreduce.Job;</span><br><span class="line">import org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line">import org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line">import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line">import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line">public class WordCount &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Configuration conf &#x3D; new Configuration();</span><br><span class="line">        Job job &#x3D; Job.getInstance(conf, &quot;word count&quot;);</span><br><span class="line">        job.setJarByClass(WordCount.class);</span><br><span class="line">        job.setMapperClass(TokenizerMapper.class);</span><br><span class="line">        job.setCombinerClass(IntSumReducer.class);</span><br><span class="line">        job.setReducerClass(IntSumReducer.class);</span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(IntWritable.class);</span><br><span class="line">        FileInputFormat.addInputPath(job, new Path(args[0]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, new Path(args[1]));</span><br><span class="line">        System.exit(job.waitForCompletion(true) ? 0 : 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class TokenizerMapper extends Mapper&lt;Object, Text, Text, IntWritable&gt; &#123;</span><br><span class="line">        private final static IntWritable one &#x3D; new IntWritable(1);</span><br><span class="line">        private Text word &#x3D; new Text();</span><br><span class="line"></span><br><span class="line">        public void map(Object key, Text value, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">            StringTokenizer itr &#x3D; new StringTokenizer(value.toString());</span><br><span class="line">            while (itr.hasMoreTokens()) &#123;</span><br><span class="line">                word.set(itr.nextToken());</span><br><span class="line">                context.write(word, one);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class IntSumReducer extends Reducer&lt;Text,IntWritable,Text,IntWritable&gt; &#123;</span><br><span class="line">        private IntWritable result &#x3D; new IntWritable();</span><br><span class="line"></span><br><span class="line">        public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">            int sum &#x3D; 0;</span><br><span class="line">            for (IntWritable val : values) &#123;</span><br><span class="line">                sum +&#x3D; val.get();</span><br><span class="line">            &#125;</span><br><span class="line">            result.set(sum);</span><br><span class="line">            context.write(key, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>四、发布项目<br>（1）打jar包<br> <img src="/images/2020/07/12/5cc7aac1-7822-4c18-af72-939844181b43.png" alt="image.png"><br> <img src="/images/2020/07/12/1f92df2f-5bdb-4787-a3e1-80284f43997a.png" alt="image.png"><br>  <img src="/images/2020/07/12/404c79b4-933d-4c36-bdc4-17cf45b33e62.png" alt="image.png"><br><img src="/images/2020/07/12/78d7bcd1-ec45-44a3-abf1-890021c1dd2f.png" alt="image.png"><br><img src="/images/2020/07/12/2a8742b2-8a97-4862-9016-c03e429e4d68.png" alt="image.png">)<img src="/images/2020/07/12/bca695a1-1bab-4cff-83c4-3b367ecd4853.png" alt="image.png">)<img src="/images/2020/07/12/72eef7c6-0a52-464d-a9b5-0fd76d6d25e2.png" alt="image.png"><br>五、将jar包传到linux系统<br><img src="/images/2020/07/12/70ab359f-26c9-4052-ab46-cac1bdb5d24c.png" alt="image.png"><br> <img src="/images/2020/07/12/95e1c40c-ef03-49e4-b41b-b7ff7c61baa4.png" alt="image.png"></p>
<p>六、运行hadoop程序<br>（1） 首先在/opt/tools/下创建一个文件t，打开文件，里面任意输入几个单词<br>（2） 在hdfs上创建文件夹，使用此命令<br>hdfs dfs -mkdir /test<br>然后，将文件t上传到hdfs上，使用此命令<br>hdfs  dfs  -put  /opt/tools/t    /test</p>
<p>（3） 执行hadoop jar /opt/tools/mareduce.jar com.hmy.mr.WordCount /test/t /out/1<br><img src="/images/2020/07/12/8c56d9f9-84b8-4355-ba74-75f7e37895b5.png" alt="image.png"><br>  <img src="/images/2020/07/12/cdbfd0e3-0257-4883-95f1-2a9553df1624.png" alt="image.png"></p>
<p>最终结果</p>
<p><img src="/images/2020/07/12/5898fdb9-7c43-47b9-9b82-09446232f433.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>deepin安装</title>
    <url>/deepin%E5%AE%89%E8%A3%85.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><p>请确保您的电脑满足以下的配置要求，如果您的电脑配置低于以下要求，将无法完美地体验深度操作系统：</p>
<blockquote>
<p>段落引用处理器：Intel Pentium IV 2GHz 或更快的处理器<br>内存：至少 2G 内存(RAM)，4G 以上是达到更好性能的推荐值<br>硬盘：至少 25 GB 的空闲空间<br>您还需要一个U盘，或一张光盘以及光驱，然后在深度科技官方网站下载<a href="镜像文件"></a>并<a href="制作启动盘"></a>。</p>
</blockquote>
<h1 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h1><p>一般情况下电脑默认是从硬盘启动，因此，在使用光盘安装系统之前，您需要先进入电脑的BIOS界面将光盘设置为第一启动项。</p>
<p>台式机一般为 Delete 键、笔记本一般为 F2  或 F10 或 F12 键，即可进入 BIOS 设置界面。</p>
<p>您只需在享受一杯咖啡的时间，便可完成系统的安装。</p>
<p>1、将深度操作系统光盘/U盘插入电脑光驱中。</p>
<p>2、启动电脑，将光盘/U盘设置为第一启动项。</p>
<p>3、进入安装界面，选择需要安装的语言。</p>
<p><img src="/images/2020/07/04/629ac412-4e54-4cf6-a353-531630ade225.png" alt="image.png"></p>
<p>4、进入账户界面，输入系统用户名和密码。</p>
<p><img src="/images/2020/07/04/4b80ef91-0e2f-4492-a20b-5a305214aa80.png" alt="image.png"></p>
<p>5、点击 下一步。</p>
<p>6、选择文件格式、挂载点、分配空间等。</p>
<p><img src="/images/2020/07/04/d1dbc8e9-d74f-4c5b-8cff-96ca242148ae.png" alt="image.png"></p>
<table>
<thead>
<tr>
<th>挂载点</th>
<th>挂载点中文名</th>
<th>文件系统</th>
<th>大小</th>
</tr>
</thead>
<tbody><tr>
<td>/</td>
<td>根分区（必选）</td>
<td>EXT4（推荐)</td>
<td>最少10G</td>
</tr>
<tr>
<td>/home</td>
<td>家目录（推荐）</td>
<td>EXT4（推荐）</td>
<td>最少10G</td>
</tr>
<tr>
<td>swap</td>
<td>交换分区（可选）</td>
<td>不设置</td>
<td>4G内存以下分配2G，4G以上可不分配</td>
</tr>
</tbody></table>
<p>7、点击 安装。</p>
<p>8、在弹出的确认安装窗口中，点击 确定。</p>
<p>9、将开始自动安装深度操作系统。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>mavern阿里云仓库设置</title>
    <url>/mavern%E9%98%BF%E9%87%8C%E4%BA%91%E4%BB%93%E5%BA%93%E8%AE%BE%E7%BD%AE.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>#第一步，右击项目名称<br><img src="/images/2020/08/24/f2cdb8f1-1cad-4361-9de6-81346c57a398.png" alt="1.png"><br>#第二步，创建setting.xml<br><img src="/images/2020/08/24/21031e2a-ee08-4128-8698-f6363c3a5730.png" alt="2.png"><br>#第三步，填上这些即可<br><img src="/images/2020/08/24/58383f16-a6e0-4a11-aacd-a0b70d57de10.png" alt="3.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mirrors&gt;</span><br><span class="line">    &lt;mirror&gt;</span><br><span class="line">        &lt;id&gt;nexus-aliyun&lt;&#x2F;id&gt;</span><br><span class="line">        &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt;</span><br><span class="line">        &lt;name&gt;Nexus aliyun&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;url&gt;https:&#x2F;&#x2F;maven.aliyun.com&#x2F;repository&#x2F;central&lt;&#x2F;url&gt;</span><br><span class="line">    &lt;&#x2F;mirror&gt;</span><br><span class="line">&lt;mirrors&gt;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>python元组</title>
    <url>/python%E5%85%83%E7%BB%84.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="对于元组来说，元组和列表是差不多的"><a href="#对于元组来说，元组和列表是差不多的" class="headerlink" title="对于元组来说，元组和列表是差不多的"></a>对于元组来说，元组和列表是差不多的</h1><h1 id="元组是不能修改的，-比如不能增加元素，不能修改元素，不能删除元素，"><a href="#元组是不能修改的，-比如不能增加元素，不能修改元素，不能删除元素，" class="headerlink" title="元组是不能修改的， 比如不能增加元素，不能修改元素，不能删除元素，"></a>元组是不能修改的， 比如不能增加元素，不能修改元素，不能删除元素，</h1><h1 id="元组遍历"><a href="#元组遍历" class="headerlink" title="元组遍历"></a>元组遍历</h1><p>tu = (1,2,34,5)<br>for index,value in enumerate(tu):<br>    print(index,value)</p>
<h1 id="返回这个元素在对象中出现的次数"><a href="#返回这个元素在对象中出现的次数" class="headerlink" title="返回这个元素在对象中出现的次数"></a>返回这个元素在对象中出现的次数</h1><p>num = tu.count(2)<br>print(num)</p>
<h1 id="index-返回的是查找在列表中的下标"><a href="#index-返回的是查找在列表中的下标" class="headerlink" title="index 返回的是查找在列表中的下标"></a>index 返回的是查找在列表中的下标</h1><p>num2 = tu.index(34)<br>print(num2)</p>
<h1 id="类型相互转换"><a href="#类型相互转换" class="headerlink" title="============类型相互转换=========="></a>============类型相互转换==========</h1><h1 id="1、字典转换成元组"><a href="#1、字典转换成元组" class="headerlink" title="1、字典转换成元组"></a>1、字典转换成元组</h1><p>dict1 = {‘name’:1,”age”:23}</p>
<h1 id="如果直接tuple-dict1-那么返回的只是字典的keys"><a href="#如果直接tuple-dict1-那么返回的只是字典的keys" class="headerlink" title="如果直接tuple(dict1) 那么返回的只是字典的keys"></a>如果直接tuple(dict1) 那么返回的只是字典的keys</h1><p>tu1 = tuple(dict1.values())<br>print(tu1)</p>
<h1 id="字典转换成列表-list-dict1-那么返回的只是字典的keys"><a href="#字典转换成列表-list-dict1-那么返回的只是字典的keys" class="headerlink" title="字典转换成列表,list(dict1) 那么返回的只是字典的keys"></a>字典转换成列表,list(dict1) 那么返回的只是字典的keys</h1><p>li = list(dict1)<br>print(li)</p>
<p>li2 =list(dict1.values())<br>print(li2)</p>
<h1 id="2、字典转换成字符串"><a href="#2、字典转换成字符串" class="headerlink" title="2、字典转换成字符串"></a>2、字典转换成字符串</h1><p>str1 = str(dict1)<br>print(str1)<br>转字符串需不需要注意返回得是什么内容（关键字？values？）</p>
<h1 id="元组转换成字符串、列表-注意：元组不可以转为字典"><a href="#元组转换成字符串、列表-注意：元组不可以转为字典" class="headerlink" title="=====元组转换成字符串、列表====注意：元组不可以转为字典"></a>=====元组转换成字符串、列表====注意：元组不可以转为字典</h1><p>tupleExchang = (1,2,3,4,5,”a”)<br>str2 = tupleExchang.<strong>str</strong>()<br>print(type(str2))<br>print(str2)</p>
<p>list2 = list(tupleExchang)<br>print(list2)</p>
<h1 id="列表转换成字符串、元组-注意：列表不能转换成字典"><a href="#列表转换成字符串、元组-注意：列表不能转换成字典" class="headerlink" title="=======列表转换成字符串、元组======注意：列表不能转换成字典"></a>=======列表转换成字符串、元组======注意：列表不能转换成字典</h1><p>list3 = [1,2,34,55,6]<br>str3 = str(list3)<br>print(str3)</p>
<p>tup = tuple(list3)<br>print(tup)</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware workstation 不可恢复错误解决</title>
    <url>/VMware-workstation-%E4%B8%8D%E5%8F%AF%E6%81%A2%E5%A4%8D%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>由于笔记本关机时，仍然在运行VMware里面的系统并没有正常的关机当再次开机时导致出现了如下错误<br><img src="/images/2020/07/03/7e7008af-facc-4262-8856-a853804d7bb5.png" alt="image.png">虚拟机是一种被挂起的状态，无法恢复到当时电脑关机时的状态。</p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>到虚拟机安装目录下删除掉一个文件即可<br><img src="/images/2020/07/03/5864f3e9-6530-4ada-8a1c-15e9fd6e51eb.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo搭建个人博客</title>
    <url>/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>现在随着计算机的飞速发展，拥有一个属于自己的博客，是一件非常平常的事。使用hexo搭建一个属于自己的个人博客，是即快捷又美观的一种方式，也是非常受到人们的喜爱的。接下来我将带领大家一起搭建自己的博客。后续还有hexo的next主题美化，hexo的部署，hexo的百度录入等等，一系列的教程，你可以访问我的<a href="个人博客">个人博客</a>.</p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><blockquote>
<p>系统：window10专业版<br>nodejs：下载 <a href="点击这里快捷电梯">点击这里快捷电梯</a><br>git：下载 <a href="点击这里快捷电梯">点击这里快捷电梯</a></p>
</blockquote>
<h1 id="安装hexo运行环境"><a href="#安装hexo运行环境" class="headerlink" title="安装hexo运行环境"></a>安装hexo运行环境</h1><blockquote>
<p>安装是非常简单的，nodejs和git的安装是非常简单的。如果你实在不会就上网搜安装教程，会有很多的。</p>
</blockquote>
<p> nodejs安装完成后的检验操作是在das窗口下输入命令 node -v和npm -v这两个命令就是查看版本信息的。如下图所示:<br><img src="/images/2020/07/09/9af42f2f-c976-4c3f-b3a3-b7aec6c00893.png" alt="image.png"><br>​ git安装完成后的检验操作是：鼠标右键 效果如下图所示。<br><img src="/images/2020/07/09/7a8e4e90-a0f7-41ec-9037-bb8ccc0b881a.png" alt="image.png"></p>
<h1 id="安装hexo基本框架"><a href="#安装hexo基本框架" class="headerlink" title="安装hexo基本框架"></a>安装hexo基本框架</h1><h2 id="第一步：新建文件夹"><a href="#第一步：新建文件夹" class="headerlink" title="第一步：新建文件夹"></a>第一步：新建文件夹</h2><p>​ 这一步是为了给你的博客找一个合适的位置。新建的文件夹的命名是随意的。进入新建的文件夹后，鼠标右键点击Git Bash Here 。如下图。<br><img src="/images/2020/07/09/2d87cd8f-d84b-44cd-b66f-b31529a6ce40.png" alt="image.png"></p>
<h2 id="第二步：安装hexo基础框架"><a href="#第二步：安装hexo基础框架" class="headerlink" title="第二步：安装hexo基础框架"></a>第二步：安装hexo基础框架</h2><p> 第一步完成后，会出现一个命名窗口。输入如下命令：</p>
<figure class="highlight plain"><figcaption><span>这是安装hexo的基础框架</span></figcaption><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;第二条   这是初始化hexo框架 这个可能会比较慢</span><br><span class="line">hexo init</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;第三条 安装所需要的组件</span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;第四条 编译生成静态页面</span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;第五条 启动本地服务</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>第五条命名完成后，可以首次体验一下，如下图<br><img src="/images/2020/07/09/fed0dc4a-81b4-4b1d-8220-f5779b2cc133.png" alt="image.png"><br>浏览器中的效果如下：<img src="/images/2020/07/09/d4c16782-4d0d-42e4-96cc-095b562e8bf3.png" alt="image.png"></p>
<h1 id="hexo的后续操作"><a href="#hexo的后续操作" class="headerlink" title="hexo的后续操作"></a>hexo的后续操作</h1><p>hexo的next主题美化，hexo的部署，hexo的百度录入等等，一系列的教程，你可以访问<a href="点击这里我的个人博客">点击这里我的个人博客</a>.</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>python函数</title>
    <url>/python%E5%87%BD%E6%95%B0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>1、python3的map函数<br>map()函数接收两个参数，一个是函数，一个是Iterable（可迭代对象），map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator（迭代器）返回。<br>举例说明，比如我们有一个函数f(x)=x2，要把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map()实现如下：</p>
<blockquote>
<blockquote>
<blockquote>
<p>def f(x):<br>     return x * x<br>r = map(f, [1<em>1, 2</em>2, 3<em>3, 4, 5, 6, 7, 8, 9])<br>list(r)<br>[1, 4, 9, 16, 25, 36, 49, 64, 81]<br>上述代码中f是一个map对象，r是一个Iterator，Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。<br>不对r进行list函数的话，输出结果如下：<br>def f(n):<br>    return n</em>n<br>r = map(f,[1,2,3])<br>print(r)<br>结果：<br>&lt;map object at 0x000001FB4EC5D240&gt;<br>map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数，比如，把这个list所有数字转为字符串：</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))</p>
</blockquote>
</blockquote>
</blockquote>
<p>[‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’]<br>2、python3的reduce函数<br>reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：</p>
<p>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)<br>比方说对一个序列求和，就可以用reduce实现：</p>
<blockquote>
<blockquote>
<blockquote>
<p>from functools import reduce<br>def add(x, y):<br>     return x + y<br>reduce(add, [1, 3, 5, 7, 9])<br>25<br>字符串str也是一个序列，对上面的例子稍加改动，配合map()，我们就可以写出把str转换为int的函数：</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>from functools import reduce<br>def fn(x, y):<br>     return x * 10 + y<br>def char2num(s):<br>…     digits = {‘0’: 0, ‘1’: 1, ‘2’: 2, ‘3’: 3, ‘4’: 4, ‘5’: 5, ‘6’: 6, ‘7’: 7, ‘8’: 8, ‘9’: 9}<br>…     return digits[s]<br>reduce(fn,[1,3,5,7,9])<br>map(char2num, ‘13579’)<br>13579</p>
</blockquote>
</blockquote>
</blockquote>
<p>3、python的filter函数<br>Python内建的filter()函数用于过滤序列。<br>和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。<br>例如，在一个list中，删掉偶数，只保留奇数，可以这么写：<br>def is_odd(n):<br>    return n % 2 == 1</p>
<p>list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))</p>
<h1 id="结果-1-5-9-15"><a href="#结果-1-5-9-15" class="headerlink" title="结果: [1, 5, 9, 15]"></a>结果: [1, 5, 9, 15]</h1><p>把一个序列中的空字符串删掉，可以这么写：<br>def not_empty(s):<br>    return s and s.strip()<br>list(filter(not_empty, [‘A’, ‘’, ‘B’, None, ‘C’, ‘  ‘]))</p>
<h1 id="结果-‘A’-‘B’-‘C’"><a href="#结果-‘A’-‘B’-‘C’" class="headerlink" title="结果: [‘A’, ‘B’, ‘C’]"></a>结果: [‘A’, ‘B’, ‘C’]</h1><p>可见用filter()这个高阶函数，关键在于正确实现一个“筛选”函数。<br>注意到filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list。<br>4、python的sort函数<br>Python内置的sorted()函数就可以对list进行排序：</p>
<blockquote>
<blockquote>
<blockquote>
<p>sorted([36, 5, -12, 9, -21])<br>[-21, -12, 5, 9, 36]<br>此外，sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序：<br>sorted([36, 5, -12, 9, -21], key=abs)<br>Key函数放在前面行不行？<br>[5, 9, -12, -21, 36]<br>key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。<br>再看一个字符串排序的例子：<br>sorted([‘bob’, ‘about’, ‘Zoo’, ‘Credit’])<br>[‘Credit’, ‘Zoo’, ‘about’, ‘bob’]<br>默认情况下，对字符串排序，是按照ASCII的大小比较的，由于’Z’ &lt; ‘a’，结果，大写字母Z会排在小写字母a的前面。<br>现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能用一个key函数把字符串映射为忽略大小写排序即可。忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。<br>这样，我们给sorted传入key函数，即可实现忽略大小写的排序：<br>sorted([‘bob’, ‘about’, ‘Zoo’, ‘Credit’], key=str.lower)<br>[‘about’, ‘bob’, ‘Credit’, ‘Zoo’]<br>要进行反向排序，不必改动key函数，可以传入第三个参数reverse=True：</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>sorted([‘bob’, ‘about’, ‘Zoo’, ‘Credit’], key=str.lower, reverse=True)<br>[‘Zoo’, ‘Credit’, ‘bob’, ‘about’]</p>
</blockquote>
</blockquote>
</blockquote>
<p>5、匿名函数<br>当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。</p>
<p>在Python中，对匿名函数提供了有限支持。还是以map()函数为例，计算f(x)=x2时，除了定义一个f(x)的函数外，还可以直接传入匿名函数：</p>
<blockquote>
<blockquote>
<blockquote>
<p>list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))<br>[1, 4, 9, 16, 25, 36, 49, 64, 81]<br>通过对比可以看出，匿名函数lambda x: x * x实际上就是：<br>def f(x):<br>    return x * x<br>关键字lambda表示匿名函数，冒号前面的x表示函数参数。<br>（连续使用参数值会不会出现覆盖的情况？）<br>匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。<br>用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：<br>（为什么匿名函数需要通过变量来调用？）<br>f = lambda x: x * x<br>f<br>&lt;function <lambda> at 0x101c6ef28&gt;<br>f(5)<br>25<br>同样，也可以把匿名函数作为返回值返回，比如：</p>
</blockquote>
</blockquote>
</blockquote>
<p>def build(x, y):<br>return lambda: x * x + y * y<br>6、装饰器<br>函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数</p>
<blockquote>
<blockquote>
<blockquote>
<p>def now():<br>…     print(‘2035-3-25’)<br>…<br>f = now<br>f()<br>2035-3-25<br>函数对象有一个<strong>name</strong>属性，可以拿到函数的名字：</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>now.<strong>name</strong><br>‘now’<br>f.<strong>name</strong><br>‘now’<br>现在，假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。<br>本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，可以定义如下:</p>
</blockquote>
</blockquote>
</blockquote>
<p>def log(func):<br>    def wrapper(<em>args, *</em>kw):<br>        print(‘call %s():’ % func.<strong>name</strong>)<br>        return func(<em>args, *</em>kw)<br>    return wrapper<br>观察上面的log，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助Python的@语法，把decorator置于函数的定义处：<br>@log<br>def now():<br>    print(‘2015-3-25’)<br>调用now()函数，不仅会运行now()函数本身，还会在运行now()函数前打印一行日志：<br>装饰器如果放在函数后面可不可以？</p>
<blockquote>
<blockquote>
<blockquote>
<p>now()<br>call now():<br>2015-3-25<br>把@log放到now()函数的定义处，相当于执行了语句：</p>
</blockquote>
</blockquote>
</blockquote>
<p>now = log(now)<br>由于log()是一个decorator，返回一个函数，所以，原来的now()函数仍然存在，只是现在同名的now变量指向了新的函数，于是调用now()将执行新函数，即在log()函数中返回的wrapper()函数。</p>
<p>那为什么还会调用原来的函数呢？<br>wrapper()函数的参数定义是(<em>args, *</em>kw)，因此，wrapper()函数可以接受任意参数的调用。在wrapper()函数内，首先打印日志，再紧接着调用原始函数。</p>
<p>如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本：</p>
<p>def log(text):<br>    def decorator(func):<br>        def wrapper(<em>args, *</em>kw):<br>            print(‘%s %s():’ % (text, func.<strong>name</strong>))<br>            return func(<em>args, *</em>kw)<br>        return wrapper<br>    return decorator<br>这个3层嵌套的decorator用法如下：</p>
<p>@log(‘execute’)<br>def now():<br>    print(‘2015-3-25’)<br>执行结果如下：</p>
<blockquote>
<blockquote>
<blockquote>
<p>now()<br>execute now():<br>2015-3-25<br>和两层嵌套的decorator相比，3层嵌套的效果是这样的：</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>now = log(‘execute’)(now)<br>我们来剖析上面的语句，首先执行log(‘execute’)，返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数。</p>
</blockquote>
</blockquote>
</blockquote>
<p>以上两种decorator的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有name等属性，但你去看经过decorator装饰之后的函数，它们的name已经从原来的’now’变成了’wrapper’：</p>
<blockquote>
<blockquote>
<blockquote>
<p>now.<strong>name</strong><br>‘wrapper’<br>因为返回的那个wrapper()函数名字就是’wrapper’，所以，需要把原始函数的<strong>name</strong>等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。<br>不需要编写wrapper.<strong>name</strong> = func.<strong>name</strong>这样的代码，Python内置的functools.wraps就是干这个事的，所以，一个完整的decorator的写法如下：</p>
</blockquote>
</blockquote>
</blockquote>
<p>import functools</p>
<p>def log(func):<br>    @functools.wraps(func)<br>    def wrapper(<em>args, *</em>kw):<br>        print(‘call %s():’ % func.<strong>name</strong>)<br>        return func(<em>args, *</em>kw)<br>    return wrapper<br>或者针对带参数的decorator：</p>
<p>import functools</p>
<p>def log(text):<br>    def decorator(func):<br>        @functools.wraps(func)<br>        def wrapper(<em>args, *</em>kw):<br>            print(‘%s %s():’ % (text, func.<strong>name</strong>))<br>            return func(<em>args, *</em>kw)<br>        return wrapper<br>    return decorator</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python模拟登录的几种方法</title>
    <url>/Python%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="方法一：直接使用已知的cookie访问"><a href="#方法一：直接使用已知的cookie访问" class="headerlink" title="方法一：直接使用已知的cookie访问"></a>方法一：直接使用已知的cookie访问</h1><p>特点：<br>　　简单，但需要先在浏览器登录<br>原理：<br>　　简单地说，cookie保存在发起请求的客户端中，服务器利用cookie来区分不同的客户端。因为http是一种无状态的连接，当服务器一下子收到好几个请求时，是无法判断出哪些请求是同一个客户端发起的。而“访问登录后才能看到的页面”这一行为，恰恰需要客户端向服务器证明：“我是刚才登录过的那个客户端”。于是就需要cookie来标识客户端的身份，以存储它的信息（如登录状态）。<br>　　当然，这也意味着，只要得到了别的客户端的cookie，我们就可以假冒成它来和服务器对话。这给我们的程序带来了可乘之机。<br>　　我们先用浏览器登录，然后使用开发者工具查看cookie。接着在程序中携带该cookie向网站发送请求，就能让你的程序假扮成刚才登录的那个浏览器，得到只有登录后才能看到的页面。<br>具体步骤：</p>
<h3 id="1-用浏览器登录，获取浏览器里的cookie字符串"><a href="#1-用浏览器登录，获取浏览器里的cookie字符串" class="headerlink" title="1.用浏览器登录，获取浏览器里的cookie字符串"></a>1.用浏览器登录，获取浏览器里的cookie字符串</h3><p>　　先使用浏览器登录。再打开开发者工具，转到network选项卡。在左边的Name一栏找到当前的网址，选择右边的Headers选项卡，查看Request Headers，这里包含了该网站颁发给浏览器的cookie。对，就是后面的字符串。把它复制下来，一会儿代码里要用到。<br>　　注意，最好是在运行你的程序前再登录。如果太早登录，或是把浏览器关了，很可能复制的那个cookie就过期无效了。<br><img src="/images/2020/07/13/a1fd95b7-1874-46a2-a2e0-11d63f13a18f.png" alt="image.png"></p>
<h3 id="2-写代码"><a href="#2-写代码" class="headerlink" title="2.写代码"></a>2.写代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　　urllib库的版本：</span><br><span class="line"> </span><br><span class="line">import sys</span><br><span class="line">import io</span><br><span class="line">from urllib import request</span><br><span class="line"></span><br><span class="line">sys.stdout &#x3D; io.TextIOWrapper(sys.stdout.buffer,encoding&#x3D;&#39;utf8&#39;) #改变标准输出的默认编码</span><br><span class="line"></span><br><span class="line">#登录后才能访问的网站</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;ssfw.xmu.edu.cn&#x2F;cmstar&#x2F;index.portal&#39;</span><br><span class="line"></span><br><span class="line">#浏览器登录后得到的cookie，也就是刚才复制的字符串</span><br><span class="line">cookie_str &#x3D; r&#39;JSESSIONID&#x3D;xxxxxxxxxxxxxxxxxxxxxx; iPlanetDirectoryPro&#x3D;xxxxxxxxxxxxxxxxxx&#39;</span><br><span class="line"></span><br><span class="line">#登录后才能访问的网页</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;ssfw.xmu.edu.cn&#x2F;cmstar&#x2F;index.portal&#39;</span><br><span class="line"></span><br><span class="line">req &#x3D; request.Request(url)</span><br><span class="line">#设置cookie</span><br><span class="line">req.add_header(&#39;cookie&#39;, raw_cookies)</span><br><span class="line">#设置请求头</span><br><span class="line">req.add_header(&#39;User-Agent&#39;, &#39;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;60.0.3112.113 Safari&#x2F;537.36&#39;)</span><br><span class="line"></span><br><span class="line">resp &#x3D; request.urlopen(req)</span><br><span class="line"></span><br><span class="line">print(resp.read().decode(&#39;utf-8&#39;))</span><br><span class="line"> </span><br><span class="line">　　requests库的版本：</span><br><span class="line"> </span><br><span class="line">import requests</span><br><span class="line">import sys</span><br><span class="line">import io</span><br><span class="line"></span><br><span class="line">sys.stdout &#x3D; io.TextIOWrapper(sys.stdout.buffer,encoding&#x3D;&#39;utf8&#39;) #改变标准输出的默认编码</span><br><span class="line"></span><br><span class="line">#登录后才能访问的网页</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;ssfw.xmu.edu.cn&#x2F;cmstar&#x2F;index.portal&#39;</span><br><span class="line"></span><br><span class="line">#浏览器登录后得到的cookie，也就是刚才复制的字符串</span><br><span class="line">cookie_str &#x3D; r&#39;JSESSIONID&#x3D;xxxxxxxxxxxxxxxxxxxxxx; iPlanetDirectoryPro&#x3D;xxxxxxxxxxxxxxxxxx&#39;</span><br><span class="line"></span><br><span class="line">#把cookie字符串处理成字典，以便接下来使用</span><br><span class="line">cookies &#x3D; &#123;&#125;</span><br><span class="line">for line in cookie_str.split(&#39;;&#39;):</span><br><span class="line">    key, value &#x3D; line.split(&#39;&#x3D;&#39;, 1)</span><br><span class="line">    cookies[key] &#x3D; value</span><br></pre></td></tr></table></figure>
<h1 id="方法二：模拟登录后再携带得到的cookie访问"><a href="#方法二：模拟登录后再携带得到的cookie访问" class="headerlink" title="方法二：模拟登录后再携带得到的cookie访问"></a>方法二：模拟登录后再携带得到的cookie访问</h1><p>原理：<br>　　我们先在程序中向网站发出登录请求，也就是提交包含登录信息的表单（用户名、密码等）。从响应中得到cookie，今后在访问其他页面时也带上这个cookie，就能得到只有登录后才能看到的页面。<br>具体步骤：</p>
<h3 id="1-找出表单提交到的页面"><a href="#1-找出表单提交到的页面" class="headerlink" title="1.找出表单提交到的页面"></a>1.找出表单提交到的页面</h3><p>　　还是要利用浏览器的开发者工具。转到network选项卡，并勾选Preserve Log（重要！）。在浏览器里登录网站。然后在左边的Name一栏找到表单提交到的页面。怎么找呢？看看右侧，转到Headers选项卡。首先，在General那段，Request Method应当是POST。其次最下方应该要有一段叫做Form Data的，里面可以看到你刚才输入的用户名和密码等。也可以看看左边的Name，如果含有login这个词，有可能就是提交表单的页面（不一定！）。<br><img src="/images/2020/07/13/cf92bfd8-aa92-47de-b2ab-ef31b8988b03.png" alt="image.png"><br>这里要强调一点，“表单提交到的页面”通常并不是你填写用户名和密码的页面！所以要利用工具来找到它。</p>
<h3 id="2-找出要提交的数据"><a href="#2-找出要提交的数据" class="headerlink" title="2.找出要提交的数据"></a>2.找出要提交的数据</h3><p>　　虽然你在浏览器里登陆时只填了用户名和密码，但表单里包含的数据可不只这些。从Form Data里就可以看到需要提交的所有数据。<br><img src="/images/2020/07/13/f1a90959-0ed1-4d22-874a-8285b940c92c.png" alt="image.png"></p>
<h3 id="3-写代码"><a href="#3-写代码" class="headerlink" title="3.写代码"></a>3.写代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 　　urllib库的版本：</span><br><span class="line"> </span><br><span class="line">import sys</span><br><span class="line">import io</span><br><span class="line">import urllib.request</span><br><span class="line">import http.cookiejar</span><br><span class="line"></span><br><span class="line">sys.stdout &#x3D; io.TextIOWrapper(sys.stdout.buffer,encoding&#x3D;&#39;utf8&#39;) #改变标准输出的默认编码</span><br><span class="line"></span><br><span class="line">#登录时需要POST的数据</span><br><span class="line">data &#x3D; &#123;&#39;Login.Token1&#39;:&#39;学号&#39;, </span><br><span class="line">        &#39;Login.Token2&#39;:&#39;密码&#39;, </span><br><span class="line">        &#39;goto:http&#39;:&#39;&#x2F;&#x2F;ssfw.xmu.edu.cn&#x2F;cmstar&#x2F;loginSuccess.portal&#39;, </span><br><span class="line">        &#39;gotoOnFail:http&#39;:&#39;&#x2F;&#x2F;ssfw.xmu.edu.cn&#x2F;cmstar&#x2F;loginFailure.portal&#39;&#125;</span><br><span class="line">post_data &#x3D; urllib.parse.urlencode(data).encode(&#39;utf-8&#39;)</span><br><span class="line"></span><br><span class="line">#设置请求头</span><br><span class="line">headers &#x3D; &#123;&#39;User-agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;60.0.3112.113 Safari&#x2F;537.36&#39;&#125;</span><br><span class="line"></span><br><span class="line">#登录时表单提交到的地址（用开发者工具可以看到）</span><br><span class="line">login_url &#x3D; &#39; http:&#x2F;&#x2F;ssfw.xmu.edu.cn&#x2F;cmstar&#x2F;userPasswordValidate.portal</span><br><span class="line"></span><br><span class="line">#构造登录请求</span><br><span class="line">req &#x3D; urllib.request.Request(login_url, headers &#x3D; headers, data &#x3D; post_data)</span><br><span class="line"></span><br><span class="line">#构造cookie</span><br><span class="line">cookie &#x3D; http.cookiejar.CookieJar()</span><br><span class="line"></span><br><span class="line">#由cookie构造opener</span><br><span class="line">opener &#x3D; urllib.request.build_opener(urllib.request.HTTPCookieProcessor(cookie))</span><br><span class="line"></span><br><span class="line">#发送登录请求，此后这个opener就携带了cookie，以证明自己登录过</span><br><span class="line">resp &#x3D; opener.open(req)</span><br><span class="line"></span><br><span class="line">#登录后才能访问的网页</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;ssfw.xmu.edu.cn&#x2F;cmstar&#x2F;index.portal&#39;</span><br><span class="line"></span><br><span class="line">#构造访问请求</span><br><span class="line">req &#x3D; urllib.request.Request(url, headers &#x3D; headers)</span><br><span class="line"></span><br><span class="line">resp &#x3D; opener.open(req)</span><br><span class="line"></span><br><span class="line">print(resp.read().decode(&#39;utf-8&#39;))</span><br><span class="line"> </span><br><span class="line">　　requests库的版本：</span><br><span class="line"> </span><br><span class="line">import requests</span><br><span class="line">import sys</span><br><span class="line">import io</span><br><span class="line"></span><br><span class="line">sys.stdout &#x3D; io.TextIOWrapper(sys.stdout.buffer,encoding&#x3D;&#39;utf8&#39;) #改变标准输出的默认编码</span><br><span class="line"></span><br><span class="line">#登录后才能访问的网页</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;ssfw.xmu.edu.cn&#x2F;cmstar&#x2F;index.portal&#39;</span><br><span class="line"></span><br><span class="line">#浏览器登录后得到的cookie，也就是刚才复制的字符串</span><br><span class="line">cookie_str &#x3D; r&#39;JSESSIONID&#x3D;xxxxxxxxxxxxxxxxxxxxxx; iPlanetDirectoryPro&#x3D;xxxxxxxxxxxxxxxxxx&#39;</span><br><span class="line"></span><br><span class="line">#把cookie字符串处理成字典，以便接下来使用</span><br><span class="line">cookies &#x3D; &#123;&#125;</span><br><span class="line">for line in cookie_str.split(&#39;;&#39;):</span><br><span class="line">    key, value &#x3D; line.split(&#39;&#x3D;&#39;, 1)</span><br><span class="line">    cookies[key] &#x3D; value</span><br><span class="line"></span><br><span class="line">#设置请求头</span><br><span class="line">headers &#x3D; &#123;&#39;User-agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;60.0.3112.113 Safari&#x2F;537.36&#39;&#125;</span><br><span class="line"></span><br><span class="line">#在发送get请求时带上请求头和cookies</span><br><span class="line">resp &#x3D; requests.get(url, headers &#x3D; headers, cookies &#x3D; cookies)</span><br><span class="line">        </span><br><span class="line">print(resp.content.decode(&#39;utf-8&#39;))</span><br></pre></td></tr></table></figure>
<h1 id="方法三：模拟登录后用session保持登录状态"><a href="#方法三：模拟登录后用session保持登录状态" class="headerlink" title="方法三：模拟登录后用session保持登录状态"></a>方法三：模拟登录后用session保持登录状态</h1><p>原理：<br>　　session是会话的意思。和cookie的相似之处在于，它也可以让服务器“认得”客户端。简单理解就是，把每一个客户端和服务器的互动当作一个“会话”。既然在同一个“会话”里，服务器自然就能知道这个客户端是否登录过。<br>具体步骤：</p>
<h3 id="1-找出表单提交到的页面-1"><a href="#1-找出表单提交到的页面-1" class="headerlink" title="1.找出表单提交到的页面"></a>1.找出表单提交到的页面</h3><p>2.找出要提交的数据<br>　　这两步和方法二的前两步是一样的</p>
<h3 id="3-写代码-1"><a href="#3-写代码-1" class="headerlink" title="3.写代码"></a>3.写代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">requests库的版本</span><br><span class="line"> </span><br><span class="line">import requests</span><br><span class="line">import sys</span><br><span class="line">import io</span><br><span class="line"></span><br><span class="line">sys.stdout &#x3D; io.TextIOWrapper(sys.stdout.buffer,encoding&#x3D;&#39;utf8&#39;) #改变标准输出的默认编码</span><br><span class="line"></span><br><span class="line">#登录时需要POST的数据</span><br><span class="line">data &#x3D; &#123;&#39;Login.Token1&#39;:&#39;学号&#39;, </span><br><span class="line">        &#39;Login.Token2&#39;:&#39;密码&#39;, </span><br><span class="line">        &#39;goto:http&#39;:&#39;&#x2F;&#x2F;ssfw.xmu.edu.cn&#x2F;cmstar&#x2F;loginSuccess.portal&#39;, </span><br><span class="line">        &#39;gotoOnFail:http&#39;:&#39;&#x2F;&#x2F;ssfw.xmu.edu.cn&#x2F;cmstar&#x2F;loginFailure.portal&#39;&#125;</span><br><span class="line"></span><br><span class="line">#设置请求头</span><br><span class="line">headers &#x3D; &#123;&#39;User-agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;60.0.3112.113 Safari&#x2F;537.36&#39;&#125;</span><br><span class="line"></span><br><span class="line">#登录时表单提交到的地址（用开发者工具可以看到）</span><br><span class="line">login_url &#x3D; &#39;http:&#x2F;&#x2F;ssfw.xmu.edu.cn&#x2F;cmstar&#x2F;userPasswordValidate.portal&#39;</span><br><span class="line"></span><br><span class="line">#构造Session</span><br><span class="line">session &#x3D; requests.Session()</span><br><span class="line"></span><br><span class="line">#在session中发送登录请求，此后这个session里就存储了cookie</span><br><span class="line">#可以用print(session.cookies.get_dict())查看</span><br><span class="line">resp &#x3D; session.post(login_url, data)</span><br><span class="line"></span><br><span class="line">#登录后才能访问的网页</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;ssfw.xmu.edu.cn&#x2F;cmstar&#x2F;index.portal&#39;</span><br><span class="line"></span><br><span class="line">#发送访问请求</span><br><span class="line">resp &#x3D; session.get(url)</span><br><span class="line"></span><br><span class="line">print(resp.content.decode(&#39;utf-8&#39;))</span><br></pre></td></tr></table></figure>
<h1 id="方法四：使用无头浏览器访问"><a href="#方法四：使用无头浏览器访问" class="headerlink" title="方法四：使用无头浏览器访问"></a>方法四：使用无头浏览器访问</h1><p>特点：<br>　　功能强大，几乎可以对付任何网页，但会导致代码效率低<br>原理：<br>　　如果能在程序里调用一个浏览器来访问网站，那么像登录这样的操作就轻而易举了。在Python中可以使用Selenium库来调用浏览器，写在代码里的操作（打开网页、点击……）会变成浏览器忠实地执行。这个被控制的浏览器可以是Firefox，Chrome等，但最常用的还是PhantomJS这个无头（没有界面）浏览器。也就是说，只要把填写用户名密码、点击“登录”按钮、打开另一个网页等操作写到程序中，PhamtomJS就能确确实实地让你登录上去，并把响应返回给你。<br>具体步骤：</p>
<h3 id="1-安装selenium库、PhantomJS浏览器"><a href="#1-安装selenium库、PhantomJS浏览器" class="headerlink" title="1.安装selenium库、PhantomJS浏览器"></a>1.安装selenium库、PhantomJS浏览器</h3><p>2.在源代码中找到登录时的输入文本框、按钮这些元素<br>　　因为要在无头浏览器中进行操作，所以就要先找到输入框，才能输入信息。找到登录按钮，才能点击它。<br>　　在浏览器中打开填写用户名密码的页面，将光标移动到输入用户名的文本框，右键，选择“审查元素”，就可以在右边的网页源代码中看到文本框是哪个元素。同理，可以在源代码中找到输入密码的文本框、登录按钮。</p>
<h3 id="3-考虑如何在程序中找到上述元素"><a href="#3-考虑如何在程序中找到上述元素" class="headerlink" title="3.考虑如何在程序中找到上述元素"></a>3.考虑如何在程序中找到上述元素</h3><p>　　Selenium库提供了find_element(s)_by_xxx的方法来找到网页中的输入框、按钮等元素。其中xxx可以是id、name、tag_name（标签名）、class_name（class），也可以是xpath（xpath表达式）等等。当然还是要具体分析网页源代码。</p>
<h3 id="4-写代码"><a href="#4-写代码" class="headerlink" title="4.写代码"></a>4.写代码</h3> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import sys</span><br><span class="line">import io</span><br><span class="line">from selenium import webdriver</span><br><span class="line"></span><br><span class="line">sys.stdout &#x3D; io.TextIOWrapper(sys.stdout.buffer, encoding&#x3D;&#39;utf8&#39;) #改变标准输出的默认编码</span><br><span class="line"></span><br><span class="line">#建立Phantomjs浏览器对象，括号里是phantomjs.exe在你的电脑上的路径</span><br><span class="line">browser &#x3D; webdriver.PhantomJS(&#39;d:&#x2F;tool&#x2F;07-net&#x2F;phantomjs-windows&#x2F;phantomjs-2.1.1-windows&#x2F;bin&#x2F;phantomjs.exe&#39;)</span><br><span class="line"></span><br><span class="line">#登录页面</span><br><span class="line">url &#x3D; r&#39;http:&#x2F;&#x2F;ssfw.xmu.edu.cn&#x2F;cmstar&#x2F;index.portal&#39;</span><br><span class="line"></span><br><span class="line"># 访问登录页面</span><br><span class="line">browser.get(url)</span><br><span class="line"></span><br><span class="line"># 等待一定时间，让js脚本加载完毕</span><br><span class="line">browser.implicitly_wait(3)</span><br><span class="line"></span><br><span class="line">#输入用户名</span><br><span class="line">username &#x3D; browser.find_element_by_name(&#39;user&#39;)</span><br><span class="line">username.send_keys(&#39;学号&#39;)</span><br><span class="line"></span><br><span class="line">#输入密码</span><br><span class="line">password &#x3D; browser.find_element_by_name(&#39;pwd&#39;)</span><br><span class="line">password.send_keys(&#39;密码&#39;)</span><br><span class="line"></span><br><span class="line">#选择“学生”单选按钮</span><br><span class="line">student &#x3D; browser.find_element_by_xpath(&#39;&#x2F;&#x2F;input[@value&#x3D;&quot;student&quot;]&#39;)</span><br><span class="line">student.click()</span><br><span class="line"></span><br><span class="line">#点击“登录”按钮</span><br><span class="line">login_button &#x3D; browser.find_element_by_name(&#39;btn&#39;)</span><br><span class="line">login_button.submit()</span><br><span class="line"></span><br><span class="line">#网页截图</span><br><span class="line">browser.save_screenshot(&#39;picture1.png&#39;)</span><br><span class="line">#打印网页源代码</span><br><span class="line">print(browser.page_source.encode(&#39;utf-8&#39;).decode())</span><br><span class="line"></span><br><span class="line">browser.quit()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python类</title>
    <url>/python%E7%B1%BB.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>类的声明：<br>一、类的属性<br>（私有属性和公有属性）<br>（类属性）<br>二、类的方法<br>（构造方法、析构方法、自定义方法、特殊成员方法）<br>（静态方法、类方法、类属性）<br>三、类的继承<br>（方法和属性的继承，方法的重构）<br>（抽象类，多重继承）<br>四、类的多态<br>（实现接口的重用）<br>五、类的特殊装饰<br>（@staticmethod、@classmethod、@property）<br>六、类的来源和原类（metaclass）<br>七、反射<br>    类的声明<br>使用class声明类，建议类名单词首字母大写。<br>“新式类”和“经典类”的区分在Python 3之后就已经不存在，在Python 3.x之后的版本，因为所有的类都派生自内置类型object(即使没有显示的继承object类型)，即所有的类都是“新式类”。<br>新式类：<br>class Management(object):</p>
<pre><code>def add():
    pass
  经典类：</code></pre><p>class Management:<br>    pass</p>
<p>    类的属性<br>类的属性就是类定义的变量值。<br>       公有属性：在类里直接定义的属性，它在类名下面直接定义。<br>                        调用：1、类中调用：类名.属性名 ，更改原公有属性值<br>                                   2、实例调用：实例.属性名<br>class Management(object):<br>    num = 10<br>    def add(self):<br>        Management.num +=10            # 类中调用公有属性并更改值，num=11<br>        pass<br>s1 = Management()<br>s2 = Management()</p>
<h1 id="第一种情况：s1实例中调用公有属性，s2实例没有调用公有属性"><a href="#第一种情况：s1实例中调用公有属性，s2实例没有调用公有属性" class="headerlink" title="第一种情况：s1实例中调用公有属性，s2实例没有调用公有属性"></a>第一种情况：s1实例中调用公有属性，s2实例没有调用公有属性</h1><p>s1.num +=1<br>Management.num += 2<br>“””&lt;结果&gt;<br>s1不变，s2和Management都改变了<br>s1_num:11   s2_num:12   Manage_num:12”””</p>
<h1 id="第二种情况：先调用s1实例公有属性，再通过S1调用add更改，然后再使用类更改"><a href="#第二种情况：先调用s1实例公有属性，再通过S1调用add更改，然后再使用类更改" class="headerlink" title="第二种情况：先调用s1实例公有属性，再通过S1调用add更改，然后再使用类更改"></a>第二种情况：先调用s1实例公有属性，再通过S1调用add更改，然后再使用类更改</h1><p>s1.num +=1<br>s1.add()<br>Management.num += 2<br>“””&lt;结果&gt;<br>先调用的s1实例num依然不变，s2和Management都被修改了<br>s1_num:11   s2_num:22   Manage_num:22”””<br> 问题：为什么修改num的值以后，实例s1和实例s2会有不同的结果呢 ？<br>            因为公有属性查找的顺序是：先找实例的公有属性，没找到再找类里的公有属性<br>            可以这样理解：Management相当于一个微信群，num是群里发的一张照片，S1和S2是群里面的两个人。<br>            情况1：S1把照片存到本地，P了个双眼皮，S2说太难看了，我也不会P图，不保存。这个时候发照片的Management说我也觉得难看，把图撤回，重新发了一个P的图。S2就只能保存最新的图片。<br>            情况2：S1找到Management说你的图太丑了，重新改一下吧，Management说好！撤回图片修改了~</p>
<pre><code>私有属性：加两个下划线，__membername,编译的时候自动加上类名，变成_classname__membername，这种技术叫变量名压缩(mangling)，以达到外部不能调用的目的。实际使用_classname__membername是可以调用的，但是不符合规定。标准方法是通过定义函数来获取。</code></pre><p>class Classname(object):<br> ‘’’this is a demo!’’’<br> def <strong>init</strong>(self):<br>  self.__membername = 88</p>
<p> def read_membername(self):            # 标准的外部访问方法,使用函数来读取私有属性。<br>  return self.__membername</p>
<p>s= Classname()<br>print(s.<em>Classname__membername)<br>print(s.read_membername())<br>‘’’<br>&lt;结果&gt;<br>88<br>88<br>——像下面的调用，会出现AttributeError错误——<br>print(s.<em>_membername)<br>‘’’<br>       类属性：  类自带的属性,需要注意的是实例化的类属性，和原类的类属性不同。用上面的例子作演示。<br>属性    作用    示例    结果<br>__doc</em></em>    类的文档字符串    print(s.<strong>doc</strong>)<br>print(Classname.<strong>doc</strong>)    this is a demo!<br>this is a demo!<br><strong>dict</strong>    类的属性组成的字典    print(s.<strong>dict</strong>)<br>print(Classname.<strong>dict</strong>)    {‘<em>Classname__membername’: 88}<br>{‘<em>_init</em></em>‘:, ‘<strong>module</strong>‘: ‘<strong>main</strong>‘, ‘<strong>doc</strong>‘: ‘\nthis is a demo!\n’, ‘read_membername’:}<br><strong>name</strong>    类的名字（字符串）    ##不能用于实例print(s.<strong>name</strong> )<br>print(Classname.<strong>name</strong> )<br>Classname<br><strong>bases</strong>    类的所有父类组成的元组    #不能用于实例print(s.<strong>bases</strong>)<br>print(Classname.<strong>bases</strong>)<br>(,)为什么没有值？可能是编译器问题<br><strong>module</strong>    类所属的模块    print(s.<strong>module</strong>)<br>print(Classname.<strong>module</strong>)    <strong>main</strong><br><strong>main</strong><br><strong>class</strong>    类对象的类型    print(s.<strong>class</strong>)<br>print(Classname.<strong>class</strong>)    待测<br><strong>slots</strong>    限定类属性，在类属性位置定义<br>未在slots定义的属性都是非法属性    <strong>slots</strong>.(‘name’,’age’,’sexy’)    使用’name’,’age’,’sexy’的以外属性会报错</p>
<p>    类的方法<br>类的方法就是类里面定义的函数。类的构造方法、析构方法、自定义类方法、静态方法、类方法、属性方法、特殊成员方法。<br>构造方法：<strong>init</strong><br>实例化类的时候就会运行的函数。希望初始化的参数放置在init下面。(个人觉得，这个初始化参数可以是一切对象！)<br>class A(object):<br> def instense(self):<br>  print(“init obj A”)</p>
<p>class B(object):<br> def <strong>init</strong>(self, para):<br>  self.init_para = para<br>  self.obj_A = A()<br>  self.num = 1</p>
<p> def show(self):<br>  print(self.init_para)<br>  self.obj_A.instense()<br>  print(self.num)<br>haha = B(“this is para”)<br>haha.show()</p>
<hr>
<p>this is para</p>
<p>init obj A</p>
<p>1<br>   析构方法：<br>   <strong>del</strong>：销毁实例时，方法才会执行。<br>class Hello(object):<br>    def <strong>del</strong>(self):<br>        print(“你删除了实例”)</p>
<h1 id="在python上测试"><a href="#在python上测试" class="headerlink" title="在python上测试"></a>在python上测试</h1><p>instance = Hello()<br>del instance</p>
<h1 id="当然也可以使用实例调用，但没有这么用的"><a href="#当然也可以使用实例调用，但没有这么用的" class="headerlink" title="当然也可以使用实例调用，但没有这么用的~~"></a>当然也可以使用实例调用，但没有这么用的~~</h1><p>instance.<strong>del</strong>()</p>
<p>  自定义方法：<br>  除去类中自带的以<em>下划线开头的函数，在类中定义一个函数，实现相应的功能。<br>class Person(object):<br>    def <em>_init</em></em>(self,person_name, person_age)<br>   静态方法：<br>    @staticmethod，不需要访问类里的任何参数。所带的参数都是从外部传入的。<br>class Person(object):<br>    def <strong>init</strong>(self,person_name, person_age):<br>        self.name = person_name<br>        self.age = person_age</p>
<pre><code>@staticmethod
def info(country):
    print(country)</code></pre><p>   类方法：<br>   @classmethod,第一个参数必须是类属性。<br>class Person(object):<br>    country = “china”<br>    def <strong>init</strong>(self,person_name, person_age):<br>        self.name = person_name<br>        self.age = person_age</p>
<pre><code>@classmethod
def info(country):
    print(country)</code></pre><p>属性方法：<br>1ban<br>    @property把一个函数变成一个静态属性<br>    直接调用函数名字，不需要加括号，就能获取到函数返回值。一般用在不注重过程，只要结果的情况!<br>class Person(object):<br>    country = “china”<br>    def <strong>init</strong>(self,person_name, person_age):<br>        self.name = person_name<br>        self.age = person_age</p>
<pre><code>@property
def health_point(self):
    print(&quot;HP:【{}】&quot;.format(self.age*2))
    return self.age*2</code></pre><p>P = Person(“laowang”,23)<br>P.health_point                # 不需要括号，看起来完全是一个属性，这就是属性方法</p>
<p>‘’’上面的类属性只是只读的，即然是叫属性，那么只读就显得太LOW了’’’<br>    类属性装饰器@property,装饰以后，函数就有：赋值setter\销毁deleter两个方法。<br>class Person(object):<br>    country = “china”<br>    def <strong>init</strong>(self,person_name, person_age):<br>        self.name = person_name<br>        self.age = person_age</p>
<pre><code>@property
def health_point(self):
    self.age = self.age*2
    print(&quot;HP:【{}】&quot;.format(self.age))
    return self.age

@health_point.setter                    # 增加了一个赋值方法
def health_point(self, add):
    self.age = add

@health_point.deleter                   # 增加了一个销毁属性的方法
def health_point(self):
    del self.age</code></pre><p>P = Person(“laowang”, 33)<br>print(P.health_point)</p>
<p>P.health_point = 22                        # 给health.point赋值<br>print(P.health_point)</p>
<p>del P.health_point                         # 销毁属性</p>
<pre><code>特殊成员方法：</code></pre><p>方法    作用    示例    结果<br><strong>call</strong>    默认未定义<br>类实例化后,调用实例运行的方法    p = Person()<br>p()    Person是类名<br>实例p没有调用函数，加()运行call方法<br><strong>str</strong>    默认未定义,定义时必须有返回值<br>定义时，打印实例，输入str返回值    p = Person()<br>print (p)    Person是类名<br>打印实例p，运行str方法，打印返回值<br><strong>getitem</strong>    用于索引操作，如字典。获取数据    p = Person()<br>p[‘name’]    自动运行getitem<br><strong>setitem</strong>    用于索引操作，如字典。赋值    p = Person()<br>p[‘name’] = ‘David’    自动运行setitem<br><strong>delitem</strong>    用于索引操作，如字典。删除数据    p = Person()<br>del p[‘name’]    自动运行delitem<br><strong>new</strong>    类实例化时，执行<strong>new</strong>，并且会阻止<br>init运行，可以在new里调用init<br>    p = Person()    参照例子二<br><strong>len</strong>    待续<br><strong>cmp</strong>    待续<br>‘’’例子一call\str\getitem\setitem\delitem方法’’’<br>class Person(object):<br> def <strong>call</strong>(self):<br>  print(“print call”)</p>
<p> def <strong>str</strong>(self):<br>  print(“print str:”,end=’’)<br>  return “1”</p>
<p> def <strong>getitem</strong>(self,key):<br>  print(“getitem:”,key)</p>
<p> def <strong>setitem</strong>(self,key,value):<br>  print(‘setitem:’,key,value)</p>
<p> def <strong>delitem</strong>(self,key):<br>  print(‘delitem:’,key)</p>
<p>p = Person()<br>p()<br>print(p)<br>print(‘———–’)<br>get = p[‘name’]<br>p[‘name’] = ‘David’<br>del p[‘name’]<br>‘’’例子二：<strong>new</strong>/<strong>init</strong>‘’’<br>class Person(object):</p>
<p> def <strong>init</strong>(self):</p>
<p>  print(‘this is init!’)</p>
<p> def <strong>new</strong>(self):                  # <strong>new</strong>会阻断<strong>init</strong>执行，要想执行，需要写init方法</p>
<p>  print(“this is new!”)</p>
<p>  self.<strong>init</strong>(self)        # 如果去掉这一行，init不能执行</p>
<p>p = Person()<br>    类的来源和元类：<br>    <a href="http://blog.jobbole.com/21351/中文版详细解答。下面写一个自己理解的简版的。" target="_blank" rel="noopener">http://blog.jobbole.com/21351/中文版详细解答。下面写一个自己理解的简版的。</a><br>    首先，类也是对象，可以：<br>    1)   你可以将它赋值给一个变量<br>    2)   你可以拷贝它<br>    3)   你可以为它增加属性<br>    4)   你可以将它作为函数参数进行传递</p>
<pre><code>类也是是由type()这个函数创建的，type是类的类，类的爹。学名叫元类！
也许有人会问那为啥type()能查看到数据类型呢？
可能你会注意到，type的结果前是class。。。因为数据类型在Python中都是类定义的，这也说明了，为什么数字，字符等等全是对象。

type格式：
type(类名,(父类元组),{属性和方法的字典})  ,  父类元组可以没有；后面两个典省略时，默认值为None。</code></pre><p>‘’’一言不合就上例子’’’</p>
<p>Person = type(‘Person’,(),{‘country’:’china’})</p>
<p>print(Person.country)</p>
<h1 id="带继承Person类的用法"><a href="#带继承Person类的用法" class="headerlink" title="带继承Person类的用法"></a>带继承Person类的用法</h1><p>def run():                    # 定义函数，把run传给Action的leg方法。<br>    print(‘running…’)</p>
<p>Action = type(‘Action’,(Person,),{‘leg’:run})</p>
<p>print(Action.country)<br>Action.leg()</p>
<pre><code>metaclass:
创建类的时候，使用metaclass，python就会使用指定的元类创建类。找不到则使用type创建。</code></pre><p>class MyType(type):<br>    def <strong>init</strong>(self,<em>args,*</em>kwargs):</p>
<pre><code>    print(&quot;Mytype __init__&quot;,*args,**kwargs)

def __call__(self, *args, **kwargs):
    print(&quot;Mytype __call__&quot;, *args, **kwargs)
    obj = self.__new__(self)
    print(&quot;obj &quot;,obj,*args, **kwargs)
    print(self)
    self.__init__(obj,*args, **kwargs)
    return obj

def __new__(cls, *args, **kwargs):
    print(&quot;Mytype __new__&quot;,*args,**kwargs)
    return type.__new__(cls, *args, **kwargs)</code></pre><p>print(‘here…’)<br>class Foo(object,metaclass=MyType):<br>    def <strong>init</strong>(self,name):<br>        self.name = name</p>
<pre><code>    print(&quot;Foo __init__&quot;)

def __new__(cls, *args, **kwargs):
    print(&quot;Foo __new__&quot;,cls, *args, **kwargs)
    return object.__new__(cls)</code></pre><p>f = Foo(“Alex”)<br>print(“f”,f)<br>print(“fname”,f.name)</p>
<p>    类的继承<br>代码重用。<br>    Python3中类有单继承和多继承，其中多继承与Python2的继承顺序不同。<br>    子类方法与父类重名，子类方法会覆盖父类<br>  单继承：<br>‘’’一言不合就上例子’’’</p>
<p>class Person(object):<br>    def <strong>init</strong>(self,person_name):<br>        self.name = person_name<br>    def info(self):<br>        print(“this is personal info:\nname:{}”.format(self.name))</p>
<p>class Action(Person):<br>    def <strong>init</strong>(self,person_name):<br>    ‘’’父类析构函数有两种继承方法’’’<br>        super(Action, self).<strong>init</strong>(person_name)     # 方法一<br>        # Person.<strong>init</strong>(self, person_name)          # 方法二<br>    # —-<br>    # 如果自已带参数写在继承的参数前面,然后在super里再声明一下父类变量<br>    # def <strong>init</strong>(self,person_sex,person_name):<br>    #     super(Action,self).<strong>init</strong>(person_name)<br>    # —-</p>
<pre><code>def run(self):
    print(&quot;{} is running...&quot;.format(self.name))</code></pre><p>a = Action(‘Alex’)<br>a.run()                            # 继承了Person的属性。<br>a.info()                           # 继承了Person的方法。</p>
<p>多重继承：<br>不能同时继承两父亲类和爷爷类比如B继承A，C继承时就不能同时写A和B，只写B就可以了。</p>
<p>class ROOT(object):<br>    def <strong>init</strong>(self):<br>        print(“this is root”)<br>    def action(self):<br>        print(“ROOT is action…”)</p>
<p>class A(ROOT):<br>    def <strong>init</strong>(self):<br>        super(A, self).<strong>init</strong>()<br>        print (‘init A…’)<br>    def action(self):<br>        print(“A is action…”)</p>
<p>class B(ROOT):<br>    def <strong>init</strong>(self):<br>        super(B, self).<strong>init</strong>()<br>        print (‘init B…’)<br>    def action(self):<br>        print(“B is action…”)</p>
<p>class C(A):<br>    def <strong>init</strong>(self):<br>        super(C, self).<strong>init</strong>()<br>        print (‘init C…’)<br>    def action(self):<br>        print(“C is action…”)</p>
<p>class D(B,C):<br>    def <strong>init</strong>(self):<br>        super(D, self).<strong>init</strong>()<br>        print (‘init D…’)<br>    def action(self):<br>        print(“D is action…”)</p>
<p>d = D()</p>
<p>要理解继承的顺序，因为当方法重名时，顺序靠后的方法覆盖前面的方法。<br>类的继承关系：                D(A,B)实例化时候的继承先后顺序：先找B（及其父类），再找C（及其父类）</p>
<h1 id="多重继承的参数"><a href="#多重继承的参数" class="headerlink" title="多重继承的参数"></a>多重继承的参数</h1><p>class A(object):<br>    def <strong>init</strong>(self,sever_ip):<br>        self.ip = sever_ip</p>
<pre><code>def show(self):
    print(&apos;IP:&apos;,self.ip)</code></pre><p>class B(object):<br>    def <strong>init</strong>(self,server_port):<br>        self.port = server_port</p>
<pre><code>def show(self):
    print(&apos;PORT:&apos;,self.port)</code></pre><p>class C(A,B):<br>    def <strong>init</strong>(self,server_port,server_ip):        # 先写B的参数，再写A的参数。<br>        super(C,self).<strong>init</strong>(server_port)          # B的参数继承<br>        super(A,self).<strong>init</strong>(server_ip)            # C的参数继承</p>
<pre><code>def show_b(self):
    print(self.ip,self.port)</code></pre><p>c = C(‘192.168.1.1’,1234)<br>c.show_b()<br>c.show()        # 先继承B的show，再继承A的show，A把B的show 替换掉了，所以此处运行的是A的show方法</p>
<p>    类的多态<br>    多态就是同一个父类的方法，不同子类继承可以进行不同的改写，实现多种不同的功能。<br>    任何依赖父类作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。<br>‘’’接着上面的例子’’’</p>
<h1 id="定义一个函数，把ROOT类传进里面"><a href="#定义一个函数，把ROOT类传进里面" class="headerlink" title="定义一个函数，把ROOT类传进里面"></a>定义一个函数，把ROOT类传进里面</h1><p>def who_action(class_name):<br>    class_name.action()</p>
<p>who_action(ROOT())<br>who_action(D())<br>who_action(A())</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python练习</title>
    <url>/python%E7%BB%83%E4%B9%A0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>1、 执行 Python 脚本的两种方式<br>1）/usr/bin/python3  xx.py<br>2）python3 xx.py  #注xx.py需要在内容里面调用由什么解释器执行<br>2、 简述位、字节的关系<br>1Byte = 8bit<br>1bit 表示某个二进制 0 1<br>3、 简述 ascii、unicode、utf-8、gbk 的关系<br>最初计算机是由美国发明的，计算机需要一套相应的字符编码集ascii，来表示英文字符<br>后来中国也表示也用来计算机，也需要一套字符编码集来表示汉字字符，也就是gbk<br>由于各国需要用计算机都需要一套相应的字符编码，来表示自已国家的字符，<br>于是就出现统一的字符编码的集也就是unicode，所有的字符都表示两个字节，<br>原来英文字符只占用一个字节，存放英文字符文档，会浪费一倍的空间，美国肯定不会同意<br>于是就出现了utf-8编码，可变长的字符编码，英文字符编码表示1个字节，汉字表示3个字节<br>这下美国就开兴了哈！<br>4、 请写出 “你好” 分别用 utf-8 和 gbk 编码所占的位数<br>你好  在utf-8中一个中文字符3个字节(Byte)  1字节 = 8位(bit) 你好就在utf-8表示24位<br>你好  在gbk中一个中文字符用2个字节(Byte)  1字节 = 8位(bit) 你好就在gbk中表示16位<br>5、 Pyhton 单行注释和多行注释分别用什么？<br>单行注释:用 #注释内容<br>多行注释:用’’’注释内容’’’    或者   “””注释内容”””<br>6、 声明变量注意事项有那些？<br>1 变量名不能以数字开头<br>2 变量名只能是数字，下划线，英文字母的组合<br>3 变量名不能有特殊符号<br>4 某些特定的字符不能用做变量名<br>7、 如何查看变量在内存中的地址?<br>id(变量名)<br>8、 执行 Python 程序时，自动生成的  .pyc文件的作用是什么？<br>当执行xx.py的python会 把编译的结果会保存在位于内存中的Pycodeobject中，<br>python程序运行结束，python解释器则将PyCodeObject写回到pyc文件中。<br>当python再次执行xx.py时，首先程序会在硬盘中寻找pyc文件，直接载入，否则就重复上面的<br>过程<br>.pyc文件在<em>pycache</em></p>
<p>注：自已理解，我也不是很了解<br>9、写代码<br>a.实现用户输入用户名和密码，当用户名为seven且密码为123时，<br>显示登陆成功，否则登陆失败！<br>代码如下：</p>
<p>user  =  “seven”<br>passwd = 123<br>username = input(“please the enter user:”)<br>password = int(input(“please the enter passwd:”))<br>if username == user and password == passwd:<br>    print(“logon successfull”)<br>else:<br>    print(“logon failed”)<br>注意:input()输入的任何内容都是字符串（存储str）<br>b.实现用户输入用户名和密码，当用户名为 seven且密码为 123 时，<br>显示登陆成功，否则登陆失败，失败时允许重复输入三次<br>代码如下</p>
<p>user  =  “seven”<br>passwd =  “123456”<br>（string）<br>print passwd.isdigit();<br>print user.isdigit();</p>
<p>for i in range(3):<br>    username = input(“please the enter user:”)<br>    password = input(“please the enter passwd:”)<br>    if password.isdigit():<br>        password = int(password)<br>        if username == user and passwd == password:<br>            print(“logon successfull”)<br>            break<br>        else:<br>            print(“logon failed”)<br>    else:<br>        print(“logon failed”)<br>c.实现用户输入用户名和密码，当用户名为 seven 或 alex 且密码为 123 时，<br>显示登陆成功，否则登陆失败，失败时允许重复输入三次<br>代码如下：</p>
<p>user  =  [“seven”,”alex”]<br>passwd =  123<br>for i in range(3):<br>    username = input(“please the enter user:”)<br>    password = input(“please the enter passwd:”)<br>    if password.isdigit():<br>        password = int(password)<br>        if (username in user)  and passwd == password:<br>            print(“logon successfull”)<br>            break<br>        else:<br>            print(“logon failed”)<br>    else:<br>        print(“logon failed”)<br>10、写代码<br>a.使用 while 循环实现输出 2-3+4¬-5+6 …+100 的和<br>代码如下：</p>
<p>even = 0<br>count = 1<br>while count&lt;100:<br>    count+=1<br>    #方法1：得出偶数-奇数+偶数-奇数…<br>    #方法2：求出所有的偶数减去所有的奇数和 （跟小学的换位运算类似）<br>    if count % 2 == 0:<br>        print(“2-100的偶数”,count)<br>        even += count<br>    else:<br>        print(“2-100的奇数”,count)<br>        even -= count<br>print(even) #得出的结果<br>b.使用 for 循环和 range 实现输出1-2+3-4+5-6….-98+99  的和<br>代码如下：</p>
<p>uneven = 0<br>for i in range(1,100):<br>    #方法1:得出的奇数-偶数+奇数-偶数….<br>    #方法2:求出奇数和，求出偶数和，用奇数和减偶数和<br>    if i % 2 == 1:<br>        print(“1-99的奇数”,i)<br>        uneven += i<br>    else:<br>        print(“1-99的偶数”,i)<br>        uneven -= i<br>print(uneven)   #得出结果<br>c.使用 while 循环实现输出1，2，3，4，5，7，8，9，11，12<br>代码如下：</p>
<p>count = 0<br>while count &lt;12:<br>    count += 1<br>    if count == 6:<br>        continue<br>    elif count ==10:<br>        continue<br>    print(count)<br>d.使用 while 循环实现输出 1-100 内的所有奇数<br>代码如下：</p>
<p>count = 0<br>while count &lt; 100:<br>    count += 1<br>    if count % 2 == 1:<br>        print(“1-100的奇数”,count)<br>e. 使用 while 循环实现输出1-100内的所有偶数<br>代码如下：</p>
<p>count = 0<br>while count &lt; 100:<br>    count += 1<br>    if count % 2 == 0:<br>        print(“1-100的偶数”,count)<br>11、分别书写数字5，10，32，7的二进制表示</p>
<p>在python解释器中执行bin(number)，把某个数字转换成二进制<br>二进制的表示:0b (binary)<br>bin(5)    #0b101<br>bin(10)  #0b1010<br>bin(32)  #0b100000<br>bin(7)    #0b111<br>12、简述对象和 类的关系（可用比喻的手法）<br>类：用来描述具有相同属性和方法的对象集合，<br>它定义每个对象的属性所共有的属性和方法，对象是类的实例<br>对象：通过类定义的数据结构实例</p>
<p>假如：人是一个种类，我们自已本身就是类的对象<br>类是一张图纸（该图纸上画了建筑的模型，以及怎样实现），实际高楼大夏就是图纸<br>实现的对象，<br>类是抽象的，对象是实际存在的。<br>13、现有如下两个变量，请简述 n1 和 n2是什么关系？<br>n1=123<br>n2=123<br>n1和n2关系是一样 ，我们可以用id(n1),id(n2)在内存中的地址的表示<br>14、现有如下两个变量，请简述 n1 和 n2是什么关系？<br>n1 = 123456<br>n2 = 123456<br>n1和n2虽然在值是一样的，在内存地址表示中是不一样的</p>
<p>注：<br>（在python内部中，内存还有一个(小数字池，字符串池)缓存池，对于经常用的，<br>在python内部编译有一个优化，在这个缓存池，如果重复使用，都是使用同一内存缓存池的内存（地址）空间<br>如果大于这个缓存池，则会在内存独立开辟新的一个内存（地址）空间<br>例如<br>数字的缓存池 -5 至 256<br>可以用不相同的变量名，相同的值，用id(变量名)，看它们的内存地址）</p>
<p>15、现有如下两个变量，请简述 n1 和 n2 是什么关系？<br>n1 = 123456<br>n2 = n1<br>n1 = 1234</p>
<p>n2 是 n1 值的引用   它们在内存的地址是一样和内容也是一样的，只是不同命名<br>变量的赋值:<br>赋值不会开辟新的内存空间，它只是复制了新对象的引用，如果n1的值发生改变，<br>n2还是原来的改变之前值<br>16、如有一下变量 n1 =5，请使用 int 的提供的方法，<br>得到该变量最少可以用多少个二进制位表示？<br>n1= 5<br>print(n1.bit_length())<br>#结果<br>3<br> 17、布尔值分别有什么？<br>True  False<br>18、阅读代码，请写出执行结果<br>a = “alex”<br>b = a.capitalize()<br>print(a)<br>print(b)<br>请写出输出结果：<br>alex    #a<br>Alex    #b<br>19、写代码，有如下变量，请按照要求实现每个功能<br>name = “ aleX”<br>a. 移除 name 变量对应的值两边的空格，并输入移除有的内容</p>
<p>print(name.strip())<br>#结果<br>aleX<br>b.判断 name 变量对应的值是否以 “al” 开头，并输出结果</p>
<p>print(name.startswith(“al”))<br>#结果<br>False<br>c.判断 name 变量对应的值是否以 “X” 结尾，并输出结果</p>
<p>print(name.endswith(“X”))<br>#结果<br>True<br>d.将 name 变量对应的值中的 “ l” 替换为 “ p”，并输出结果</p>
<p>print(name.replace(“l”,”p”))<br>#结果<br>    apeX<br>e.将 name 变量对应的值根据 “ l” 分割，并输出结果。</p>
<p>print(name.split(“l”))<br>#结果<br>[‘\ta’, ‘eX’]  #\t 表示使用了tab<br>f.请问，上一题 e分割之后得到值是什么类型？</p>
<p>print(type(name.split(“l”)))<br>#结果<br>&lt;class ‘list’&gt; #列表<br>g.将 name 变量对应的值变大写，并输出结果</p>
<p>print(name.upper())<br>    ALEX<br>h.将 name 变量对应的值变小写，并输出结果</p>
<p>print(name.lower())<br>#结果<br>    alex</p>
<p>i.请输出 name 变量对应的值的第 2 个字符？</p>
<p>print(name[2])<br>#结果<br>l<br>j. 请输出 name 变量对应的值的前 3 个字符？</p>
<p>print(name[:3])<br>#结果<br>    al<br>k. 请输出 name 变量对应的值的后 2 个字符？</p>
<p>print(name[-2:])<br>#结果<br>eX<br>l.请输出 name 变量对应的值中 “ e” 所在索引位置？</p>
<p>print(name.index(‘e’))<br>#结果<br>3<br> 20、字符串是否可迭代？如可以请使用 for 循环每一个元素？</p>
<p>字符串可以迭代<br>代码如下：<br>hobby = “一条龙”<br>for i in hobby:<br>    print(i)<br>显示结果如下：<br>一<br>条<br>龙<br>21、请用代码实现：利用下划线将列表的每一个元素拼接成字符串，<br>li = [‘alex’, ‘eric’, ‘rain’]</p>
<p>print(“_”.join(li))<br>#结果<br>alex_eric_rain<br>22、写代码，有如下列表，按照要求实现每一个功能<br>li = [‘alex’,’eric’,’rain’]<br>a.计算列表长度并输出</p>
<p>print(len(li))<br>#结果<br>3<br>b.列表中追加元素 “seven”，并输出添加后的列表</p>
<p>li.append(“seven”)<br>print(li)<br>#结果<br>[‘alex’, ‘eric’, ‘rain’, ‘seven’]<br>c.请在列表的第1个位置插入元素 “Tony”，并输出添加后的列表</p>
<p>li.insert(0,”Tony”)<br>print(li)<br>#结果<br>[‘Tony’, ‘alex’, ‘eric’, ‘rain’]<br>d.请修改列表第2个位置的元素为 “Kelly”，并输出修改后的列表</p>
<p>li[1] = “Kelly”<br>print(li)<br>#结果<br>[‘alex’, ‘Kelly’, ‘rain’]<br>e.请删除列表中的元素 “eric”，并输出修改后的列表</p>
<p>第一种：得出“eric”索引，通过索引来删除该值<br>第二种：直接删除”eric”<br>1)<br>del li[1];print(li)   #结果[‘alex’, ‘rain’]<br>li.pop(1);print(li)   #结果[‘alex’, ‘rain’]<br>2)<br>li.remove(“eric”)<br>print(li)<br>#结果<br>[‘alex’, ‘rain’]<br>f.请删除列表中的第2个元素，并输出删除的元素的值和删除元素后的列表</p>
<p>print(li.pop(1));print(li)<br>#结果<br>eric<br>[‘alex’, ‘rain’]<br>g.请删除列表中的第3个元素，并输出删除元素后的列表</p>
<p>print(li.pop(2));print(li)<br>#结果<br>rain<br>[‘alex’, ‘eric’]<br>h.请删除列表中的第2至4个元素并输出删除元素后的列表</p>
<p>del li[1:3]<br>print(li)<br>#结果<br>[‘alex’]<br>i.请将列表所有的元素反转，并输出反转后的列表</p>
<p>li.reverse()<br>print(li)<br>#结果<br>[‘rain’, ‘eric’, ‘alex’]<br>j.请使用 for、len、range 输出列表的索引</p>
<p>#3种方法，建议用第三种<br>1)for<br>for i in li:<br>    #list.index()列表有相同元素的,只是的获取（相同元素中的第一个元素）的索引<br>    print(li.index(i),i)  #如果列表内有相同的元素，不建议使用此方法<br>#结果<br>0 alex<br>1 eric<br>2 rain</p>
<p>2)len<br>zero = []<br>for i in li:<br>    print(len(zero),i)<br>    zero.append(i)<br>#结果<br>0 alex<br>1 eric<br>2 rain</p>
<p>3)range<br>for i in range(len(li)):<br>    print(i,li[i])<br>#结果<br>0 alex<br>1 eric<br>2 rain<br> k.请使用 enumrate 输出列表元素和序号（序号从 100 开始）</p>
<p>for index,i in enumerate(li,start=100):<br>    print(index,i)<br>#结果<br>100 alex<br>101 eric<br>102 rain<br>l.请使用 for 循环输出列表的所有元素</p>
<p>for i in li:<br>    print(i)<br>#结果<br>alex<br>eric<br>rain<br> (新)<br>23、写代码，有如下列表，请按照功能要求实现每一个功能<br>li=[“hello”,’seven’,[“mon”,[“h”,”kelly”],’all’],123,446]<br>a. 请输出 “Kelly”</p>
<p>print(li[2][1][1])<br>#结果<br>kelly<br>b.请使用索引找到 ‘all’元素并将其修改为 “ALL”</p>
<p>li[2][2] = “ALL”<br>print(li)<br>#结果<br>[‘hello’, ‘seven’, [‘mon’, [‘h’, ‘kelly’], ‘ALL’], 123, 446]<br>24、写代码，有如下元组，按照要求实现每一个功能<br>tu=(‘alex’,’eric’,’rain’)<br>a.计算元组长度并输出</p>
<p>print(len(tu))<br>#结果<br>3<br>b.获取元组的第2个元素，并输出</p>
<p>print(tu[1])<br>#结果<br>eric<br>c.获取元组的第 1-2个元素，并输出</p>
<p>print(tu[0:2])<br>#结果<br>(‘alex’, ‘eric’)<br>d.请使用 for 输出元组的元素</p>
<p>for i in tu:<br>    print(i)<br>#结果<br>alex<br>eric<br>rain<br>e.请使用 for、len、range 输出元组的索引</p>
<p>#跟22题j列表用法类似<br>for i in range(len(tu)):<br>    print(i,tu[i])<br>#结果<br>0 alex<br>1 eric<br>2 rain<br>f.请使用 enumrate 输出元祖元素和序号（序号从 10 开始）</p>
<p>for index,i in enumerate(tu,start=10):<br>    print(index,i)<br>#结果<br>10 alex<br>11 eric<br>12 rain<br>25、有如下变量，请实现要求的功能<br>tu=(“alex”,[11,22,{“k1”:’v1’,”k2”:[“age”,”name”],”k3”:(11,22,33)},44])<br>a.讲述元祖的特性<br>元祖和列表类似都是有序的从0开始<br>不同的是元祖的元素是不能修改的<br>b.请问 tu 变量中的第一个元素 “alex” 是否可被修改？<br>不能修改<br>c.请问tu变量中的”k2”对应的值是什么类型？是否可以被修改？<br>如果可以，请在其中添加一个元素 “Seven”</p>
<p>print(type(tu[1][2][“k2”]))<br>#结果<br>&lt;class ‘list’&gt;<br>列表类型可以修改<br>tu[1][2][“k2”].append(“seven”)<br>print(tu)<br>#结果<br>(‘alex’, [11, 22, {‘k2’: [‘age’, ‘name’, ‘seven’], ‘k3’: (11, 22, 33), ‘k1’: ‘v1’}, 44])<br>注：表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。<br>tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，<br>tuple的每个元素，指向永远不变。但指向的这个list本身是可变的！<br>d.请问 tu 变量中的”k3”对应的值是什么类型？是否可以被修改？<br>如果可以，请在其中添加一个元素 “Seven”</p>
<p>print(type(tu[1][2][“k3”]))<br>#结果<br>&lt;class ‘tuple’&gt;<br>#对应值是元祖，不能修改</p>
<p>26、字典<br>dic ={‘k1’:”v1”,”k2”:”v2”,”k3”:[11,22,33]}<br>a.请循环输出所有的 key</p>
<p>for i in dic:<br>    print(i)<br>#结果<br>k1<br>k3<br>k2<br>注：字典是无序的<br>b.请循环输出所有的value</p>
<p>for i in dic:<br>    print(dic[i])<br>#结果<br>[11, 22, 33]<br>v2<br>v1<br>c.请循环输出所有的 key 和 value</p>
<p>for i in dic:<br>    print(i,dic[i])<br>#结果<br>k2 v2<br>k3 [11, 22, 33]<br>k1 v1<br>d.请在字典中添加一个键值对，”k4”:”v4”，输出添加后的字典</p>
<p>dic[“k4”] = “v4”<br>print(dic)<br>#结果<br>{‘k4’: ‘v4’, ‘k2’: ‘v2’, ‘k3’: [11, 22, 33], ‘k1’: ‘v1’}<br>e.请在修改字典中 “k1” 对应的值为 “alex”，输出修改后的字典</p>
<p>dic[‘k1’] = “alex”<br>print(dic)<br>#结果<br>{‘k3’: [11, 22, 33], ‘k1’: ‘alex’, ‘k2’: ‘v2’}<br>f.请在 k3 对应的值中追加一个元素44，输出修改后的字典</p>
<p>dic[“k3”].append(44)<br>print(dic)<br>#结果<br>{‘k2’: ‘v2’, ‘k3’: [11, 22, 33, 44], ‘k1’: ‘v1’}<br>g.请在 k3 对应的值的第1个位置插入个元素18，输出修改后的字典</p>
<p>dic[“k3”].insert(0,18)<br>print(dic)<br>#结果<br>{‘k1’: ‘v1’, ‘k2’: ‘v2’, ‘k3’: [18, 11, 22, 33]}<br> 27、转换<br>a.将字符串 s=”alex” 转换成列表</p>
<p>print(list(s))<br>#结果<br>[‘a’, ‘l’, ‘e’, ‘x’]<br>b.将字符串 s=”alex” 转换成元祖</p>
<p>print(tuple(s))<br>#结果<br>(‘a’, ‘l’, ‘e’, ‘x’)<br>c.将列表 li =[“alex”,”seven”]转换成元组</p>
<p>print(tuple(li))<br>#结果<br>(‘alex’, ‘seven’)<br>d.将元祖 tu =(‘Alex’,”seven”)转换成列表</p>
<p>print(list(tu))<br>#结果<br>[‘Alex’, ‘seven’]<br>e.将列表 li=[“alex”,”seven”]转换成字典且字典的key按照10开始向后递增</p>
<p>dic1 = {}<br>for key,value in enumerate(li,start=10):<br>    dic1[key] = value<br>print(dic1)<br>#结果<br>{10: ‘alex’, 11: ‘seven’}<br> 28、转码<br>n=”老男孩”<br>a.将字符串转换成 utf-8 编码的字节，并输出，然后将该字节再转换成 utf-8 编码字符串，再输出</p>
<p>print(n.encode(“utf-8”))<br>#结果<br>b’\xe8\x80\x81\xe7\x94\xb7\xe5\xad\xa9’</p>
<p>print(n.encode(“utf-8”).decode(“utf-8”))<br>#结果<br>老男孩<br>b.将字符串转换成 gbk 编码的字节，并输出，然后将该字节再转换成 gbk 编码字符串，再输出</p>
<p>print(n.encode(“gbk”))<br>#结果<br>b’\xc0\xcf\xc4\xd0\xba\xa2’</p>
<p>print(n.encode(“gbk”).decode(“gbk”))<br>#结果<br>老男孩<br> 29、求1-100内的所有数的和</p>
<p>#3种方法<br>1)<br>print(sum(range(1,101)))<br>#结果<br>5050</p>
<p>2)<br>SUM = 0<br>for i in range(1,101):<br>    SUM += i<br>print(SUM)<br>#结果<br>5050</p>
<p>3)<br>SUM = 0<br>count = 1<br>while count &lt;= 100:<br>    SUM += count<br>    count += 1<br>print(SUM)<br>#结果<br>5050<br>30、元素分类<br>有如下值集合 [11,22,33,44,55,66,77,88,99,90]，<br>将所有大于66的值保存至字典的第一个 key中，<br>将小于66的值保存至第二个 key 的值中。<br>即：{‘k1’:大于 66 的所有值,’k2’:小于66 的所有值}</p>
<p>dic = {“k1”:[],<br>       “k2”:[]}<br>aa = set([11,22,33,44,55,66,77,88,99,90])<br>for i in aa:<br>    if i&gt;= 66:<br>        dic[“k1”].append(i)<br>    else:<br>        dic[“k2”].append(i)<br>print(dic)<br>结果<br>{‘k1’: [66, 99, 77, 88, 90], ‘k2’: [33, 11, 44, 22, 55]}<br>31、购物车<br>功能要求：<br>要求用户输入总资产，例如： 2000<br>显示商品列表，让用户根据序号选择商品，加入购物车<br>购买，如果商品总额大于总资产，提示账户余额不足，否则，购买成功。<br>goods = [<br>{“name”:”电脑”,”price”:1999},<br>{“name”:”鼠标”,”price”:10},<br>{“name”:”游艇”,”price”:20},<br>{“name”:”美女”,”price”:98},<br>]</p>
<p>shop_cart = []<br>goods    =    [<br>{“name”:”电脑”,”price”:1999},<br>{“name”:”鼠标”,”price”:10},<br>{“name”:”游艇”,”price”:20},<br>{“name”:”美女”,”price”:98},<br>]<br>while True:<br>    salary = input(“请输入用户余额[quit]:”)<br>    if salary.isdigit():<br>        salary = int(salary)<br>        break<br>    elif salary == “quit”:<br>        exit(“不想购买”)<br>    else:<br>        print(“please the enter number”)<br>while True:<br>    print(“shop list”.center(50, ‘*’))<br>    for index,i in enumerate(goods):<br>        print(index,i)<br>    choose_number = input(“请输入购买商品编号[quit]:”)<br>    if choose_number.isdigit():<br>    choose_number = int(choose_number)<br>        product_list = []<br>        if 0 &lt;= choose_number &lt;= len(goods):<br>            product_list.append(goods[choose_number])<br>            if salary &gt;= product_list[0][“price”]:<br>              shop_cart.append(goods[choose_number])<br>              salary -= product_list[0][‘price’]<br>              print(“当前购买的商品”,product_list,”当前用户余额\033[1;31m{salary}\033[0m”.format(salary=salary))<br>            else:<br>                print(“余额不足”)<br>        else:<br>            print(“无效的商品编号”)<br>    elif choose_number.lower() == ‘quit’:</p>
<pre><code>    print(&quot;购买的商品&quot;.center(50,&quot;*&quot;))
    for y in shop_cart:
        print(y)
    exit()
else:
    print(&quot;无效的输入&quot;)</code></pre><p>#注:简易的购物车，还能继续优化</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>requests实现模拟用户登录</title>
    <url>/requests%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%8B%9F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="1-了解cookie和session"><a href="#1-了解cookie和session" class="headerlink" title="1. 了解cookie和session"></a>1. 了解cookie和session</h1><p>首先一定要先了解到cookie和session是什么，这是后面理解网站交互，模拟用户登录的基础。</p>
<h2 id="1-1-无状态协议：Http"><a href="#1-1-无状态协议：Http" class="headerlink" title="1.1. 无状态协议：Http"></a>1.1. 无状态协议：Http<img src="/images/2020/07/13/d7d748a0-16cb-4121-8bd8-3c1db8cb19b8.png" alt="image.png"></h2><p>如上图所示，HTTP协议 是无状态的协议，用户浏览服务器上的内容，只需要发送页面请求，服务器返回内容。对于服务器来说，并不关心，也并不知道是哪个用户的请求。对于一般浏览性的网页来说，没有任何问题。<br>但是，现在很多的网站，是需要用户登录的。以淘宝为例：比如说某个用户想购买一个产品，当点击 “ 购买按钮 ” 时，由于HTTP协议 是无状态的，那对于淘宝来说，就不知道是哪个用户操作的。<br>为了实现这种用户标记，服务器就采用了cookie这种机制来识别具体是哪一个用户的访问。</p>
<h2 id="1-2-了解cookie"><a href="#1-2-了解cookie" class="headerlink" title="1.2. 了解cookie"></a>1.2. 了解cookie</h2><p><img src="/images/2020/07/13/7cefe427-bf7c-4f89-9f4f-9f566edd0ce1.png" alt="image.png"><br>如图，为了实现用户标记，在Http无状态请求的基础之上，我们需要在请求中携带一些用户信息（比如用户名之类，这些信息是服务器发送到本地浏览器的，但是服务器并不存储这些信息），这就是cookie机制。如下图所示，在登录马蜂窝网站之后，就可以看到浏览器已经保存了一些cookie信息（chrome浏览器为例）：<img src="/images/2020/07/13/c72725a8-0ff3-4222-ba9c-3c3955e725d5.png" alt="image.png"><br>需要注意的是：cookie信息是保存在本地浏览器里面的，服务器上并不存储相关的信息。 在发送请求时，cookie的这些内容是放在 Http协议中的header 字段中进行传输的。 <img src="/images/2020/07/13/33b9b9e0-a1f0-45b9-8c5e-4938172eb02d.png" alt="image.png">几乎现在所有的网站都会发送一些 cookie信息过来，当用户请求中携带了cookie信息，服务器就可以知道是哪个用户的访问了，从而不需要再使用账户和密码登录。<br>但是，刚才也提到了，cookie信息是直接放在Http协议的header中进行传输的，看得出来，这是个隐患！一旦别人获取到你的cookie信息（截获请求，或者使用你的电脑），那么他很容易从cookie中分析出你的用户名和密码。为了解决这个隐患，所以有了session机制。</p>
<h2 id="1-3-了解session"><a href="#1-3-了解session" class="headerlink" title="1.3. 了解session"></a>1.3. 了解session</h2><p>刚才提到了cookie不安全，所以有了session机制。简单来说（每个框架都不一样，这只是举一个通用的实现策略），整过过程是这样：<br>服务器根据用户名和密码，生成一个session ID，存储到服务器的数据库中。<br>用户登录访问时，服务器会将对应的session ID发送给用户（本地浏览器）。<br>浏览器会将这个session ID存储到cookie中，作为一个键值项。<br>以后，浏览器每次请求，就会将含有session ID的cookie信息，一起发送给服务器。<br>服务器收到请求之后，通过cookie中的session ID，到数据库中去查询，解析出对应的用户名，就知道是哪个用户的请求了。</p>
<h3 id="1-3-1-看一下Django是如何实现session机制的，来加深对session的了解"><a href="#1-3-1-看一下Django是如何实现session机制的，来加深对session的了解" class="headerlink" title="1.3.1. 看一下Django是如何实现session机制的，来加深对session的了解"></a>1.3.1. 看一下Django是如何实现session机制的，来加深对session的了解</h3><p><img src="/images/2020/07/13/bc5b3849-887e-4c5c-aaaf-b742bf339192.png" alt="image.png">)<img src="/images/2020/07/13/2eb28ab3-5a98-4083-ac50-40196d13f847.png" alt="image.png"> Session_key：服务器给用户返回的ID<br>    Session_data：一段加密的文字。用户名，密码，一些其他的用户信息。把这些信息生成一段字符串，是加密的<br>    expire_date：django后台会设置过期时间。 主要是担心session被黑客截取，那就一直可以用，盗用数据。<br>第二步，当用户登录时，服务器会给本地浏览器返回一些cookie信息，包括session ID。<br><img src="/images/2020/07/13/0c6c5760-017e-4acf-9fd2-6886cbdb6a22.png" alt="image.png">第三步：以后浏览器每次访问时，浏览器都会把 session ID带过来，这样服务器不需要知道你的用户名，就知道是哪个用户的访问了。<br>服务器是如何把sessionID转换成用户名的？<br><img src="/images/2020/07/13/7e9506a3-a4de-4a74-bdb2-0d378c587c23.png" alt="image.png">如上图所示，在Django中，需要对session进行配置。这个INSTALLED_APPS 是会对每次request和response进行拦截，拦截到浏览器发送过来的request时，找到其中的session信息，然后到数据库中进行查询，找到session_data，再做解密，就知道所有的用户信息了，取出user信息。新建完Django项目之后，这个sessions信息就配置好了。如果注释掉这一个session配置，自动登录机制就会失效，无法使用。</p>
<h2 id="1-4-总结一下"><a href="#1-4-总结一下" class="headerlink" title="1.4. 总结一下"></a>1.4. 总结一下</h2><p>cookie 在客户端（本地浏览器），session 在服务器端。cookie是一种浏览器本地存储机制。存储在本地浏览器中，和服务器没有关系。每次请求，用户会带上本地cookie的信息。这些cookie信息也是服务器之前发送给浏览器的，或者是用户之前填写的一些信息。<br>Cookie有不安全机制。 你不能把所有的用户信息都存在本地，一旦被别人窃取，就知道你的用户名和密码，就会很危险。所以引入了session机制。<br>服务器在发送id时引入了一种session的机制，很简单，就是根据用户名和密码，生成了一段随机的字符串，这段字符串是有过期时间的。<br>一定要注意：session是服务器生成的，存储在服务器的数据库或者文件中，然后把sessionID发送给用户，用户存储在本地cookie中。每次请求时，把这个session ID带给服务器，服务器根据session ID到数据库中去查询，找到是哪个用户，就可以对用户进行标记了。<br>session 的运行依赖 session ID，而 session ID 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，那么同时 session 也会失效（但是可以通过其它方式实现，比如在url中传递 session ID）<br>用户验证这种场合一般会用 session。 因此，维持一个会话的核心就是客户端的唯一标识，即session ID</p>
<h1 id="2-环境"><a href="#2-环境" class="headerlink" title="2. 环境"></a>2. 环境</h1><p>python 3.6.1<br>requests 2.14.2 （通过pip list查看）</p>
<h1 id="3-模拟登录马蜂窝网站"><a href="#3-模拟登录马蜂窝网站" class="headerlink" title="3. 模拟登录马蜂窝网站"></a>3. 模拟登录马蜂窝网站</h1><p>马蜂窝：<a href="http://www.mafengwo.cn/" target="_blank" rel="noopener">http://www.mafengwo.cn/</a></p>
<h2 id="3-1-分析用户登录流程"><a href="#3-1-分析用户登录流程" class="headerlink" title="3.1. 分析用户登录流程"></a>3.1. 分析用户登录流程</h2><p>这里会用到两个小技巧<br>第一，先使用一个错误的用户名和密码来登录，这样就可以清晰的看到这个登录请求有post哪些数据，post到哪个url。因为如果使用正确的用户名和密码登录，一旦登录成功，就会直接跳转到其他页面，页面和请求都会被刷新。很难找出原始的请求信息<br><img src="/images/2020/07/13/dd15389f-9d3b-4dd0-92a5-a08509e02109.png" alt="image.png"><br>第二，在截取请求的地方，勾选Preserve log，保留跳转前的请求数据。<br><img src="/images/2020/07/13/c9467950-caaa-4d91-a019-a9973de2ac8e.png" alt="image.png"><br>截取到的请求如下：<br><img src="/images/2020/07/13/1fd354c2-3673-48cd-8e71-5f84cc7b3599.png" alt="image.png">)<img src="/images/2020/07/13/162b0a1a-1473-41f9-852e-0cbd5ac680ae.png" alt="image.png"><br>#提取到的请求信息：<br>Headers：<br>    Request URL:<a href="https://passport.mafengwo.cn/login/" target="_blank" rel="noopener">https://passport.mafengwo.cn/login/</a><br>    Request Method:POST<br>    origin:<a href="https://passport.mafengwo.cn" target="_blank" rel="noopener">https://passport.mafengwo.cn</a><br>    referer:<a href="https://passport.mafengwo.cn/" target="_blank" rel="noopener">https://passport.mafengwo.cn/</a><br>    User-Agent:Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko)     Chrome/63.0.3239.132 Safari/537.36    </p>
<p>Form Data:<br>    passport:13725168940<br>    password:aaa00000000</p>
<h2 id="3-2-模拟登录"><a href="#3-2-模拟登录" class="headerlink" title="3.2. 模拟登录"></a>3.2. 模拟登录</h2><h1 id="coding-utf-8"><a href="#coding-utf-8" class="headerlink" title="-- coding: utf-8 --"></a>-<em>- coding: utf-8 -</em>-</h1><figure class="highlight plain"><figcaption><span>requests</span></figcaption><table><tr><td class="code"><pre><span class="line">userAgent &#x3D; &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;63.0.3239.132 Safari&#x2F;537.36&quot;</span><br><span class="line">header &#x3D; &#123;</span><br><span class="line">    # &quot;origin&quot;: &quot;https:&#x2F;&#x2F;passport.mafengwo.cn&quot;,</span><br><span class="line">    &quot;Referer&quot;: &quot;https:&#x2F;&#x2F;passport.mafengwo.cn&#x2F;&quot;,</span><br><span class="line">    &#39;User-Agent&#39;: userAgent,</span><br><span class="line">&#125;</span><br><span class="line">def mafengwoLogin(account, password):</span><br><span class="line">    # 马蜂窝模仿 登录</span><br><span class="line">    print (&quot;开始模拟登录马蜂窝&quot;)</span><br><span class="line">    postUrl &#x3D; &quot;https:&#x2F;&#x2F;passport.mafengwo.cn&#x2F;login&#x2F;&quot;</span><br><span class="line">    postData &#x3D; &#123;</span><br><span class="line">        &quot;passport&quot;: account,</span><br><span class="line">        &quot;password&quot;: password,</span><br><span class="line">    &#125;</span><br><span class="line">    responseRes &#x3D; requests.post(postUrl, data &#x3D; postData, headers &#x3D; header)</span><br><span class="line">    # 无论是否登录成功，状态码一般都是 statusCode &#x3D; 200</span><br><span class="line">    print(f&quot;statusCode &#x3D; &#123;responseRes.status_code&#125;&quot;)</span><br><span class="line">    print(f&quot;text &#x3D; &#123;responseRes.text&#125;&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line"># 从返回结果来看，有登录成功</span><br><span class="line">    mafengwoLogin(&quot;13756567832&quot;, &quot;000000001&quot;)</span><br><span class="line">一般来说，调试期，判断是否登录成功的最简单的方法：就是直接打印登录之后的text内容，使用错误的用户名登录，和使用正确的用户名登录，对比打印输出的内容。</span><br><span class="line">后面通过学习我们会提出相对来说更好的判断方式…</span><br></pre></td></tr></table></figure>
<h2 id="3-3-使用cookie访问站点"><a href="#3-3-使用cookie访问站点" class="headerlink" title="3.3. 使用cookie访问站点"></a>3.3. 使用cookie访问站点</h2><p>在上一步，我们已经成功登录到马蜂窝网站了。那么接下来要如何访问站点中其他页面呢。前面提到过，网站是通过cookie和session来标记是哪个用户访问的。所以，在我们登录成功之后，有很重要的一步，就是我们需要把cookie保存下来，下一次请求这个站点的页面时，把这个cookie带过去。</p>
<h3 id="3-3-1-保存cookie信息"><a href="#3-3-1-保存cookie信息" class="headerlink" title="3.3.1. 保存cookie信息"></a>3.3.1. 保存cookie信息</h3><p>修改代码，加入cookie保存机制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import requests</span><br><span class="line"># python2 和 python3的兼容代码</span><br><span class="line">try:</span><br><span class="line">    # python2 中</span><br><span class="line">    import cookielib</span><br><span class="line">    print(f&quot;user cookielib in python2.&quot;)</span><br><span class="line">except:</span><br><span class="line">    # python3 中</span><br><span class="line">    import http.cookiejar as cookielib</span><br><span class="line">    print(f&quot;user cookielib in python3.&quot;)</span><br><span class="line"></span><br><span class="line"># session代表某一次连接</span><br><span class="line">mafengwoSession &#x3D; requests.session()</span><br><span class="line"># 因为原始的session.cookies 没有save()方法，所以需要用到cookielib中的方法LWPCookieJar，这个类实例化的cookie对象，就可以直接调用save方法。</span><br><span class="line">mafengwoSession.cookies &#x3D; cookielib.LWPCookieJar(filename &#x3D; &quot;mafengwoCookies.txt&quot;)</span><br><span class="line"></span><br><span class="line">userAgent &#x3D; &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;63.0.3239.132 Safari&#x2F;537.36&quot;</span><br><span class="line">header &#x3D; &#123;</span><br><span class="line">    # &quot;origin&quot;: &quot;https:&#x2F;&#x2F;passport.mafengwo.cn&quot;,</span><br><span class="line">    &quot;Referer&quot;: &quot;https:&#x2F;&#x2F;passport.mafengwo.cn&#x2F;&quot;,</span><br><span class="line">    &#39;User-Agent&#39;: userAgent,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def mafengwoLogin(account, password):</span><br><span class="line">    # 马蜂窝模仿 登录</span><br><span class="line">    print(&quot;开始模拟登录马蜂窝&quot;)</span><br><span class="line"></span><br><span class="line">    postUrl &#x3D; &quot;https:&#x2F;&#x2F;passport.mafengwo.cn&#x2F;login&#x2F;&quot;</span><br><span class="line">    postData &#x3D; &#123;</span><br><span class="line">        &quot;passport&quot;: account,</span><br><span class="line">        &quot;password&quot;: password,</span><br><span class="line">    &#125;</span><br><span class="line">    # 使用session直接post请求</span><br><span class="line">    responseRes &#x3D; mafengwoSession.post(postUrl, data &#x3D; postData, headers &#x3D; header)</span><br><span class="line">    # 无论是否登录成功，状态码一般都是 statusCode &#x3D; 200</span><br><span class="line">    print(f&quot;statusCode &#x3D; &#123;responseRes.status_code&#125;&quot;)</span><br><span class="line">    print(f&quot;text &#x3D; &#123;responseRes.text&#125;&quot;)</span><br><span class="line">    # 登录成功之后，将cookie保存在本地文件中，好处是，以后再去获取马蜂窝首页的时候，就不需要再走mafengwoLogin的流程了，因为已经从文件中拿到cookie了</span><br><span class="line">    mafengwoSession.cookies.save()</span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    # 从返回结果来看，有登录成功</span><br><span class="line">    # mafengwoLogin(&quot;13756567832&quot;, &quot;000000001&quot;)</span><br><span class="line">cookie保存结果如下：</span><br><span class="line"># 文件：mafengwoCookies.txt</span><br><span class="line">#LWP-Cookies-2.0</span><br><span class="line">Set-Cookie3: __today_login&#x3D;1; path&#x3D;&quot;&#x2F;&quot;; domain&#x3D;&quot;.mafengwo.cn&quot;; path_spec; domain_dot; expires&#x3D;&quot;2018-03-16 15:56:15Z&quot;; httponly&#x3D;None; version&#x3D;0</span><br><span class="line">Set-Cookie3: mafengwo&#x3D;&quot;0a60e1a04f6a6f5555f0e285602b5b17_94281374_5aab641fb23d42.37804626_5aab641fb23dc3.28763728&quot;; path&#x3D;&quot;&#x2F;&quot;; domain&#x3D;&quot;.mafengwo.cn&quot;; path_spec; domain_dot; expires&#x3D;&quot;2018-06-13 06:25:03Z&quot;; httponly&#x3D;None; version&#x3D;0</span><br><span class="line">Set-Cookie3: mfw_uuid&#x3D;&quot;5aab641f-b789-96ef-736d-48640285f4c0&quot;; path&#x3D;&quot;&#x2F;&quot;; domain&#x3D;&quot;.mafengwo.cn&quot;; path_spec; domain_dot; expires&#x3D;&quot;2019-03-16 06:25:03Z&quot;; version&#x3D;0</span><br><span class="line">Set-Cookie3: oad_n&#x3D;&quot;a%3A3%3A%7Bs%3A3%3A%22oid%22%3Bi%3A1029%3Bs%3A2%3A%22dm%22%3Bs%3A20%3A%22passport.mafengwo.cn%22%3Bs%3A2%3A%22ft%22%3Bs%00009%3A%222018-03-16+14%3A28%3A47%22%3B%7D&quot;; path&#x3D;&quot;&#x2F;&quot;; domain&#x3D;&quot;.mafengwo.cn&quot;; path_spec; domain_dot; expires&#x3D;&quot;2018-03-23 06:25:03Z&quot;; version&#x3D;0</span><br><span class="line">Set-Cookie3: uol_throttle&#x3D;94281374; path&#x3D;&quot;&#x2F;&quot;; domain&#x3D;&quot;.mafengwo.cn&quot;; path_spec; domain_dot; expires&#x3D;&quot;2018-03-16 06:35:03Z&quot;; version&#x3D;0</span><br></pre></td></tr></table></figure>
<h3 id="3-3-2-使用cookie登录"><a href="#3-3-2-使用cookie登录" class="headerlink" title="3.3.2. 使用cookie登录"></a>3.3.2. 使用cookie登录</h3><p>为了测试访问页面时，是否处于登录状态。有一个比较巧妙的方法：就是直接访问一个需要登录后，才可见的地址。比如说涉及到用户信息的页面。下面以 “我的路线” 页面为例：<a href="http://www.mafengwo.cn/plan/route.php" target="_blank" rel="noopener">http://www.mafengwo.cn/plan/route.php</a><br>这是登录状态后见到的页面：<br><img src="/images/2020/07/13/a95ff71a-ddb6-4f42-88c5-d510422b36ae.png" alt="image.png"><br><img src="/images/2020/07/13/61fa814a-a32c-4240-9203-f3bf8f937b35.png" alt="image.png"><br>如果是 非登录状态，会自动跳转（重定向302）到 用户登录页面<br><img src="/images/2020/07/13/a499ba31-7049-4d2d-9f2d-9ef1e431ccd8.png" alt="image.png"><br>所以，我们可以用这个页面判断cookie登录是否成功，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line"># python2 和 python3的兼容代码</span><br><span class="line">try:</span><br><span class="line">    # python2 中</span><br><span class="line">    import cookielib</span><br><span class="line">    print(f&quot;user cookielib in python2.&quot;)</span><br><span class="line">except:</span><br><span class="line">    # python3 中</span><br><span class="line">    import http.cookiejar as cookielib</span><br><span class="line">    print(f&quot;user cookielib in python3.&quot;)</span><br><span class="line"></span><br><span class="line"># session代表某一次连接</span><br><span class="line">mafengwoSession &#x3D; requests.session()</span><br><span class="line"># 因为原始的session.cookies 没有save()方法，所以需要用到cookielib中的方法LWPCookieJar，这个类实例化的cookie对象，就可以直接调用save方法。</span><br><span class="line">mafengwoSession.cookies &#x3D; cookielib.LWPCookieJar(filename &#x3D; &quot;mafengwoCookies.txt&quot;)</span><br><span class="line"></span><br><span class="line">userAgent &#x3D; &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;63.0.3239.132 Safari&#x2F;537.36&quot;</span><br><span class="line">header &#x3D; &#123;</span><br><span class="line">    # &quot;origin&quot;: &quot;https:&#x2F;&#x2F;passport.mafengwo.cn&quot;,</span><br><span class="line">    &quot;Referer&quot;: &quot;https:&#x2F;&#x2F;passport.mafengwo.cn&#x2F;&quot;,</span><br><span class="line">    &#39;User-Agent&#39;: userAgent,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def isLoginStatus():</span><br><span class="line">    # 通过访问个人中心页面的返回状态码来判断是否为登录状态</span><br><span class="line"></span><br><span class="line">    routeUrl &#x3D; &quot;http:&#x2F;&#x2F;www.mafengwo.cn&#x2F;plan&#x2F;route.php&quot;</span><br><span class="line">    # 下面有两个关键点</span><br><span class="line">        # 第一个是header，如果不设置，会返回500的错误</span><br><span class="line">        # 第二个是allow_redirects，如果不设置，session访问时，服务器返回302，</span><br><span class="line">        # 然后session会自动重定向到登录页面，获取到登录页面之后，变成200的状态码</span><br><span class="line">        # allow_redirects &#x3D; False  就是不允许重定向</span><br><span class="line">    responseRes &#x3D; mafengwoSession.get(routeUrl, headers &#x3D; header, allow_redirects &#x3D; False)</span><br><span class="line">    print(f&quot;isLoginStatus &#x3D; &#123;responseRes.status_code&#125;&quot;)</span><br><span class="line">    if responseRes.status_code !&#x3D; 200:</span><br><span class="line">        return False</span><br><span class="line">    else:</span><br><span class="line">        return True</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    mafengwoSession.cookies.load()</span><br><span class="line">    isLogin &#x3D; isLoginStatus()</span><br><span class="line">    print(f&quot;is login mafengwo &#x3D; &#123;isLogin&#125;&quot;)</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">        # 按照之前保存过的mafengwoCookies.txt登录，属于登录状态：</span><br><span class="line">        user cookielib in python3.</span><br><span class="line">        isLoginStatus &#x3D; 200</span><br><span class="line">        is login mafengwo &#x3D; True</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">        # 如果把mafengwoCookies.txt中的信息修改掉之后，就无法登录了，属于非登录状态了</span><br><span class="line">        user cookielib in python3.</span><br><span class="line">        isLoginStatus &#x3D; 302</span><br><span class="line">        is login mafengwo &#x3D; False</span><br><span class="line">    &#39;&#39;&#39;</span><br></pre></td></tr></table></figure>
<h2 id="3-4-最终形成的登录模式"><a href="#3-4-最终形成的登录模式" class="headerlink" title="3.4. 最终形成的登录模式"></a>3.4. 最终形成的登录模式</h2><p>因为cookie是有有效期的，所以没法做到一次登录，终生有效。所以，一般的登录模式，就是：<br>第一步：先尝试cookie登录<br>第二步：如果cookie无法登录成功，就使用用户名密码登录，将新的cookie保存下来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import requests</span><br><span class="line"># python2 和 python3的兼容代码</span><br><span class="line">try:</span><br><span class="line">    # python2 中</span><br><span class="line">    import cookielib</span><br><span class="line">    print(f&quot;user cookielib in python2.&quot;)</span><br><span class="line">except:</span><br><span class="line">    # python3 中</span><br><span class="line">    import http.cookiejar as cookielib</span><br><span class="line">    print(f&quot;user cookielib in python3.&quot;)</span><br><span class="line"># session代表某一次连接</span><br><span class="line">mafengwoSession &#x3D; requests.session()</span><br><span class="line"># 因为原始的session.cookies 没有save()方法，所以需要用到cookielib中的方法LWPCookieJar，这个类实例化的cookie对象，就可以直接调用save方法。</span><br><span class="line">mafengwoSession.cookies &#x3D; cookielib.LWPCookieJar(filename &#x3D; &quot;mafengwoCookies.txt&quot;)</span><br><span class="line">userAgent &#x3D; &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;63.0.3239.132 Safari&#x2F;537.36&quot;</span><br><span class="line">header &#x3D; &#123;</span><br><span class="line">    # &quot;origin&quot;: &quot;https:&#x2F;&#x2F;passport.mafengwo.cn&quot;,</span><br><span class="line">    &quot;Referer&quot;: &quot;https:&#x2F;&#x2F;passport.mafengwo.cn&#x2F;&quot;,</span><br><span class="line">    &#39;User-Agent&#39;: userAgent,</span><br><span class="line">&#125;</span><br><span class="line"># 马蜂窝模仿 登录</span><br><span class="line">def mafengwoLogin(account, password):</span><br><span class="line">    print(&quot;开始模拟登录马蜂窝&quot;)</span><br><span class="line">    postUrl &#x3D; &quot;https:&#x2F;&#x2F;passport.mafengwo.cn&#x2F;login&#x2F;&quot;</span><br><span class="line">    postData &#x3D; &#123;</span><br><span class="line">        &quot;passport&quot;: account,</span><br><span class="line">        &quot;password&quot;: password,</span><br><span class="line">    &#125;</span><br><span class="line">    # 使用session直接post请求</span><br><span class="line">    responseRes &#x3D; mafengwoSession.post(postUrl, data &#x3D; postData, headers &#x3D; header)</span><br><span class="line">    # 无论是否登录成功，状态码一般都是 statusCode &#x3D; 200</span><br><span class="line">    print(f&quot;statusCode &#x3D; &#123;responseRes.status_code&#125;&quot;)</span><br><span class="line">    print(f&quot;text &#x3D; &#123;responseRes.text&#125;&quot;)</span><br><span class="line">    # 登录成功之后，将cookie保存在本地文件中，好处是，以后再去获取马蜂窝首页的时候，就不需要再走mafengwoLogin的流程了，因为已经从文件中拿到cookie了</span><br><span class="line">    mafengwoSession.cookies.save()</span><br><span class="line"># 通过访问个人中心页面的返回状态码来判断是否为登录状态</span><br><span class="line">def isLoginStatus():</span><br><span class="line">    routeUrl &#x3D; &quot;http:&#x2F;&#x2F;www.mafengwo.cn&#x2F;plan&#x2F;route.php&quot;</span><br><span class="line">    # 下面有两个关键点</span><br><span class="line">        # 第一个是header，如果不设置，会返回500的错误</span><br><span class="line">        # 第二个是allow_redirects，如果不设置，session访问时，服务器返回302，</span><br><span class="line">        # 然后session会自动重定向到登录页面，获取到登录页面之后，变成200的状态码</span><br><span class="line">        # allow_redirects &#x3D; False  就是不允许重定向</span><br><span class="line">    responseRes &#x3D; mafengwoSession.get(routeUrl, headers &#x3D; header, allow_redirects &#x3D; False)</span><br><span class="line">    print(f&quot;isLoginStatus &#x3D; &#123;responseRes.status_code&#125;&quot;)</span><br><span class="line">    if responseRes.status_code !&#x3D; 200:</span><br><span class="line">        return False</span><br><span class="line">    else:</span><br><span class="line">        return True</span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    # 第一步：尝试使用已有的cookie登录</span><br><span class="line">    mafengwoSession.cookies.load()</span><br><span class="line">    isLogin &#x3D; isLoginStatus()</span><br><span class="line">    print(f&quot;is login mafengwo &#x3D; &#123;isLogin&#125;&quot;)</span><br><span class="line">    if isLogin &#x3D;&#x3D; False:</span><br><span class="line">        # 第二步：如果cookie已经失效了，那就尝试用帐号登录</span><br><span class="line">        print(f&quot;cookie失效，用户重新登录...&quot;)</span><br><span class="line">        mafengwoLogin(&quot;13756567832&quot;, &quot;000000001&quot;)</span><br><span class="line">    resp &#x3D; mafengwoSession.get(&quot;http:&#x2F;&#x2F;www.mafengwo.cn&#x2F;plan&#x2F;fav_type.php&quot;, headers &#x3D; header, allow_redirects &#x3D; False)</span><br><span class="line">    print(f&quot;resp.status &#x3D; &#123;resp.status_code&#125;&quot;)</span><br><span class="line"># 第一次运行程序的输出：</span><br><span class="line"># 由于第一次还没有生成cookie，所以需要用账户登录一次</span><br><span class="line">user cookielib in python3.</span><br><span class="line">isLoginStatus &#x3D; 302</span><br><span class="line">is login mafengwo &#x3D; False</span><br><span class="line">cookie失效，用户重新登录...</span><br><span class="line">开始模拟登录马蜂窝</span><br><span class="line">statusCode &#x3D; 200</span><br><span class="line">……………………</span><br><span class="line">resp.status &#x3D; 200</span><br><span class="line"># 第二次运行程序的输出：</span><br><span class="line"># 第二次，就直接使用cookie登录了，不再需要使用帐号登录</span><br><span class="line"></span><br><span class="line">user cookielib in python3.</span><br><span class="line">isLoginStatus &#x3D; 200</span><br><span class="line">is login mafengwo &#x3D; True</span><br><span class="line">resp.status &#x3D; 200</span><br><span class="line"> </span><br><span class="line">注意事项</span><br><span class="line">try:</span><br><span class="line">        _se.cookies.load()</span><br><span class="line">        isLogin &#x3D; isLoginStatus()</span><br><span class="line">    except FileNotFoundError:</span><br><span class="line">        isLogin &#x3D; False</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python四种验证码解决思路</title>
    <url>/python%E5%9B%9B%E7%A7%8D%E9%AA%8C%E8%AF%81%E7%A0%81%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>1.输入式验证码<br>这种验证码主要是通过用户输入图片中的字母、数字、汉字等进行验证。如下图<br>   <img src="/images/2020/07/12/1da1261d-7475-4dc7-881e-5ec5e0c54c7a.png" alt="image.png">图1 <img src="/images/2020/07/12/0ab1686e-60ef-4c4d-a270-81f201490751.png" alt="image.png">图2</p>
<p>解决思路：这种是最简单的一种，只要识别出里面的内容，然后填入到输入框中即可。这种识别技术叫OCR，这里我们推荐使用Python的第三方库，tesserocr。对于没有什么背影影响的验证码如图2，直接通过这个库来识别就可以。但是对于有嘈杂的背景的验证码这种，直接识别识别率会很低，遇到这种我们就得需要先处理一下图片，先对图片进行灰度化，然后再进行二值化，再去识别，这样识别率会大大提高。</p>
<p>2.滑动式验证码<br>这种是将备选碎片直线滑动到正确的位置，如下图<br>  <img src="/images/2020/07/12/4d51b6de-7a6a-4c5b-ac9b-c7a3fe476435.png" alt="image.png">)<img src="/images/2020/07/12/356a818d-718f-4a6f-9576-ff91724f8c4c.png" alt="image.png"></p>
<p>解决思路：对于这种验证码就比较复杂一点，但也是有相应的办法。我们直接想到的就是模拟人去拖动验证码的行为，点击按钮，然后看到了缺口  的位置，最后把拼图拖到缺口位置处完成验证。</p>
<p>第一步：点击按钮。然后我们发现，在你没有点击按钮的时候那个缺口和拼图是没有出现的，点击后才出现，这为我们找到缺口的位置提供了灵感。</p>
<p>第二步：拖到缺口位置。我们知道拼图应该拖到缺口处，但是这个距离如果用数值来表示？通过我们第一步观察到的现象，我们可以找到缺口的位置。这里我们可以比较两张图的像素，设置一个基准值，如果某个位置的差值超过了基准值，那我们就找到了这两张图片不一样的位置，当然我们是从那块拼图的右侧开始并且从左到右，找到第一个不一样的位置时就结束，这是的位置应该是缺口的left，所以我们使用selenium拖到这个位置即可。这里还有个疑问就是如何能自动的保存这两张图？这里我们可以先找到这个标签，然后获取它的location和size，然后 top，bottom，left，right = location[‘y’] ,location[‘y’]+size[‘height’]+ location[‘x’] + size[‘width’]  ,然后截图，最后抠图填入这四个位置就行。具体的使用可以查看selenium文档，点击按钮前抠张图，点击后再抠张图。最后拖动的时候要需要模拟人的行为，先加速然后减速。因为这种验证码有行为特征检测，人是不可能做到一直匀速的，否则它就判定为是机器在拖动，这样就无法通过验证了。</p>
<p>3.点击式的图文验证 和  图标选择<br>图文验证：通过文字提醒用户点击图中相同字的位置进行验证。</p>
<p>图标选择： 给出一组图片，按要求点击其中一张或者多张。借用万物识别的难度阻挡机器。</p>
<p>这两种原理相似，只不过是一个是给出文字，点击图片中的文字，一个是给出图片，点出内容相同的图片。</p>
<p>这两种没有特别好的方法，只能借助第三方识别接口来识别出相同的内容，推荐一个超级鹰，把验证码发过去，会返回相应的点击坐标。</p>
<p>然后再使用selenium模拟点击即可。具体怎么获取图片和上面方法一样。</p>
<p>4.宫格验证码</p>
<p><img src="/images/2020/07/12/b3c00b2d-0545-4167-93f6-fc6272641263.png" alt="image.png"><br>这种就很棘手，每一次出现的都不一样，但是也会出现一样的。而且拖动顺序都不一样。</p>
<p>但是我们发现不一样的验证码个数是有限的，这里采用模版匹配的方法。我觉得就好像暴力枚举，把所有出现的验证码保存下来，然后挑出不一样的验证码，按照拖动顺序命名，我们从左到右上下到下，设为1,2,3,4。上图的滑动顺序为4,3,2,1所以我们命名4_3_2_1.png，这里得手动搞。当验证码出现的时候，用我们保存的图片一一枚举，与出现这种比较像素，方法见上面。如果匹配上了，拖动顺序就为4,3,2,1。然后使用selenium模拟即可。</p>
<p>python中的验证码识别库PyTesser</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>最强下载神器IDM</title>
    <url>/%E6%9C%80%E5%BC%BA%E4%B8%8B%E8%BD%BD%E7%A5%9E%E5%99%A8IDM.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>Internet Download Manager，简称 IDM，是国外的一款优秀下载工具。目前凭借着下载计算的速度优势在外媒网站中均受好评，现在已被多数国人熟知。Internet Download Manager 提升你的下载速度最多达5倍，安排下载时程，带有续传功能，可以恢复因为断线、网络问题、计算机当机甚至无预警的停电导致下传到一半的资料。国外的Internet Download Manager简称IDM是一款下载利器，不限速，界面简洁好看，还能自动识别网页视频，无多余菜单弹窗!并且支持IE，Firefox，Chrome等浏览器。<br>IDM具有动态文件分割、多重下载点技术，而且它会重复使用现有的联机，而不需再重新联机登入一遍。智能in-speed技术会动态地将所有设定应用到某种联机类型，以充分利用下载速度。IDM支持下载队列、防火墙、代理服务器和映摄服务器、重新导向、cookies、需要验证的目录，以及各种不同的服务器平台，它紧密地与Internet Explorer和Netscape Communicator结合，自动地处理你的下载需求。此外，IDM还具有下载逻辑最佳化功能、检查病毒，以及多种偏好设定。</p>
<h2 id="安装方法："><a href="#安装方法：" class="headerlink" title="安装方法："></a>安装方法：</h2><p>下载后解压&gt;找到!绿化卸载.bat&gt;右键以管理员身份运行。<br><img src="/images/2020/07/06/c308e0eb-9028-44a9-a29f-75c3d655b29b.png" alt="image.png"><br>输入1,回车确定安装。<br><img src="/images/2020/07/06/b22014f1-eca2-455f-9453-7b1b75de180a.png" alt="image.png"><br>强烈建议创建快捷方式。<br><img src="/images/2020/07/06/c769bb97-c8c1-4c03-b5b3-3539988b0b68.png" alt="image.png"><br>主界面就是这个样子了，还算简洁，最起码没广告。<br><img src="/images/2020/07/06/e072019d-34b3-4f6f-aeca-80fdf540613e.png" alt="image.png"><br>下面是个人推荐下载地址：<a href="http://soft.ucbug.com/uploads/soft/linshi/wlrj/ucbug.com-idm.rar" target="_blank" rel="noopener">idm下载</a></p>
]]></content>
      <categories>
        <category>插件</category>
      </categories>
      <tags>
        <tag>IDM</tag>
      </tags>
  </entry>
  <entry>
    <title>元数据库安装配置</title>
    <url>/%E5%85%83%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="1、下载Mysql-yum-仓库"><a href="#1、下载Mysql-yum-仓库" class="headerlink" title="1、下载Mysql yum 仓库"></a>1、下载Mysql yum 仓库</h1><p><img src="/images/2020/07/04/2f5b1866-edd9-4e32-bff4-8d5464bf4a97.png" alt="image.png"></p>
<h1 id="2、添加Mysql-yum-仓库"><a href="#2、添加Mysql-yum-仓库" class="headerlink" title="2、添加Mysql yum 仓库"></a>2、添加Mysql yum 仓库</h1><p><img src="/images/2020/07/04/e5596132-16ce-4edc-a81a-dae6715c3173.png" alt="image.png"></p>
<h1 id="3、让安装包可用"><a href="#3、让安装包可用" class="headerlink" title="3、让安装包可用"></a>3、让安装包可用</h1><p><img src="/images/2020/07/04/466e06c3-1fba-4786-b8b6-1179ca7db91d.png" alt="image.png"></p>
<h1 id="4、安装Mysql"><a href="#4、安装Mysql" class="headerlink" title="4、安装Mysql"></a>4、安装Mysql</h1><p><img src="/images/2020/07/04/5cd8776c-1cd8-413a-bacf-138f85b63c91.png" alt="image.png"></p>
<h1 id="5、启动Mysql服务"><a href="#5、启动Mysql服务" class="headerlink" title="5、启动Mysql服务"></a>5、启动Mysql服务</h1><p><img src="/images/2020/07/04/4e17769e-f249-4501-94ff-534e2319ed57.png" alt="image.png"></p>
<h1 id="6、修改Mysql数据库"><a href="#6、修改Mysql数据库" class="headerlink" title="6、修改Mysql数据库"></a>6、修改Mysql数据库</h1><p><img src="/images/2020/07/04/f3ceef96-7015-4999-8f5e-0a66d4195f01.png" alt="image.png"></p>
<h1 id="7、设置数据库访问权限"><a href="#7、设置数据库访问权限" class="headerlink" title="7、设置数据库访问权限"></a>7、设置数据库访问权限</h1><p><img src="/images/2020/07/04/c33b7323-7b83-4ac2-af77-c285cab2d029.png" alt="image.png"><br><img src="/images/2020/07/04/980eddfc-3321-48e2-a33e-6bf0ad381013.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>HIve</tag>
      </tags>
  </entry>
  <entry>
    <title>数据预处理</title>
    <url>/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>在数据挖掘中，海量的原始数据中存在着这大量不完整（有缺失值）、不一致、有异常的数据，严重影响到数据挖掘建模的执行效率，甚至可能导致挖掘结果的偏差，所以进行数据清洗就显得尤为重要，数据清洗完成后接着进行或者同时进行数据继承、转换、规约等一系列的处理，该过程就是数据预处理。<br>      数据预处理一方面是要提高数据的质量，另一个方面是要让数据更好地适应特定挖掘技术或工具。统计发现，在数据挖掘的过程中，数据预处理工作量占到了整个过程的60%<br>数据预处理框架图<br><img src="/images/2020/07/14/5671eb5f-c0c8-4354-9ea3-efc6d4c1808d.png" alt="image.png">数据清洗<br>      数据清洗主要是删除原始数据集中的无关数据、重复数据，平滑噪声数据，筛选掉与挖掘主题无关的数据，处理缺失值、异常值等。</p>
<h1 id="缺失值的处理"><a href="#缺失值的处理" class="headerlink" title="缺失值的处理"></a>缺失值的处理</h1><p>处理缺失值的方法可以分为三类：<br>删除记录<br>数据插补<br>不处理<br> ::: hljs-center</p>
<p>常用的插补方法</p>
<p>:::</p>
<p>  <img src="/images/2020/07/14/b818c5b9-ac4c-410a-b403-8db8a77f99cd.png" alt="image.png"><br>插值法：<br>拉格朗日插值法<br>Hermite插值<br>牛顿插值法<br>分段插值<br>样条插值<br>      如果通过简单的删除小部分记录达到既定的目标，那么删除含有缺失值的记录的方法是最有效的。然而，这种方法却有很大的局限性。它是以减少历史数据来换取数据的完备，会造成资源的大量浪费，将丢弃了大量隐藏在这些记录中的信息。尤其是在数据集本来就包含很少纪录的情况下，删除少量记录可能会严重影响到分析结果的客观性和正确性。一些模型可以将缺失值视作一种特殊的取值，允许直接在含有缺失值的数据上进行建模。<br>异常值处理<br>      在数据预处理时，异常值是否剔除，需视具体情况而定，因为有些异常值可能蕴含着有用的信息。<br>::: hljs-center</p>
<p>异常值处理常用方法 </p>
<p>:::<br>  <img src="/images/2020/07/14/6c47b79b-0d9e-42b6-a5c8-5feabc961821.png" alt="image.png">将含有异常值的记录直接删除的方法简单易行，但缺点也很明显，在观测值很少的情况下，这种删除会造成样本量不足，可能会改变变量的原有分布，从而造成分析结果的不准确。视为缺失值处理的好处是可以利用现有变量的信息，对异常值（缺失值）进行填补。<br>      在很多情况下，要先分析异常值出现的可能原因，在判断异常值是否应该舍弃，如果是正确的数据，可以直接在具有异常值的数据集上进行挖掘建模。</p>
<h1 id="数据集成"><a href="#数据集成" class="headerlink" title="数据集成"></a>数据集成</h1><p>数据挖掘需要的数据往往分布在不同的数据源中，数据集成就是将多个数据源合并存放在一个一致的数据存储（数据仓库）中的过程。<br>      在数据集成时，来自多个数据源的现实世界实体的表达形式是不一样的，有可能不匹配，要考虑实体识别问题和属性冗余问题，从而将数据源在最底层上加以转换、提炼和集成。<br>实体识别<br>实体识别是指从不同数据源识别出现实世界的实体，它的任务是统一不同源数据的矛盾之处，常见形式如下：</p>
<h1 id="同名异义"><a href="#同名异义" class="headerlink" title="同名异义"></a>同名异义</h1><p>数据源A中的属性ID和数据源中的属性ID分别描述的是学生编号和科目编号，即描述的是不同的实体。</p>
<h1 id="异名同义"><a href="#异名同义" class="headerlink" title="异名同义"></a>异名同义</h1><p>数据源A中dt和数据源B中的date都是描述日期的。</p>
<h1 id="单位不统一"><a href="#单位不统一" class="headerlink" title="单位不统一"></a>单位不统一</h1><p>描述同一个实体分别用的是国际单位和中国传统的计量单位，检测和解决这些冲突就是实体识别的任务。</p>
<h1 id="冗余属性识别"><a href="#冗余属性识别" class="headerlink" title="冗余属性识别"></a>冗余属性识别</h1><p>数据冗余情况：<br>同一属性多次出现。<br>同一属性命名不一致导致重复。<br>      仔细整合不同数据源减少甚至避免数据冗余与不一致，从而提高数据挖掘的速度和质量。对于冗余属性要先分析，检测到后再将其删除。<br>      有些冗余属性可以用相关分析检测。给定两个数值型A和B，根据其属性值，用相关系数度量一个属性在多大程度上蕴含另一个属性。</p>
<h1 id="数据变换"><a href="#数据变换" class="headerlink" title="数据变换"></a>数据变换</h1><p>数据变换主要是对数据进行规范化处理，将数据转化成“适当的”形式，以适用于挖掘任务及算法的需要。</p>
<p>方便置信区间分析或者可视化 (缩放数据， 对称分布)。<br>为了获取更容易解释的特征 (获取线性特征)。<br>降低数据的维度或者复杂度。<br>方便使用简单的回归模型。<br>简单的数据变换<br>      简单的函数变换常用来将不具有正态分布非数据变换成具有正态分布的数据。在时间序列分析中，有时简单的对数变换或者差分运算就可以将非平稳序列转换成平稳序列。<br>::: hljs-center</p>
<p>常用简单的函数表</p>
<p>:::<br><img src="/images/2020/07/14/b3e224bb-c0f8-474e-9ea3-e3d750a4d55f.png" alt="image.png"></p>
<h1 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h1><p>数据规范化（归一化）处理是数据挖掘的一项基础工作。不同评价指标往往具有不同的量纲， 数之间的差别可能很大，不进行处理会影响到数据分析的结果。为了消除指标之间的量纲和取值范围差异的影响，需要进行标准化处理，将数据按照比例进行缩放，使之落入特定的区域，便于进行综合分析。<br>把数据映射到[0,1]的区间中。<br>把有量纲形式变成无量纲形式 。<br>::: hljs-center</p>
<p>常用的规范化方法</p>
<p>:::<br><img src="/images/2020/07/14/66d45649-4790-4442-a499-6282b49d09de.png" alt="image.png"></p>
<h1 id="连续属性离散化"><a href="#连续属性离散化" class="headerlink" title="连续属性离散化"></a>连续属性离散化</h1><p> 一些数据挖掘算法，特别是某些分类算法（ID3算法、Apripri算法等）、要求数据是分类属性形式。这样，常常需要将连续属性变换换成分类属性，即连续属性离散化。</p>
<h3 id="离散化过程"><a href="#离散化过程" class="headerlink" title="离散化过程"></a>离散化过程</h3><p>连续属性的离散化就是在数据的取值范围内设定若干个离散的划分点，将取值范围划分为一些离散化的区间，最后用不同的符号或整数值代表落在每个子区间中的数据值。所以，离散化涉及两个任务：确定分类数以及如何将连续属性值映射到这些分类值。</p>
<h3 id="常用的离散化方法"><a href="#常用的离散化方法" class="headerlink" title="常用的离散化方法"></a>常用的离散化方法</h3><p><img src="/images/2020/07/14/03344607-bc7c-4beb-8e45-80892039794b.png" alt="image.png"></p>
<h1 id="属性构造"><a href="#属性构造" class="headerlink" title="属性构造"></a>属性构造</h1><p>在数据挖掘的过程中，为了提取更有用的信息，挖掘更深层次的模式，提高挖掘结果的精度，需要利用已有的属性集构造出新的属性，并加入到现有的属性集合中。</p>
<h1 id="数据规约"><a href="#数据规约" class="headerlink" title="数据规约"></a>数据规约</h1><p>在大数据集上进行复杂的数据分析和挖掘需要很长的时间，数据归约产生更小但保持原数据完整性的新数据集。在规约后的数据集上进行分析和挖掘将更有效率。<br>数据规约的意义：</p>
<p>降低无效、错误数据对建模的影响，提高建模的准确性。<br>少量且代表性的数据将大幅缩减数据挖掘所需的时间。<br>降低存储数据的成本</p>
<h1 id="属性规约"><a href="#属性规约" class="headerlink" title="属性规约"></a>属性规约</h1><p> 属性规约通过属性合并来创建新属性维数，或者直接通过删除不相关（维）来减少数据维数，从而提高数据挖掘的效率、降低计算成本。属性规约的目标是寻找出最小的属性子集并确保新数据子集的概率分布尽可能地接近原来数据集的概率分布。<br><img src="/images/2020/07/14/a178a096-56b8-4052-a5de-ed5c2d47eec2.png" alt="image.png"></p>
<h1 id="数值规约"><a href="#数值规约" class="headerlink" title="数值规约"></a>数值规约</h1><p>数值规约值通过选择替代的、较少的数据来减少数据量，包括有参数和无参数方法两类。有参数方法是使用一个模型来评估数据，只需存放参数，而不需要存放实际数据，例如回归和对数线性模型。无参数方法就需要存放实际数据。</p>
<h3 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h3><p>直方图使用分箱来近似数据分布，是一种流行的数据归约形式。</p>
<h3 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h3><p>聚类技术将数据元组（即记录，数据表中的一行）视为对象。它将对象划分为簇，使一个簇中的对象相互“相似”，而与其他簇中的对象“相异”。在数据规约中，用数据的簇替换实际数据。该技术的有效性依赖于簇的定义是否符合数据的分布性质。</p>
<h3 id="抽样"><a href="#抽样" class="headerlink" title="抽样"></a>抽样</h3><p>抽样也是一种数据规约技术，它用比原始数据小得多的随机样本（子集）表示原始数据集。假定原始数据集D包含N个元组，可以采用抽样方法对D进行抽样。<br><strong>s个样本无放回简单随机抽样<br>s个样本有放回简单随机抽样<br>聚类抽样<br>分层抽样</strong></p>
<h3 id="参数回归"><a href="#参数回归" class="headerlink" title="参数回归"></a>参数回归</h3><p>简单线性模型和对数线性模型可以用来近似描述给定的数据。线性模型对数据建模，使之拟合一条直线。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫开发步骤流程简析</title>
    <url>/%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4%E6%B5%81%E7%A8%8B%E7%AE%80%E6%9E%90.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>爬虫的基本流程:<br>0.（预处理）<br>1.发起请求：<br>通过HTTP库向目标站点发起请求，即发送一个Request，请求可以包含额外的headers、data等信息，然后等待服务器响应。这个请求的过程就像我们打开浏览器，在浏览器地址栏输入网址：<a href="http://www.baidu.com，然后点击回车。这个过程其实就相当于浏览器作为一个浏览的客户端，向服务器端发送了" target="_blank" rel="noopener">www.baidu.com，然后点击回车。这个过程其实就相当于浏览器作为一个浏览的客户端，向服务器端发送了</a> 一次请求。</p>
<p>2.获取响应内容：<br>如果服务器能正常响应，我们会得到一个Response，Response的内容便是所要获取的内容，类型可能有HTML、Json字符串，二进制数据(图片，视频等）等类型。这个过程就是服务器接收客户端的请求，进过解析发送给浏览器的网页HTML文件。</p>
<p>3.解析内容：<br>得到的内容可能是HTML，可以使用正则表达式，网页解析库进行解析。也可能是Json，可以直接转为Json对象解析。可能是二进制数据，可以做保存或者进一步处理。这一步相当于浏览器把服务器端的文件获取到本地，再进行解释并且展现出来。</p>
<p>4.保存数据：<br>保存的方式可以是把数据存为文本，也可以把数据保存到数据库，或者保存为特定的jpg，mp4 等格式的文件。这就相当于我们在浏览网页时，下载了网页上的图片或者视频。</p>
<p>Scrapy爬虫开发流程一般包括如下步骤：<br>1）确定项目需求。<br>2）创建Scrapy项目。<br>3）定义页面提取的Item。<br>4）分析被爬对象页面。<br>5）编写爬取网站的Spider并提取Item。<br>6）编写Item Pipeline来存储提取到的Item（即数据）。<br>7）运行爬虫。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟化VMware ESXi 6.7服务器与vCenter的安装与配置</title>
    <url>/%E8%99%9A%E6%8B%9F%E5%8C%96VMware-ESXi-6-7%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8EvCenter%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h2 id="vSphere虚拟化架构"><a href="#vSphere虚拟化架构" class="headerlink" title="vSphere虚拟化架构"></a>vSphere虚拟化架构</h2><p>vSphere是VNware公司在2001年基于云计算推出的一套企业级虚拟化解决方案、核心组件为ESXi。如今，经历了5个版本的改进，已经实现了虚拟化基础架构、高可用性、集中管理、性能监控等一体化解决方案。</p>
<p><a href="https://baike.baidu.com/item/vSphere" target="_blank" rel="noopener">🔗详情点击</a><br>安装步骤<br>首先打开VMware workstation软件创建新的虚拟机并且采用自定义安装</p>
<p><img src="/images/2020/07/07/7bcaec75-a70d-4022-8dae-06470eea358e.png" alt="image.png">选择稍后安装一个操作系统</p>
<p><img src="/images/2020/07/07/ba64b5a3-4c77-4dc0-a5b0-520fd5a019e3.png" alt="image.png"><br>选择操作系统，点击VMware ESX选择版本为VMware ESXI 6.x的那个版本<br><img src="/images/2020/07/07/52325d15-2bb8-4365-a243-bcf2a2c7e94b.png" alt="image.png"></p>
<p>命名虚拟机名称并且选择虚拟机在自己电脑上的位置</p>
<p><img src="/images/2020/07/07/4d9bfa35-0585-4084-bd18-8a1f6112f329.png" alt="image.png"></p>
<p>选择处理器的配置，这里可以根据自己的需求选择</p>
<p><img src="/images/2020/07/07/582516fd-62d2-4f34-930b-4affae4836bc.png" alt="image.png"></p>
<p>选择网络类型，这里使用桥接网络</p>
<p><img src="/images/2020/07/07/40f98f7d-5cb1-480c-990e-6fdf135422ad.png" alt="image.png"></p>
<p>选择I/O控制器类型，选择为推荐的准虚拟化SCSI<br><img src="/images/2020/07/07/c1eca22a-0cc3-4174-affd-984f151bddd1.png" alt="image.png"></p>
<p>选择虚拟磁盘类型为SCSI</p>
<p><img src="/images/2020/07/07/c5389142-35cc-4c6c-a69b-51c5d63367b2.png" alt="image.png"></p>
<p>选择创建新的虚拟磁盘</p>
<p><img src="/images/2020/07/07/9640b004-2432-4158-a397-dec33ea63378.png" alt="image.png"></p>
<p>指定虚拟磁盘的容量大小，在这分配200GB空间具体根据自己需求</p>
<p><img src="/images/2020/07/07/13b1e0e0-15b4-4421-b092-1771ccd33db9.png" alt="image.png"></p>
<p>先不要点击完成，因为ESXI的镜像还没有挂载，点击自定义硬件</p>
<p><img src="/images/2020/07/07/9acb422c-bb75-4641-9cba-368d7d3b08b3.png" alt="image.png"></p>
<p>选择挂载自己电脑上的ISO镜像文件</p>
<p><img src="/images/2020/07/07/2f268ad5-32c3-4201-ab25-21d9ef1995b3.png" alt="image.png"></p>
<p>选择完成后点击关闭然后再点击完成，然后打开虚拟机。会出现如下的界面</p>
<p><img src="/images/2020/07/07/2721abcb-397e-4de2-a996-417821228115.png" alt="image.png"></p>
<p>等待片刻，按回车键开始安装</p>
<p><img src="/images/2020/07/07/684104e1-b05f-4598-9464-a5f5fe68eec8.png" alt="image.png"></p>
<p>按F11键接受协议并继续</p>
<p><img src="/images/2020/07/07/acd04bff-ce39-4224-b2c2-1fd8af495b0e.png" alt="image.png"></p>
<p>选择安装的位置并按回车键继续安装</p>
<p><img src="/images/2020/07/07/b4fef258-7294-423b-9c21-799f75910d8d.png" alt="image.png"></p>
<p>选择键盘布局，这里选择使用默认.</p>
<p><img src="/images/2020/07/07/ed2f25b5-61d0-4356-99d8-4d5e58406a6f.png" alt="image.png"></p>
<p>为root用户创建密码，需要选择安全性较高的的数字字母字符组合来作为密码</p>
<p><img src="/images/2020/07/07/0e84667b-7d98-416c-a5f6-5aa007215693.png" alt="image.png"></p>
<p>按下F11键开始正式的安装</p>
<p><img src="/images/2020/07/07/cc5559a3-0c8f-44ed-89ba-9d325796711b.png" alt="image.png"></p>
<p>接下来会进入这个安装进度界面，</p>
<p><img src="/images/2020/07/07/f93b1b24-bad1-4ee9-9fc8-281e35314a0a.png" alt="image.png"></p>
<p>等待2-3分钟后，安装完成按回车键重启系统</p>
<p><img src="/images/2020/07/07/ecf55256-b7fb-4dd9-91dd-a6a7b6be77fa.png" alt="image.png"></p>
<p>重启完成后界面如下</p>
<p><img src="/images/2020/07/07/dfd6d466-a9bf-47b3-9b89-aa2e43e81e13.png" alt="image.png"></p>
<p>对系统进行配置，按F2键然后输入刚才创建的密码进入配置界面。</p>
<p><img src="/images/2020/07/07/a1911cf5-a23e-4888-949c-fb69d27926c2.png" alt="image.png"></p>
<p>Configure Managment Network来配置网络。配置静态IPV4地址</p>
<p><img src="/images/2020/07/07/a2e19773-2470-4510-a3ad-9b8c668ad5b8.png" alt="image.png"></p>
<p>配置DNS服务器地址</p>
<p><img src="/images/2020/07/07/afe524fe-8c4d-4b29-a4c2-ee7b78c3fc92.png" alt="image.png"></p>
<p>按ESC键离开，会提示下面这个界面按Y同意重启网络</p>
<p><img src="/images/2020/07/07/ba6e1153-bf2a-43fc-9f3a-5b5c5715fd06.png" alt="image.png"></p>
<p>Troubleshooting Options来开启SSH与Shell</p>
<p><img src="/images/2020/07/07/e7bf600e-d87d-4925-9416-c9a2b87b4c88.png" alt="image.png"></p>
<p>到此为止配置上基本完成了，下面在浏览器地址栏中输入刚才配置的IP地址192.168.1.103使用web界面对ESXI进行控制。使用root用户登录</p>
<p><img src="/images/2020/07/07/805d2a5b-a964-414f-9ea9-a1bd16ea090a.png" alt="image.png"></p>
<h2 id="vCenter"><a href="#vCenter" class="headerlink" title="vCenter"></a>vCenter</h2><p>Vcenter一般指 VMware vCenter™ Server<br>VMware vCenterServer 提供了一个可伸缩、可扩展的平台，为 虚拟化管理奠定了基础。 VMware vCenter Server（以前称为 VMware VirtualCenter），可集中管理 VMware vSphere 环境，与其他管理平台相比，极大地提高了 IT 管理员对虚拟环境的控制。<br>VMware vCenter Server：提高在虚拟基础架构每个级别上的集中控制和可见性，通过主动管理发挥 vSphere 潜能，是一个具有广泛合作伙伴体系支持的可伸缩、可扩展平台。</p>
<p><a href="https://baike.baidu.com/item/vCenter" target="_blank" rel="noopener">🔗详情点击</a></p>
<h2 id="安装vCenter"><a href="#安装vCenter" class="headerlink" title="安装vCenter"></a>安装vCenter</h2><p>vCenter主要有两种:一种是基于Windows的vCenter server它的功能和性能更强大！还有一种就是基于嵌入式linux的vCenter server appliance，使用小的虚拟化环境（主机小于50台，虚拟机少于1000个），使用这个部署起来更简单快捷。当然如果更大的虚拟化环境，就一定需要基于Windows的vCenter server了。随着版本的更迭，vmware去windows化越来越明显了，很多高级功能（跨集群迁移，vcsa ha等等）只有以vcsa方式部署才可能实现了，vcsa部署维护都要比传统windows+vCenterServer+MySQL方便，就是web管理界面还是不如原来的vsphere client好用。</p>
<p><img src="/images/2020/07/07/94d52b8e-3461-48f4-b2eb-55904c4bcb07.png" alt="image.png"></p>
<p>安装vCenter server appliance<br>在Windows上装载镜像</p>
<p><img src="/images/2020/07/07/6802d789-1363-4e95-bbc0-50ce42e61865.png" alt="image.png">vcenter</p>
<p>然后打开vcsa-ui-installer那个文件夹，在打开下面的那个win32目录，双击installer.exe即可开始安装。</p>
<p><img src="/images/2020/07/07/09f8bcee-c68a-4ccf-84fd-5044d88f44e1.png" alt="image.png"></p>
<p>安装分为两个阶段</p>
<p><img src="/images/2020/07/07/37a72090-47e6-4105-a532-033f3f918931.png" alt="image.png"></p>
<p>勾选“我接受许可协议条款”</p>
<p><img src="/images/2020/07/07/8675eb99-4a6b-40c9-ba2d-c3d772a0c3bf.png" alt="image.png"></p>
<p>选择嵌入式 Platform Services Controller</p>
<p><img src="/images/2020/07/07/de346651-a018-40c6-becb-e9fa0c4cd9d6.png" alt="image.png"></p>
<p>指定VCSA 6.7部署到ESXi主机或vCenter Server</p>
<p><img src="/images/2020/07/07/b5aa3d3f-f48e-4dd7-add0-3ca5526442c2.png" alt="image.png"></p>
<p>会出现警告直接点是即可，下面配置VCSA 6.7虚拟机名称以及root密码。</p>
<p><img src="/images/2020/07/07/d80444a6-392b-4d2f-9494-22cbfc09f861.png" alt="image.png"></p>
<p>选择部署大小</p>
<p><img src="/images/2020/07/07/982b0164-426e-41ce-9c30-f3d53d4e5611.png" alt="image.png"></p>
<p>选择VCSA 6.7虚拟机存储<br><img src="/images/2020/07/07/23af1a0c-f0f9-4691-8588-f992f7ddfa27.png" alt="image.png"></p>
<p>之前的设置部署大小为300GB，可是由于自己电脑没有那么大的存储空间23333。只好这样先装了</p>
<p>配置VCSA 6.7虚拟机网络</p>
<p><img src="/images/2020/07/07/5b2ed2da-a716-40ff-af8d-a8d10d689648.png" alt="image.png"></p>
<p>确认第1阶段参数<br><img src="/images/2020/07/07/24db6c5c-6722-4993-a53c-81b785c5e1c0.png" alt="image.png"></p>
<p>开始第一阶段部署，部署的时间取决于物理服务器性能</p>
<p><img src="/images/2020/07/07/bece36f1-bc18-47dc-8405-53040e150d31.png" alt="image.png"></p>
<p>第一阶段完成，开始第二阶段</p>
<p><img src="/images/2020/07/07/b5a19232-1905-483a-a025-774640aabf5c.png" alt="image.png">)<img src="/images/2020/07/07/b1a61faa-02c6-4dcf-98e0-914eb7b7b8c2.png" alt="image.png"></p>
<p>配置系统时间</p>
<p><img src="/images/2020/07/07/887f5517-f9ab-438a-864e-dd3a25df5a60.png" alt="image.png"></p>
<p>这里选择跟ESXI主机同步。当然也可以选择和NTP服务器时间相同。根据自己需求选择是否启用SSH</p>
<p>SSO配置</p>
<p><img src="/images/2020/07/07/70404f34-797b-40e8-bcf5-0eb919ae80f9.png" alt="image.png"></p>
<p>确认是否加入CEIP</p>
<p><img src="/images/2020/07/07/8ef42ed4-fe92-46f9-b779-d664d390fddc.png" alt="image.png"></p>
<p>确认参数</p>
<p><img src="/images/2020/07/07/dc757e61-bf85-4c8d-86c3-8b747756bbca.png" alt="image.png"></p>
<p>点击确定开始第二阶段部署</p>
<p><img src="/images/2020/07/07/3d2e2f64-798e-49de-a438-10300e20e5e0.png" alt="image.png"></p>
<p>开始部署</p>
<p><img src="/images/2020/07/07/c8b3f7ee-4f93-4767-bbe7-9dc1a9769cd9.png" alt="image.png"></p>
<p>安装完成</p>
<p><img src="/images/2020/07/07/2b9c0c64-3393-4a03-8698-251a490b39df.png" alt="image.png"></p>
<p>打开VCSA 6.7控制台界面</p>
<p><img src="/images/2020/07/07/fc431e8c-134e-4c80-815e-11947dc87f21.png" alt="image.png"></p>
<p>在浏览器中输入VCSA 6.7的IP地址进行访问，VCSA 6.7提供H5以及FLASH两个选择，从初步使用看，H5功能比VCSA 6.5得到增强</p>
<p><img src="/images/2020/07/07/60dabf12-51c5-482b-bada-a28431efe7e8.png" alt="image.png"></p>
<p>输入SSO登录</p>
<p><img src="/images/2020/07/07/f1bf8161-91af-49c5-bcbc-38266e4e0da8.png" alt="image.png"></p>
<p>VCSA 6.7 登录成功后界面如下</p>
<p><img src="/images/2020/07/07/e6ee7699-a220-4c5c-b623-f908d886cb41.png" alt="image.png"></p>
<p>访问VMware vCenter Server Appliance Web</p>
<p><img src="/images/2020/07/07/b6aca240-9f68-458e-af9a-152944842c58.png" alt="image.png"><br><img src="/images/2020/07/07/bacd3236-4d20-49ee-9626-92d3659a8197.png" alt="image.png"></p>
<h3 id="安装vCenter-server"><a href="#安装vCenter-server" class="headerlink" title="安装vCenter server"></a>安装vCenter server</h3><p>当镜像挂载之后打开安装程序<br><img src="/images/2020/07/07/db865e34-e4f3-4f69-84fa-e8c2b4c58b9a.png" alt="image.png"></p>
<p>点击下一步继续安装<br><img src="/images/2020/07/07/e84fd03e-7965-4c54-b490-4a93597c3554.png" alt="image.png"></p>
<p>选择接受许可协议条款</p>
<p><img src="/images/2020/07/07/31fdd3d2-80cb-460a-92d4-3e41f898555a.png" alt="image.png"></p>
<p>选择部署类型，在这先暂时选择嵌入式部署。在以后会对外部部署进行安装。</p>
<p><img src="/images/2020/07/07/1883039b-fa49-4e1a-a0a5-de6570885525.png" alt="image.png"></p>
<p>配置系统网络名称，输入windows server的IP地址</p>
<p><img src="/images/2020/07/07/8a5cdc57-002d-4176-8c27-831431c6133c.png" alt="image.png"></p>
<p>vCenter Single Sign-On 配置</p>
<p><img src="/images/2020/07/07/686dd69f-b8a6-44c2-966e-b786055f1183.png" alt="image.png"></p>
<p>选择vCenter Server服务账户</p>
<p><img src="/images/2020/07/07/2ebc8f5a-de2e-4816-b0bf-a6cf3b344d21.png" alt="image.png"></p>
<p>数据库设置，选择嵌入式数据库</p>
<p><img src="/images/2020/07/07/36a4cd7e-234e-4925-8bd7-0cfd71769622.png" alt="image.png"></p>
<p>配置端口</p>
<p><img src="/images/2020/07/07/8e9f85b8-43ff-4a41-9a1b-b4e15402d5fa.png" alt="image.png"></p>
<p>选择安装目录</p>
<p><img src="/images/2020/07/07/508f6244-b468-418a-9c95-742d4abbbc22.png" alt="image.png"></p>
<p>加入客户体验提升计划</p>
<p><img src="/images/2020/07/07/19c6e02f-679e-4cab-baa9-f807bdb4da78.png" alt="image.png"></p>
<p>点击完成开始安装<br><img src="/images/2020/07/07/2084f5c3-1edf-4a35-8c5e-e52fe501833d.png" alt="image.png"></p>
<p>安装过程时间根据机器性能决定，大概10分钟左右</p>
<p><img src="/images/2020/07/07/1f1c81e6-2e97-476f-89c0-0b93723ceca4.png" alt="image.png"></p>
<p>安装完成</p>
<p><img src="/images/2020/07/07/87be7579-5906-4db4-b081-6576152bcfc1.png" alt="image.png"></p>
<p>在客户机访问vSphere Web Client</p>
<p><img src="/images/2020/07/07/f12110f1-5829-4eb9-9aab-720145a342f1.png" alt="image.png"></p>
<p>输入刚才设置的账号密码，然后登录成功</p>
<p><img src="/images/2020/07/07/7087312b-e0be-458a-8785-04dae733ff83.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title>网页基础</title>
    <url>/%E7%BD%91%E9%A1%B5%E5%9F%BA%E7%A1%80.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h2 id="1-网页的组成"><a href="#1-网页的组成" class="headerlink" title="1. 网页的组成"></a>1. 网页的组成</h2><p>网页可以分为三大部分——HTML、CSS和JavaScript。如果把网页比作一个人的话，HTML相当于骨架，JavaScript相当于肌肉，CSS相当于皮肤，三者结合起来才能形成一个完善的网页。下面我们分别来介绍一下这三部分的功能。<br>(1) HTML<br>HTML是用来描述网页的一种语言，其全称叫作Hyper Text Markup Language，即超文本标记语言。网页包括文字、按钮、图片和视频等各种复杂的元素，其基础架构就是HTML。不同类型的文字通过不同类型的标签来表示，如图片用img标签表示，视频用video标签表示，段落用p标签表示，它们之间的布局又常通过布局标签div嵌套组合而成，各种标签通过不同的排列和嵌套才形成了网页的框架。<br>在Chrome浏览器中打开百度，右击并选择“检查”项（或按F12键），打开开发者模式，这时在Elements选项卡中即可看到网页的源代码，如图2-9所示。<br> <img src="/images/2020/07/05/eb2e6bab-77a3-435d-9a73-001dc077439a.png" alt="image.png">图2-9 源代码<br>这就是HTML，整个网页就是由各种标签嵌套组合而成的。这些标签定义的节点元素相互嵌套和组合形成了复杂的层次关系，就形成了网页的架构。<br>(2) CSS<br>HTML定义了网页的结构，但是只有HTML页面的布局并不美观，可能只是简单的节点元素的排列，为了让网页看起来更好看一些，这里借助了CSS。<br>CSS，全称叫作Cascading Style Sheets，即层叠样式表。“层叠”是指当在HTML中引用了数个样式文件，并且样式发生冲突时，浏览器能依据层叠顺序处理。“样式”指网页中文字大小、颜色、元素间距、排列等格式。<br>CSS是目前唯一的网页页面排版样式标准，有了它的帮助，页面才会变得更为美观。<br>图2-9的右侧即为CSS，例如：</p>
<pre><code>#head_wrapper.s-ps-islite .s-p-top {
position: absolute;
bottom: 40px;
width: 100%;
height: 181px;}</code></pre><p>就是一个CSS样式。大括号前面是一个CSS选择器，此选择器的意思是首先选中id为head_wrapper且class为s-ps-islite的节点，然后再选中其内部的class为s-p-top的节点。大括号内部写的就是一条条样式规则，例如position指定了这个元素的布局方式为绝对布局，bottom指定元素的下边距为40像素，width指定了宽度为100%占满父元素，height则指定了元素的高度。也就是说，我们将位置、宽度、高度等样式配置统一写成这样的形式，然后用大括号括起来，接着在开头再加上CSS选择器，这就代表这个样式对CSS选择器选中的元素生效，元素就会根据此样式来展示了。<br>在网页中，一般会统一定义整个网页的样式规则，并写入CSS文件中（其后缀为css）。在HTML中，只需要用link标签即可引入写好的CSS文件，这样整个页面就会变得美观、优雅。<br>(3) JavaScript<br>JavaScript，简称JS，是一种脚本语言。HTML和CSS配合使用，提供给用户的只是一种静态信息，缺乏交互性。我们在网页里可能会看到一些交互和动画效果，如下载进度条、提示框、轮播图等，这通常就是JavaScript的功劳。它的出现使得用户与信息之间不只是一种浏览与显示的关系，而是实现了一种实时、动态、交互的页面功能。<br>JavaScript通常也是以单独的文件形式加载的，后缀为js，在HTML中通过script标签即可引入，例如：</p>
<pre><code>&lt;script src=&quot;jquery-2.1.0.js&quot;&gt;&lt;/script&gt;</code></pre><p>综上所述，HTML定义了网页的内容和结构，CSS描述了网页的布局，JavaScript定义了网页的行为。</p>
<h2 id="2-网页的结构"><a href="#2-网页的结构" class="headerlink" title="2. 网页的结构"></a>2. 网页的结构</h2><p>我们首先用例子来感受一下HTML的基本结构。新建一个文本文件，名称可以自取，后缀为html，内容如下：</p>
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>This is a Demo</title>
    <meta name="generator" content="Hexo 4.2.1"></head>
    <body>
        <div id="container">
            <div class="wrapper">
                <h2 class="title">Hello World</h2>
                <p class="text">Hello, this is a paragraph.</p>
            </div>
        </div>
    <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"react":{"opacity":0.7},"log":false});</script></body>
</html>

<p>这就是一个最简单的HTML实例。开头用DOCTYPE定义了文档类型，其次最外层是html标签，最后还有对应的结束标签来表示闭合，其内部是head标签和body标签，分别代表网页头和网页体，它们也需要结束标签。head标签内定义了一些页面的配置和引用，如：</p>
<pre><code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code></pre><p>它指定了网页的编码为UTF-8。<br>title标签则定义了网页的标题，会显示在网页的选项卡中，不会显示在正文中。body标签内则是在网页正文中显示的内容。div标签定义了网页中的区块，它的id是container，这是一个非常常用的属性，且id的内容在网页中是唯一的，我们可以通过它来获取这个区块。然后在此区块内又有一个div标签，它的class为wrapper，这也是一个非常常用的属性，经常与CSS配合使用来设定样式。然后此区块内部又有一个h2标签，这代表一个二级标题。另外，还有一个p标签，这代表一个段落。在这两者中直接写入相应的内容即可在网页中呈现出来，它们也有各自的class属性。<br>将代码保存后，在浏览器中打开该文件，可以看到如图2-10所示的内容。<br> <img src="/images/2020/07/05/0f0f252b-4e61-4a92-be73-b14db897e7a4.png" alt="image.png">   图2-10 运行结果<br>可以看到，在选项卡上显示了This is a Demo字样，这是我们在head中的title里定义的文字。而网页正文是body标签内部定义的各个元素生成的，可以看到这里显示了二级标题和段落。<br>这个实例便是网页的一般结构。一个网页的标准形式是html标签内嵌套head和body标签，head内定义网页的配置和引用，body内定义网页的正文。</p>
<h2 id="3-节点树及节点间的关系"><a href="#3-节点树及节点间的关系" class="headerlink" title="3. 节点树及节点间的关系"></a>3. 节点树及节点间的关系</h2><p>在HTML中，所有标签定义的内容都是节点，它们构成了一个HTML DOM树。<br>我们先看下什么是DOM，DOM是W3C（万维网联盟）的标准，其英文全称Document Object Model，即文档对象模型。它定义了访问HTML和XML文档的标准：<br>W3C文档对象模型（DOM）是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。<br>W3C DOM标准被分为3个不同的部分。<br>•    核心DOM： 针对任何结构化文档的标准模型。<br>•    XML DOM：针对XML文档的标准模型。<br>•    HTML DOM：针对HTML文档的标准模型。<br>根据W3C的HTML DOM标准，HTML文档中的所有内容都是节点。<br>•    整个文档是一个文档节点；<br>•    每个HTML元素是元素节点；<br>•    HTML元素内的文本是文本节点；<br>•    每个HTML属性是属性节点；<br>•    注释是注释节点。<br>HTML DOM将HTML文档视作树结构，这种结构被称为节点树，如图2-11所示。<br><img src="/images/2020/07/05/b93058d4-c3ce-475c-91c2-ff3c37e04702.png" alt="image.png"> 图2-11 节点树<br>通过HTML DOM，树中的所有节点均可通过JavaScript访问，所有HTML节点元素均可被修改，也可以被创建或删除。<br>节点树中的节点彼此拥有层级关系。我们常用父（parent）、子（child）和兄弟（sibling）等术语描述这些关系。父节点拥有子节点，同级的子节点被称为兄弟节点。<br>在节点树中，顶端节点称为根（root）。除了根节点之外，每个节点都有父节点，同时可拥有任意数量的子节点或兄弟节点。图2-12展示了节点树以及节点之间的关系。<img src="/images/2020/07/05/cd6a66aa-25f6-47aa-aa7d-498ef629f263.png" alt="image.png"><br> 图2-12 节点树及节点间的关系<br>本段参考W3SCHOOL，链接：<a href="http://www.w3school.com.cn/htmldom/dom_nodes.asp。" target="_blank" rel="noopener">http://www.w3school.com.cn/htmldom/dom_nodes.asp。</a></p>
<h2 id="4-选择器"><a href="#4-选择器" class="headerlink" title="4. 选择器"></a>4. 选择器</h2><p>我们知道网页由一个个节点组成，CSS选择器会根据不同的节点设置不同的样式规则，那么怎样来定位节点呢？<br>在CSS中，我们使用CSS选择器来定位节点。例如，上例中div节点的id为container，那么就可以表示为#container，其中#开头代表选择id，其后紧跟id的名称。另外，如果我们想选择class为wrapper的节点，便可以使用.wrapper，这里以点（.）开头代表选择class，其后紧跟class的名称。另外，还有一种选择方式，那就是根据标签名筛选，例如想选择二级标题，直接用h2即可。这是最常用的3种表示，分别是根据id、class、标签名筛选，请牢记它们的写法。<br>另外，CSS选择器还支持嵌套选择，各个选择器之间加上空格分隔开便可以代表嵌套关系，如#container .wrapper p则代表先选择id为container的节点，然后选中其内部的class为wrapper的节点，然后再进一步选中其内部的p节点。另外，如果不加空格，则代表并列关系，如div#container .wrapper p.text代表先选择id为container的div节点，然后选中其内部的class为wrapper的节点，再进一步选中其内部的class为text的p节点。这就是CSS选择器，其筛选功能还是非常强大的。<br>另外，CSS选择器还有一些其他语法规则，具体如表2-4所示。<br>表2-4 CSS选择器的其他语法规则<br><img src="/images/2020/07/05/8bf1bfc8-f09c-4e68-8bbf-2d1834b60323.png" alt="image.png"><br><img src="/images/2020/07/05/5545f3ee-025c-4211-a5f0-430207508533.png" alt="image.png"><br><img src="/images/2020/07/05/74d97db9-d198-4c8b-b0d8-1339287fe2ef.png" alt="image.png"><br><img src="/images/2020/07/05/20d2ccdb-41e5-48af-b32d-fc1529239b6c.png" alt="image.png"><br><img src="/images/2020/07/05/3bbc1032-ae0f-4b4c-bf4d-d402da270711.png" alt="image.png"><br>另外，还有一种比较常用的选择器是XPath，这种选择方式后面会详细介绍。</p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>网页</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫基本原理</title>
    <url>/%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>我们可以把互联网比作一张大网，而爬虫（即网络爬虫）便是在网上爬行的蜘蛛。把网的节点比作一个个网页，爬虫爬到这就相当于访问了该页面，获取了其信息。可以把节点间的连线比作网页与网页之间的链接关系，这样蜘蛛通过一个节点后，可以顺着节点连线继续爬行到达下一个节点，即通过一个网页继续获取后续的网页，这样整个网的节点便可以被蜘蛛全部爬行到，网站的数据就可以被抓取下来了。</p>
<h2 id="1-爬虫概述"><a href="#1-爬虫概述" class="headerlink" title="1. 爬虫概述"></a>1. 爬虫概述</h2><p>简单来说，爬虫就是获取网页并提取和保存信息的自动化程序，下面概要介绍一下。<br>(1) 获取网页<br>爬虫首先要做的工作就是获取网页，这里就是获取网页的源代码。源代码里包含了网页的部分有用信息，所以只要把源代码获取下来，就可以从中提取想要的信息了。<br>前面讲了请求和响应的概念，向网站的服务器发送一个请求，返回的响应体便是网页源代码。所以，最关键的部分就是构造一个请求并发送给服务器，然后接收到响应并将其解析出来，那么这个流程怎样实现呢？总不能手工去截取网页源码吧？<br>不用担心，Python提供了许多库来帮助我们实现这个操作，如urllib、requests等。我们可以用这些库来帮助我们实现HTTP请求操作，请求和响应都可以用类库提供的数据结构来表示，得到响应之后只需要解析数据结构中的Body部分即可，即得到网页的源代码，这样我们可以用程序来实现获取网页的过程了。<br>(2) 提取信息<br>获取网页源代码后，接下来就是分析网页源代码，从中提取我们想要的数据。首先，最通用的方法便是采用正则表达式提取，这是一个万能的方法，但是在构造正则表达式时比较复杂且容易出错。<br>另外，由于网页的结构有一定的规则，所以还有一些根据网页节点属性、CSS选择器或XPath来提取网页信息的库，如Beautiful Soup、pyquery、lxml等。使用这些库，我们可以高效快速地从中提取网页信息，如节点的属性、文本值等。<br>提取信息是爬虫非常重要的部分，它可以使杂乱的数据变得条理清晰，以便我们后续处理和分析数据。<br>(3) 保存数据<br>提取信息后，我们一般会将提取到的数据保存到某处以便后续使用。这里保存形式有多种多样，如可以简单保存为TXT文本或JSON文本，也可以保存到数据库，如MySQL和MongoDB等，也可保存至远程服务器，如借助SFTP进行操作等。<br>(4) 自动化程序<br>说到自动化程序，意思是说爬虫可以代替人来完成这些操作。首先，我们手工当然可以提取这些信息，但是当量特别大或者想快速获取大量数据的话，肯定还是要借助程序。爬虫就是代替我们来完成这份爬取工作的自动化程序，它可以在抓取过程中进行各种异常处理、错误重试等操作，确保爬取持续高效地运行。</p>
<h2 id="2-能抓怎样的数据"><a href="#2-能抓怎样的数据" class="headerlink" title="2. 能抓怎样的数据"></a>2. 能抓怎样的数据</h2><p>在网页中我们能看到各种各样的信息，最常见的便是常规网页，它们对应着HTML代码，而最常抓取的便是HTML源代码。<br>另外，可能有些网页返回的不是HTML代码，而是一个JSON字符串（其中API接口大多采用这样的形式），这种格式的数据方便传输和解析，它们同样可以抓取，而且数据提取更加方便。<br>此外，我们还可以看到各种二进制数据，如图片、视频和音频等。利用爬虫，我们可以将这些二进制数据抓取下来，然后保存成对应的文件名。<br>另外，还可以看到各种扩展名的文件，如CSS、JavaScript和配置文件等，这些其实也是最普通的文件，只要在浏览器里面可以访问到，就可以将其抓取下来。<br>上述内容其实都对应各自的URL，是基于HTTP或HTTPS协议的，只要是这种数据，爬虫都可以抓取。</p>
<h2 id="3-JavaScript渲染页面"><a href="#3-JavaScript渲染页面" class="headerlink" title="3. JavaScript渲染页面"></a>3. JavaScript渲染页面</h2><p>有时候，我们在用urllib或requests抓取网页时，得到的源代码实际和浏览器中看到的不一样。<br>这是一个非常常见的问题。现在网页越来越多地采用Ajax、前端模块化工具来构建，整个网页可能都是由JavaScript渲染出来的，也就是说原始的HTML代码就是一个空壳，例如：<br> <figure class="highlight plain"><figcaption><span>html></span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">   &lt;head&gt;</span><br><span class="line">         &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">         &lt;title&gt;This is a Demo&lt;&#x2F;title&gt;</span><br><span class="line">     &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">         &lt;div id&#x3D;&quot;container&quot;&gt;</span><br><span class="line">       &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;app.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure></p>
<p>body节点里面只有一个id为container的节点，但是需要注意在body节点后引入了app.js，它便负责整个网站的渲染。<br>在浏览器中打开这个页面时，首先会加载这个HTML内容，接着浏览器会发现其中引入了一个app.js文件，然后便会接着去请求这个文件，获取到该文件后，便会执行其中的JavaScript代码，而JavaScript则会改变HTML中的节点，向其添加内容，最后得到完整的页面。<br>但是在用urllib或requests等库请求当前页面时，我们得到的只是这个HTML代码，它不会帮助我们去继续加载这个JavaScript文件，这样也就看不到浏览器中的内容了。<br>这也解释了为什么有时我们得到的源代码和浏览器中看到的不一样。<br>因此，使用基本HTTP请求库得到的源代码可能跟浏览器中的页面源代码不太一样。对于这样的情况，我们可以分析其后台Ajax接口，也可使用Selenium、Splash这样的库来实现模拟JavaScript渲染。<br>后面，我们会详细介绍如何采集JavaScript渲染的网页。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>详解python命名空间和作用域</title>
    <url>/%E8%AF%A6%E8%A7%A3python%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="1、典型案例"><a href="#1、典型案例" class="headerlink" title="1、典型案例"></a>1、典型案例</h1><p>先从几个典型的案例来看下名称空间及作用域对python代码运行的影响，请看下面几个代码实例及其执行结果，是否符合你的预期。<br>代码1：块作用域<br>if True:<br>    i = 1<br>print i<br>执行结果： 1<br>代码2：函数作用域<br>def f():<br>    i = 1<br>f()<br>print i<br>执行结果：执行报错“NameError: name ‘cc’ is not defined”</p>
<p>代码3：静态作用域<br>i = 1<br>def test():<br>    i += 1<br>test()<br>执行结果：执行报错“UnboundLocalError: local variable ‘i’ referenced before assignment”</p>
<p>代码4：静态作用域<br>i = 1<br>def g():<br>print i<br>print i<br>def f():<br>    i = 2<br>    g()<br>f()　<br>执行结果： 1<br> 将i = 2放在g()后面会不会起作用？<br>代码5：闭包、全局作用域<br>i = 1<br>def f():<br>    i = 2<br>def g():<br>        print i<br>    return g<br>func = f()<br>func()<br>print i<br>执行结果：2    1<br>PS:python2.1之前执行该代码会报错，闭包(嵌套作用域)是在之后引入的概念，内部函数g()只能访问本函数中的命名空间、全局命名空间、内建命名空间，无法访问外部调用函数的命名空间。</p>
<h1 id="2、命名空间"><a href="#2、命名空间" class="headerlink" title="2、命名空间"></a>2、命名空间</h1><p>【定义】<br>    名称到对象的映射。命名空间是一个字典的实现，键为变量名，值是变量对应的值。各个命名空间是独立没有关系的，一个命名空间中不能有重名，但是不同的命名空间可以重名而没有任何影响。</p>
<p>【分类】<br>    python程序执行期间会有2个或3个活动的命名空间（函数调用时有3个，函数调用结束后2个）。按照变量定义的位置，可以划分为以下3类：<br>    Local，局部命名空间，每个函数所拥有的命名空间，记录了函数中定义的所有变量，包括函数的入参、内部定义的局部变量。<br>    Global，全局命名空间，每个模块加载执行时创建的，记录了模块中定义的变量，包括模块中定义的函数、类、其他导入的模块、模块级的变量与常量。<br>    Built-in，python自带的内建命名空间，任何模块均可以访问，放着内置的函数和异常。</p>
<p>【生命周期】<br>    Local（局部命名空间）在函数被调用时才被创建，但函数返回结果或抛出异常时被删除。（每一个递归函数都拥有自己的命名空间）。<br>    Global（全局命名空间）在模块被加载时创建，通常一直保留直到python解释器退出。<br>    Built-in（内建命名空间）在python解释器启动时创建，一直保留直到解释器退出。</p>
<pre><code>各命名空间创建顺序：python解释器启动 -&gt;创建内建命名空间 -&gt; 加载模块 -&gt; 创建全局命名空间 -&gt;函数被调用 -&gt;创建局部命名空间
各命名空间销毁顺序：函数调用结束 -&gt; 销毁函数对应的局部命名空间 -&gt; python虚拟机（解释器）退出 -&gt;销毁全局命名空间 -&gt;销毁内建命名空间
python解释器加载阶段会创建出内建命名空间、模块的全局命名空间，局部命名空间是在运行阶段函数被调用时动态创建出来的，函数调用结束动态的销毁的。</code></pre><h1 id="3、作用域"><a href="#3、作用域" class="headerlink" title="3、作用域"></a>3、作用域</h1><p>【定义】<br>    作用域是针对变量而言，指申明的变量在程序里的可应用范围。或者称为变量的可见性。</p>
<p>【分类】<br>    只有函数、类、模块会产生作用域，代码块不会产生作用域（参考代码1）。作用域按照变量的定义位置可以划分为4类：<br>    Local(函数内部)局部作用域<br>    Enclosing（嵌套函数的外层函数内部）嵌套作用域（闭包）<br>    Global（模块全局）全局作用域<br>    Built-in（内建）内建作用域</p>
<p>【规则】<br>    1、静态作用域规则<br>         定义：python中变量的作用域是由它在源代码中的位置决定的。（名字查找是动态发生的）<br>         说明：参考代码3/4，以代码3为例说明，在模块中定义了一个全局变量 i = 1，在test方法中执行 i += 1，对变量 i进行了赋值动作，该赋值动作决定了i在test()方法中是一个局部变量， i += 1可以拆分为两步执行，首先执行 i + 1, 然后将结果赋值给i。执行i + 1操作时，i虽然申明为局部变量，但是没有绑定任何具体值，因此报错。<br>    2、最内嵌套作用域规则<br>         定义：由一个赋值语句引进的名字在这个赋值语句所在的作用域里是可见（起作用）的，而且在其内部嵌套的每个作用域内也可见，除非它被嵌套于内部的且引进同样名字的赋值语句所遮蔽。<br>         说明：参考代码5. 方法g()是方法f()中定义的内嵌函数。在方法f()中定义的局部变量 i =2，在内嵌方法 g()中是可见的。如果在g()中又定义一个重名的变量 i = 3，则f()中定义的变量将被遮蔽。</p>
<h1 id="4、命名空间与作用域的关系"><a href="#4、命名空间与作用域的关系" class="headerlink" title="4、命名空间与作用域的关系"></a>4、命名空间与作用域的关系</h1><pre><code>命名空间定义了在某个作用域内变量名和绑定值之间的对应关系，命名空间是键值对的集合，变量名与值是一一对应关系。作用域定义了命名空间中的变量能够在多大范围内起作用。
命名空间在python解释器中是以字典的形式存在的，是以一种可以看得见摸得着的实体存在的。作用域是python解释器定义的一种规则，该规则确定了运行时变量查找的顺序，是一种形而上的虚的规定。</code></pre><p>【变量查找法则】<br>    python解释器动态执行过程中，对遇到的变量进行解释时，是按照一条固定的作用域链查找解释的，又称为LEGB法则。<br>    其中L代表Local 局部作用域，E代表Enclosing 嵌套作用域，G代表Global 全局作用域，B代表Built-in 内建作用域。<br>    python解释器查找变量时，会按照顺序依次查找局部作用域，嵌套作用域，全局作用域，内建作用域，在任意一个作用域中找到变量则停止查找，所有作用域查找完成没有找到对应的变量，则抛出 NameError: name ‘xxxx’ is not defined的异常。<br>    在局部作用域中，可以看到局部作用域、嵌套作用域、全局作用域、内建作用域中所有定义的变量。<br>    在全局作用域中，可以看到全局作用域、内建作用域中的所有定义的变量，无法看到局部作用域中的变量。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>git命令大全</title>
    <url>/git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>git init                                                  # 初始化本地git仓库（创建新仓库）<br>git config –global user.name “xxx”                       # 配置用户名<br>git config –global user.email “<a href="mailto:xxx@xxx.com">xxx@xxx.com</a>“              # 配置邮件<br>git config –global color.ui true                         # git status等命令自动着色<br>git config –global color.status auto<br>git config –global color.diff auto<br>git config –global color.branch auto<br>git config –global color.interactive auto<br>git config –global –unset http.proxy                    # remove  proxy configuration on git<br>git clone git+ssh://git@192.168.53.168/VT.git             # clone远程仓库<br>git status                                                # 查看当前版本状态（是否修改）<br>git add xyz                                               # 添加xyz文件至index<br>git add .                                                 # 增加当前子目录下所有更改过的文件至index<br>git commit -m ‘xxx’                                       # 提交<br>git commit –amend -m ‘xxx’                               # 合并上一次提交（用于反复修改）<br>git commit -am ‘xxx’                                      # 将add和commit合为一步<br>git rm xxx                                                # 删除index中的文件<br>git rm -r *                                               # 递归删除<br>git log                                                   # 显示提交日志<br>git log -1                                                # 显示1行日志 -n为n行<br>git log -5<br>git log –stat                                            # 显示提交日志及相关变动文件<br>git log -p -m<br>git show dfb02e6e4f2f7b573337763e5c0013802e392818         # 显示某个提交的详细内容<br>git show dfb02                                            # 可只用commitid的前几位<br>git show HEAD                                             # 显示HEAD提交日志<br>git show HEAD^                                            # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本<br>git tag                                                   # 显示已存在的tag<br>git tag -a v2.0 -m ‘xxx’                                  # 增加v2.0的tag<br>git show v2.0                                             # 显示v2.0的日志及详细内容<br>git log v2.0                                              # 显示v2.0的日志<br>git diff                                                  # 显示所有未添加至index的变更<br>git diff –cached                                         # 显示所有已添加index但还未commit的变更<br>git diff HEAD^                                            # 比较与上一个版本的差异<br>git diff HEAD – ./lib                                    # 比较与HEAD版本lib目录的差异<br>git diff origin/master..master                            # 比较远程分支master上有本地分支master上没有的<br>git diff origin/master..master –stat                     # 只显示差异的文件，不显示具体内容<br>git remote add origin git+ssh://git@192.168.53.168/VT.git # 增加远程定义（用于push/pull/fetch）<br>git branch                                                # 显示本地分支<br>git branch –contains 50089                               # 显示包含提交50089的分支<br>git branch -a                                             # 显示所有分支<br>git branch -r                                             # 显示所有原创分支<br>git branch –merged                                       # 显示所有已合并到当前分支的分支<br>git branch –no-merged                                    # 显示所有未合并到当前分支的分支<br>git branch -m master master_copy                          # 本地分支改名<br>git checkout -b master_copy                               # 从当前分支创建新分支master_copy并检出<br>git checkout -b master master_copy                        # 上面的完整版<br>git checkout features/performance                         # 检出已存在的features/performance分支<br>git checkout –track hotfixes/BJVEP933                    # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支<br>git checkout v2.0                                         # 检出版本v2.0<br>git checkout -b devel origin/develop                      # 从远程分支develop创建新本地分支devel并检出<br>git checkout – README                                    # 检出head版本的README文件（可用于修改错误回退）<br>git merge origin/master                                   # 合并远程master分支至当前分支<br>git cherry-pick ff44785404a8e                             # 合并提交ff44785404a8e的修改<br>git push origin master                                    # 将当前分支push到远程master分支<br>git push origin :hotfixes/BJVEP933                        # 删除远程仓库的hotfixes/BJVEP933分支<br>git push –tags                                           # 把所有tag推送到远程仓库<br>git fetch                                                 # 获取所有远程分支（不更新本地分支，另需merge）<br>git fetch –prune                                         # 获取所有原创分支并清除服务器上已删掉的分支<br>git pull origin master                                    # 获取远程分支master并merge到当前分支<br>git mv README README2                                     # 重命名文件README为README2<br>git reset –hard HEAD                                     # 将当前版本重置为HEAD（通常用于merge失败回退）<br>git rebase<br>git branch -d hotfixes/BJVEP933                           # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）<br>git branch -D hotfixes/BJVEP933                           # 强制删除分支hotfixes/BJVEP933<br>git ls-files                                              # 列出git index包含的文件<br>git show-branch                                           # 图示当前分支历史<br>git show-branch –all                                     # 图示所有分支历史<br>git whatchanged                                           # 显示提交历史对应的文件修改<br>git revert dfb02e6e4f2f7b573337763e5c0013802e392818       # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818<br>git ls-tree HEAD                                          # 内部命令：显示某个git对象<br>git rev-parse v2.0                                        # 内部命令：显示某个ref对于的SHA1 HASH<br>git reflog                                                # 显示所有提交，包括孤立节点<br>git show HEAD@{5}<br>git show master@{yesterday}                               # 显示master分支昨天的状态<br>git log –pretty=format:’%h %s’ –graph                   # 图示提交日志<br>git show HEAD~3<br>git show -s –pretty=raw 2be7fcb476<br>git stash                                                 # 暂存当前修改，将所有至为HEAD状态<br>git stash list                                            # 查看所有暂存<br>git stash show -p stash@{0}                               # 参考第一次暂存<br>git stash apply stash@{0}                                 # 应用第一次暂存<br>git grep “delete from”                                    # 文件中搜索文本“delete from”<br>git grep -e ‘#define’ –and -e SORT_DIRENT<br>git gc<br>git fsck</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机安装openfiler</title>
    <url>/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85openfiler.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Openfiler是一个基于rPath Linux系统的免费ISCIS/NAS应用。它是一个基于浏览器的免费网络存储管理实用程序，可以在单一框架中提供基于文件的网络连接存储 (NAS) 和基于块的存储区域网 (SAN)。Openfiler 支持 CIFS、NFS、HTTP/DAV 和 FTP。Openfiler能把标准x86/64架构的系统变成一个强大的NAS、SAN存储和IP存储网关，为管理员提供一个强大的管理平台，并能能应付未来的存储需求。依赖如VMware，Virtual Iron和Xen服务器虚拟化技术，Openfiler也可部署为一个虚拟机实例。<br>Openfiler的主要性能和优点：<br>1.可靠性—Openfiler可以支持软件和硬件的RAID，能监测和预警，并且可以做卷的快照和快速恢复。<br>2. 高可用性–Openfiler支持主动或被动的高可用性集群、多路径存储（MPIO）、块级别的复制。<br>3.性能–及时更新的Linux内核支持最新的CPU、网络和存储硬件。<br>4.可伸缩性—文件系统可扩展性最高可超出60TB，并能使文件系统大小可以在线的增长。</p>
<h1 id="openfiler安装"><a href="#openfiler安装" class="headerlink" title="openfiler安装"></a>openfiler安装</h1><h3 id="下载openfiler镜像"><a href="#下载openfiler镜像" class="headerlink" title="下载openfiler镜像"></a>下载openfiler镜像</h3><p><a href="https://www.openfiler.com/community/download" target="_blank" rel="noopener">链接🔗</a></p>
<h3 id="创建虚拟机"><a href="#创建虚拟机" class="headerlink" title="创建虚拟机"></a>创建虚拟机</h3><p>新建虚拟机，选择自定义<br><img src="/images/2020/07/26/a62b9fba-1e6d-45a0-8671-0e67b4c95302.png" alt="image.png"><br>选择虚拟机兼容性<br><img src="/images/2020/07/26/b797defc-3b51-42db-afec-24f5aa0ed0ce.png" alt="image.png"><br>选择稍后安装操作系统<br><img src="/images/2020/07/26/415c3b94-bfce-4d22-ade7-fd5ea4bfc5e0.png" alt="image.png"><br>选择系统为Linux并且选择为Red Hat Enterprise Linux 5<br><img src="/images/2020/07/26/4c2e82dd-0611-4ea4-860b-757d659b1190.png" alt="image.png"><br>命名虚拟机并且选择安装位置<br><img src="/images/2020/07/26/5ad5a368-53b4-4b5b-b4b7-4b50c3d844dd.png" alt="image.png"><br>处理器配置<br><img src="/images/2020/07/26/f8e854f8-86c6-4599-a917-75d952329ebe.png" alt="image.png"><br>虚拟机内存设置<br><img src="/images/2020/07/26/9840952f-5648-4e62-9120-40bea1417d3f.png" alt="image.png"><br>设置网络类型，选择桥接<br><img src="/images/2020/07/26/f2adc548-24b1-42d9-8927-376f2546e97f.png" alt="image.png"><br>选择I/O控制器类型<br><img src="/images/2020/07/26/094c5a2c-d9fb-404d-8ff3-af63c4ff9144.png" alt="image.png"><br>选择磁盘类型<br><img src="/images/2020/07/26/642a542b-0a15-4b30-8b06-fad1d5bde637.png" alt="image.png"><br>选择磁盘<br><img src="/images/2020/07/26/3de87fb9-9b81-46d8-b4fd-ac67e66d216e.png" alt="image.png"><br>指定磁盘容量<br><img src="/images/2020/07/26/c6a484d9-bb58-458b-b9b7-a15d2b1a3712.png" alt="image.png"><br>指定磁盘文件<br><img src="/images/2020/07/26/cef87bbd-9d2c-47a4-bf28-781bc87fc884.png" alt="image.png"><br>选择挂载安装镜像<br><img src="/images/2020/07/26/18d40631-dd49-4623-8451-bb872ff55318.png" alt="image.png"><br>开启虚拟机，进入此界面按回车<br><img src="/images/2020/07/26/55b6cbdc-e504-4403-8a9e-1dc520edfdc8.png" alt="image.png"><br>点击下一步<br><img src="/images/2020/07/26/10e86c71-14df-4a3e-8bae-761f9bdc74d2.png" alt="image.png"><br>选择适当的键盘<br><img src="/images/2020/07/26/5d3fd7b9-412b-45b7-940f-9fd2c644c1a0.png" alt="image.png"><br>初始化磁盘，选择”Yes”<br><img src="/images/2020/07/26/237a10bb-7207-4967-a114-5e0b063ba327.png" alt="image.png"><br>创建分区，选择”Yes”<br><img src="/images/2020/07/26/8c00f7ed-fb02-4846-b64e-fc16067b517a.png" alt="image.png"><br>选择使用静态的IP地址<img src="/images/2020/07/26/c459e249-a7b9-4ccc-9ac2-ff6b259ace07.png" alt="image.png"><br>配置网关与DNS服务器地址，这一步使用内网地址的话感觉DNS服务器配置与否都行。所以此处有点多余2333🤣<img src="/images/2020/07/26/03d29a10-b29e-4c0c-a8c1-d6bf12e987b1.png" alt="image.png"><br>选择时区，选择上海<img src="/images/2020/07/26/5e3bbc04-8a6f-4acc-a78c-f3650b2c6049.png" alt="image.png"><br>设置root密码<img src="/images/2020/07/26/afaf7d1a-4123-481b-ac1b-d70e0963b1d3.png" alt="image.png"><br>点击“Next”进行安装<img src="/images/2020/07/26/55bb2d31-4bb6-4263-91ce-cdee2f7025ae.png" alt="image.png"><br><img src="/images/2020/07/26/cb1b0604-c779-4b92-9480-2ee312a80381.png" alt="image.png"><br>安装完成，选择“Reboot”重启系统<br><img src="/images/2020/07/26/6937af98-bdc9-4a0b-afb3-b0d17f850c2a.png" alt="image.png"></p>
<h1 id="配置openfiler-的iscsi目标服务器"><a href="#配置openfiler-的iscsi目标服务器" class="headerlink" title="配置openfiler 的iscsi目标服务器"></a>配置openfiler 的iscsi目标服务器</h1><h3 id="1-重启进入操作系统"><a href="#1-重启进入操作系统" class="headerlink" title="1.重启进入操作系统"></a>1.重启进入操作系统</h3><p><img src="/images/2020/07/26/bebf2e4c-2748-4772-8287-41af3a38150e.png" alt="image.png"></p>
<h3 id="2-添加3块scsi硬盘"><a href="#2-添加3块scsi硬盘" class="headerlink" title="2.添加3块scsi硬盘"></a>2.添加3块scsi硬盘</h3><p><img src="/images/2020/07/26/40c3ce31-49f3-4b55-adb7-766f62fc9795.png" alt="image.png"><br>然后输入init 6重启操作系统，重新扫描scsi硬盘。<br><img src="/images/2020/07/26/c68166db-8831-4ef5-8446-e3f265a76d4d.png" alt="image.png"></p>
<h3 id="3-登录web界面"><a href="#3-登录web界面" class="headerlink" title="3.登录web界面"></a>3.登录web界面</h3><p>登录地址就是启动时页面上显示的IP地址;用户名是：openfiler ， 密码是：password</p>
<p><img src="/images/2020/07/26/66c20d26-c33b-451e-bdcc-21b48c828aa0.png" alt="image.png"></p>
<h3 id="4-磁盘配置RAID5"><a href="#4-磁盘配置RAID5" class="headerlink" title="4.磁盘配置RAID5"></a>4.磁盘配置RAID5</h3><p>登录成功后界面如下所示</p>
<p><img src="/images/2020/07/26/1adbd07d-6252-41eb-979b-af762f37357c.png" alt="image.png"></p>
<p>选择”Volumes”选项<br><img src="/images/2020/07/26/12ae85bc-1445-40de-8cfb-9090dbb3c043.png" alt="image.png"></p>
<p>选择右测得菜单栏“Block Devices”<br><img src="/images/2020/07/26/cab73e38-b09a-4535-b188-2cdda3dbc5e2.png" alt="image.png"></p>
<p>点击刚添加的三块硬盘</p>
<p><img src="/images/2020/07/26/71055f79-a98a-469b-a6bc-35ee26a1f6a8.png" alt="image.png"></p>
<p>创建raid分区类型</p>
<p><img src="/images/2020/07/26/cd25519f-0a0c-4ff4-b11b-3cdde6cddcf0.png" alt="image.png"></p>
<p>选择右侧的“Software RAID”<br><img src="/images/2020/07/26/b2ba056a-f670-43e9-80ad-fe9fbdfda22a.png" alt="image.png"></p>
<p>选择创建RAID5分区，点击“Add array”<br><img src="/images/2020/07/26/2fa2225b-bab8-4a7c-bd7e-964a5af2198f.png" alt="image.png"></p>
<h3 id="5-创建逻辑卷"><a href="#5-创建逻辑卷" class="headerlink" title="5.创建逻辑卷"></a>5.创建逻辑卷</h3><p>使用刚才创建好的raid5分区创建逻辑卷，点击“Volume Groups”</p>
<p><img src="/images/2020/07/26/c65b447a-fae2-4b44-882a-f70dce3c252b.png" alt="image.png"></p>
<p>点击“create new physical volumes”，给卷组起一个名字叫“First”，选择物理卷“/dev/md0”</p>
<p><img src="/images/2020/07/26/f2f2650a-e477-4bd4-8c12-20383c1282c5.png" alt="image.png"></p>
<p>点击右侧的“Add volume”<br><img src="/images/2020/07/26/7d86236b-602b-4761-a460-ea91d5865a74.png" alt="image.png"></p>
<p>创建卷，卷的名字叫“One”，卷描述“hello world”当然可以填其他的，容量调整为最大，FileSystem / Volume type： 选择 block(iSCSI,FC,etc)<br><img src="/images/2020/07/26/b1eeef6a-9faf-4e0a-9e27-c3063443310f.png" alt="image.png"></p>
<h3 id="6-启动iscsi目标服务器"><a href="#6-启动iscsi目标服务器" class="headerlink" title="6.启动iscsi目标服务器"></a>6.启动iscsi目标服务器</h3><p><img src="/images/2020/07/26/94683742-b973-4263-88bb-c2add97827ad.png" alt="image.png"></p>
<h3 id="7-配置访问控制列表，iscsi目标服务器"><a href="#7-配置访问控制列表，iscsi目标服务器" class="headerlink" title="7.配置访问控制列表，iscsi目标服务器"></a>7.配置访问控制列表，iscsi目标服务器</h3><p>选择“System”</p>
<p><img src="/images/2020/07/26/328c6199-ba14-4620-a97a-b7ceccdb2609.png" alt="image.png"></p>
<p>选择允许访问的ip地址或一个网段，然后点击“update”<br><img src="/images/2020/07/26/0f569178-a59f-444f-bd4b-50b05ce7fb31.png" alt="image.png"></p>
<p>选择Volumes<br><img src="/images/2020/07/26/7154ab2e-d624-43b1-baef-a3b2d4aee943.png" alt="image.png"></p>
<p>选择右边的“iSCSI Targets”</p>
<p><img src="/images/2020/07/26/391c8d3b-c29f-47b7-9d27-78f892e3e90a.png" alt="image.png"></p>
<p>添加一个target IQN<br><img src="/images/2020/07/26/b6519eef-ab67-4777-a277-e4b2ce58d5f5.png" alt="image.png"></p>
<p>选择“LUN Mapping”，然后进行映射</p>
<p><img src="/images/2020/07/26/94c26dde-efae-48ca-98e9-4a142d30e0ee.png" alt="image.png"></p>
<p>选择“Network ACL”，“ACCESS”下面改成“Allow”，然后点击“update”</p>
<p><img src="/images/2020/07/26/d3607d29-a38f-4d18-9bea-752c674da007.png" alt="image.png"></p>
<p>连接iscsi测试<br>打开iscsi发起程序，连接iscsi目标服务器<br><img src="/images/2020/07/26/039c2696-eb04-4828-b835-fb2b3b54832d.png" alt="image.png"><br><img src="/images/2020/07/26/8a56f05d-2968-4fd2-add9-56345cabbaa8.png" alt="image.png"></p>
<p>查看Windows磁盘管理，发现已经正常连接<br><img src="/images/2020/07/26/818b688a-0259-4af6-af5f-71dfc751740b.png" alt="image.png"></p>
<p>新建一个分区</p>
<p><img src="/images/2020/07/26/7f3c9172-1196-40af-8c2d-bebf17336811.png" alt="image.png"></p>
<p>复制文件速度测试<br><img src="/images/2020/07/26/26b461b7-bf26-4ecf-a8fc-715e5a84a383.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建一个属于自己的音乐网站</title>
    <url>/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9F%B3%E4%B9%90%E7%BD%91%E7%AB%99.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>搭建一个云音乐网站，有这些东西是必需的：<br>1：网站源码<br>2：服务器<br>3：域名<br>云音乐源码在这：<a href="https://www.lanzous.com/i5i1fwb" target="_blank" rel="noopener">https://www.lanzous.com/i5i1fwb</a><br>然后服务器我这里选择一个虚拟主机，有一些这种免费的空间可以使用，这里我选择的是美国的，因为我域名是在自己买的，没备案，所以选择了国外的一款虚拟机：<a href="http://idc.xfbk.top/" target="_blank" rel="noopener">http://idc.xfbk.top/</a><br>自行注册，然后选择免费的那个购买<br><img src="/images/2020/07/28/ae51774c-4f6e-4963-9b1a-b6e12f13034f.png" alt="image.png"><br>点击FTP/文件管理<br><img src="/images/2020/07/28/8c87728c-6f62-4bad-83b4-596f9719a27d.png" alt="image.png"><br>打开在线文件管理器，上传源码<br><img src="/images/2020/07/28/beffed99-6b1e-4831-9091-d145538da78b.png" alt="image.png"><br>解压文件到wwwroot目录下<br><img src="/images/2020/07/28/512bd85f-4234-4b0c-80fc-17eeaa981ffd.png" alt="image.png"><br>现在就是进行域名的绑定，没有域名的可以去阿里云腾讯云等等购买，购买需要一些认证啊什么的，会有点麻烦，购买的域名需要解析，主页搜索域名控制台，然后点解析，再点添加记录，如下图<br><img src="/images/2020/07/28/f490f8fb-5c01-4ad5-aed5-79759f3b45c7.png" alt="image.png"><br>或者使用这个去注册获取个二级域名<a href="http://dns.txizd.cn/，有域名的点击右侧基本功能—域名绑定" target="_blank" rel="noopener">http://dns.txizd.cn/，有域名的点击右侧基本功能—域名绑定</a><br><img src="/images/2020/07/28/cccfadb4-c107-450d-826b-3c375cdf8d6e.png" alt="image.png"><br>到了这一步，那很好，你已经完成了基本操作，现在可以输入你绑定的域名查看<br>自己完成的，可以点击查看：<a href="http://zcmusic.bylds.cn" target="_blank" rel="noopener">http://zcmusic.bylds.cn/</a><br><img src="/images/2020/07/28/21d03fdc-a835-4a25-8f98-d3e114c67e36.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>网站</category>
      </categories>
      <tags>
        <tag>网页</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 基础知识入门及常见命令</title>
    <url>/Linux-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%85%A5%E9%97%A8%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>1,V8:192.168.40.10<br>V1:192.168.40.11<br>Linux ip:192.168.40.128<br>2,Linux 是一个操作系统, 与 windows 的区别:<br>Linux:图形化界面简单,性能很快,在企业中当做服务器来使用.<br>Windows:图形化界面很炫,性能相对差,大众用户.<br>windows 的服务器: windows2003,windows2008,windows2012<br>3,Linux 的作用:<br>当做服务器来使用<br>4,Linux 中目录结构: bin:存放二进制可执行文件 sbin: 存放二进制可执行文件,只有 root 才能访问 etc:存放系统配置文件 usr:用于存放共享的系统资源 home:存放用户文件的根目录 root:超级的用户目录 dev:用于存放设备文件 lib:存放跟文件系统中的程序运行所需要的共享库及内核模块 mnt:mount 系统管理员安装临时文件的安装点 boot:存放用于系统引导时使用的各种文件 tmp:用于存放各种临时文件 var:用于存放运行时需要改变数据的文件(log 日志) 5,NetWork connection:<br>Host-only:本地跟远方的 Linux 通信需要用这个<br>NAT:多个 Linux 系统之间相互通信<br>6,使用 SecureCRT<br>Linux 命令:<br>ifconfig: 查看 ip service network restart:重启<br>命令分类:<br>内部命令:执行 shell 解析器的一部分,存放在 bash 目录,执行速度快,不需要创建子进程<br>cd:切换目录 change directory pwd:显示当前工作目录 print working directory help:帮助 </p>
<p>外部命令:独立于 Shell 解析器之外的文件程序,执行速度慢,一般存放在 bin/sbin/usr/sbin/此类目录,执行时创建子线程. ls:显示文件和目录列表 mkdir:创建目录 cp:复制文件或目录 </p>
<p>操作文件或目录的命令:<br>pwd touch:创建空文件<br>echo:写文件内容: echo “aaa”&gt;a.txt mkdir:创建目录<br>-p 父目录不存在的情况下先生成父目录<br>cp:复制文件或目录<br>-r:递归处理,将指定目录下的文件与子目录一并拷贝 mv:移动文件或目录,文件或目录改名 rm:删除文件<br>-r 同时删除该目录下的所有文件 -f 强制删除文件或目录<br>rmdir:删除空目录 cat:显示文本文件内容 more,less:分页显示文本文件内容 head,tail:查看文本中开头或结尾部分的内容. </p>
<p>查看帮助文档:<br>内部命令 :help+命令(help cd) 外部命令: man+命令(man ls) </p>
<p>7,常见命令<br>===========常用命令============= 一,目录与文件命令<br>1,目录处理命令:mkdir,rm,ls,find,cd,mv,cp,pwd,chmod<br>2,操作文件命令:touch,rm,find,cat,more,less<br>3,压缩/解压命令:gzip,bzip2,tar<br>4,其他常用命令:head,tail,wc,in,mount </p>
<p>二,用户操作命令<br>useradd,userdel,usermod<br>三,用户组操作命令<br>groupadd,groupdel,groupmod<br>四,安装软件命令<br>yum,rpm<br>五,网络命令<br>ping,ifconfig,netstat </p>
<p>===========================<br>echo “welcome to linux” &gt; a.txt: 往 a.txt 中写入字符 cat a.txt: 查看 a.txt 中的内容 ctrl+L: 清屏 ctrl + z: 退出(cat &gt; file 写入文件时使用这个键退出写入) vi 模式下: 编辑完成后点 esc ,然后 如果要保存退出输入:wq,不保存退出输入:q!<br>点击 esc, shift + z + z 退出并保存<br>============详解============<br>mkdir:创建目录 (touch a.txt :创建文件) mkdir dir : 创建名称叫做 dir 目录, 创建单个目录<br>mkdir dir1 dir2 : 创建多个目录,dir1, dir2 mkdir dir{3..10}: 创建 dir3 dir4…dir10 </p>
<p>cp:copy 复制<br>复制文件:<br>cp a.txt b.txt: 复制 a.txt 且复制后的文件名为 b.txt cp a.txt dir: 将 a.txt 拷贝到 dir 文件夹下<br>cp <em>.txt dir<br>cp ../</em>.txt ../dir2:将上一级目录下的所有 txt 文件拷贝到上一级目录的 dir2 文件夹下 cp ../file* . //拷贝到上一级目录下的所有 file 文件到当前目录 </p>
<p>复制目录:<br>cp -r dir1 dir2: 将 dir1 目录复制到 dir2 目录中 cp -r dir/* dir1/ : 将 dir 中的所有文件和目录复制到 dir1 目录中 </p>
<p>mv:目录移动(剪切) 移动文件:<br>mv file1 file2 //如果 file2 不存在,将 file1 重命名为 file2 mv file2 file1//将 file2 命名为 file1, 如果 file1 中有内容, 则覆盖 mv dir/* dir1//将 dir 中所有目录及文件移动到 dir1 目录中 </p>
<p>移动目录:<br>mv dir dir1//将 dir 目录移动到 dir1 目录中 mv dir2 dir3 dir1//将 dir2 和 dir3 移动到 dir1 中 </p>
<p>rm:remove 删除删除文件:<br>rm a.txt //删除 a.txt rm a.txt b.txt //同时删除 a.txt b.txt<br>rm <em>txt//删除所有扩展名为 txt 的文件 rm -rf dir1/</em> //强制删除 dir1 下所有文件和目录 </p>
<p>删除目录: rm -rf dir1// 删除 dir1 下的所有文件和目录, f 是强制删除, 不需要提示 </p>
<p>cd:切换目录 cd .. //跳转到上一级目录 cd ~ //跳转到根目录 cd /usr/local //跳转到 usr 下的 local 目录 </p>
<p>pwd:显示当前的目录 </p>
<p>touch:创建文件<br>语法:touch filename </p>
<p>touch myfile1//创建单个文件,文件名为 myfile1 touch myfile2 myfile3//同时创建两个文件 touch myfile{1..10}//创建多个文件 </p>
<p>cat<br>功能 1: 查询文件内容,查询全部文件内容(如果文件过大, 会卡死)<br>cat filename// 查看文件名 filename 的文件内容 </p>
<p>功能 2: 可以创建文件, 并且写入内容<br>cat &gt; myfile10 </p>
<p>功能 3:合并文件,合并内容<br>cat myfile1 myfile2 &gt; myfile10//将 myfile1 和 myfile2 中的内容合并到 myfile10 中, myfile10 中内<br>容被覆盖<br>more: 查看文件, 可以分页查看 +n 从第几行开始<br>-n 定义屏幕显示多少行 </p>
<p>more myfile//分页查看 myfile 文件 more +3 myfile//从第三行开始查看 myfile 文件 more -2 myfile//每页显示两行 more +/pattern myfile//从 myfile 中搜索 pattern, 结果显示在第三行 </p>
<p>less: 查看文件, 分页上下翻滚页 </p>
<p>head: 查看文件, 分页显示, 每页只显示 10 条 head myfile// 默认每页只显示 10 条 head -n 5 myfile//查看 myfile1,每页显示 5 条记录 head -c 12 myfile//查看 myfile,只显示前面 12 字节符 tail:查看文件, 实时监控文件 tail -f myfile// 实时监控 myfile 文件的变化<br>which:查找命令 which 命令<br>which mv//将 mv 命令的别名和 mv 所在的位置都给查询出来 </p>
<p>whereis: 查找命令 whereis mv: 查找命令的所在位置, 帮助文档,命令源码 </p>
<p>locate: 查找文件 locate myfile//搜索出来 myfile 所在目录, 需要先刷新 db, 使用命令: updatedb<br>新创建的文件搜索不到,新创建的文件被放在 Linux 的文件数据库, 需要属性文件数据库才能够找到 </p>
<p>find: 查找文件 find -name myfile//根据文件名, 在当前的目录进行查询 find -name “myfile”//和上面一个没有区别 find /etc/ /root/ -name “<em>[A-Z]</em>“ //查询目录 etc 和 root 下以 A-Z 开头的所有文件 find /etc/ /root/ -name “<em>[A-Z]</em>“ -exec ls -l {} ;// 把查询结果交给 ls 命令继续执行, 显示前面查询<br>结果详细信息.<br>-exec:执行,执行后面的命令,执行 ls -l 命令<br>{}: 标识查询结果在一行显示<br>; :命令要使用很好结束,斜杠是用来转义的. </p>
<p>| (管道命令)<br>把前面的查询结果交给后面的命令进行执行<br>ls -al | more -5 //查询所有,把查询的结果交给 more 命令去执行 </p>
<p>grep (过滤命令) 经常和管道命令一起使用<br>ps -ef | grep svn//查询所有进程, 过滤查询 svn </p>
<p>ln: 连接命令,创建快捷方式<br>ln -s myfile link//给 myfile 创建一个快捷方式 link </p>
<p>top:显示当前系统中消耗资源的进程情况 top //每隔 5 秒显示徐偶有进程的资源占用情况<br>top -d 2//每隔 2 秒刷新 </p>
<p>ps: 查看进程(常用) ps -ef//查看所有进程 ps -ef | grep redis //查看 redis 进程是否存在 </p>
<p>kill: 杀死进程(常用)<br>kill -9 PID<br>df: 显示磁盘使用情况 df -h//查看当前磁盘使用情况, 包括占用量单位 </p>
<p>shutdown: 关机 shutdown 系统关机 shutdown -r 关机后立即重启 shutdown -h 关机后不重新启动 </p>
<p>halt: 关机后关闭电源 </p>
<p>reboot: 重新启动 </p>
<p>=============================解压缩命令<br>gzip zip bzip2 压缩命令<br>gzip: 压缩文件, 不能够压缩目录<br>gzip file3// 把 file3 压缩, 压缩后文件名变为: file3.gz gunzip: 解压  gunzip file3.gz//解压单个文件 gunzip file1.gz file2.gz //解压多个文件<br>通常使用 gzip -d 来解压 gzip -dv file1.gz// 解压 file1, v 是视图可以看到解压过程 </p>
<p>bzip2 和 gzip 压缩方式一样 </p>
<p>zip:<br>zip myzip.zip file1 //将 file1 压缩成 myzip.zip unzip myzip.zip// 解压 </p>
<p>tar: 打包命令, 将多个文件压缩成一个文件<br>tar -cvf dir.tar dir//将 dir 目录下所有文件打包成 dir.tar<br>tar -xvf dir1.tar//解包 </p>
<p>gzip dir.tar //压缩 tar 文件变成 dir.tar.gz tar -zxvf dir.tar.gz//解压 dir.tar.gz 到 dir<br>-z:解压 gz 扩展名的文件<br>-x:解压 tar 包<br>-v:显示执行过程<br>-f:指定解压文件 </p>
<p>bzip2 dir.tar//使用 bzip2 压缩 tar 包: dir.tar.bz2<br>tar -jxvf dir.tar.bz2//解压 bzip2 格式包 </p>
<p>==============vim 文本编辑器 vim 进入编辑器 vi 有 3 总模式: 插入模式,命令模式,低行模式<br>1,插入模式 i 进入插入模式<br>2,命令模式 esc 进入命令模式<br>3,底行模式<br>:或者/ 进入底行模式<br>在命令模式下:<br>基本:<br>a:在当前光标位置的右边添加文本 i:在当前光标的位置的左边添加文本<br>A:在当前行的末尾位置添加文本<br>I:在当前行的开始处添加文本<br>O: 在当前行上面创建一行<br>0: 在当前行下面创建一行 R:替换(覆盖)当前光标位置及后面的若干文本<br>J:合并光标所在行及下一行为一行 </p>
<p>删除,撤销:<br>x:删除当前字符 nx: 删除从光标开始的 n 个字符 dd:删除当前行 ndd:删除 n 行 u:撤销上一步操作<br>U:撤销当前行的操作 </p>
<p>搜索:<br>/vpser: 向光标下搜索 vpser 字符串<br>?vpser: 向光标闪搜索 vpser 字符串 n: 先下搜索前一个搜索动作<br>N: 向上搜索前一个搜索动作 </p>
<p>跳转指定行:<br>n+: 向下跳转 n 行 n-: 向下跳转 n 行 nG: 调到行号为 n 的行<br>G: 跳至文件的底部 </p>
<p>设置行号:<br>:set nu //显示行号<br>:set noun//取消显示行号 </p>
<p>复制粘贴:<br>yy: 将当前行复制到缓存区 nyy:将当前行向下 n 行复制到缓存区 p: 当前行的下面进行粘贴 P: 当前光标所在行的上面进行粘贴 yw:复制光标到单词词尾 nyw:复制从光标开始的 n 个单词 y^: 复制从光标到行首的内容 y$: 复制从光标到行尾的内容 </p>
<p>替换:<br>:s/old/new //用 new 替换行中首次出现的 old 这个单词为 new<br>:s/old/new/g //用 new 替换当前行中所有的 old 单词<br>:n,m s/old/new/g //用 new 替换从 n 到 m 行在哪个所有的 old 单词<br>:%s/old/new/g //用 new 替换当前文件中的所有 old </p>
<p>8,权限管理<br>==================权限管理<br>-rwxrw-r– </p>
<ul>
<li>:类型<br>rwx:所属用户权限 rw-:所属组权限 r–:其他用户权限 </li>
</ul>
<p>最高位:文件类型<br>-: 普通文件 d: 目录 l: 快捷方式文件<br>高三位:u 所属用户权限(rwx) 中间三位:g 用户所属组权限(rw-) 第三位:o 其他用户权限(r–)<br>设置权限第一种方式举例:<br>———- file1: file1 无权限 (使用 chmod 0 file1 就取消所有权限) 设置权限: (x:执行权限 r:读权限 w:写权限)<br>chmod u+x file1—-&gt; —x—— file1 chmod u+r file1—-&gt; -r-x—— file1 chmod g+w file1—-&gt; -r-x-w—- file1 chmod g+rx file1—&gt; -r-xrwx— file1 chmod o+rwx file1–&gt; -r-xrwxrwx file1 </p>
<p>chomod o=x file1—&gt; -r-xrwx–x file1 </p>
<p>设置权限第二种方式举例: 用 421 来代表 rwx, 对应关系如下:<br>421 421 421 rwx rwx rwx<br>chmod 后面每一位数字匹配三位: 3=2(w)+1(x) 5=4(r)+1(x)<br>chmod 421 file1—–&gt; -r—w—x file1 (4 代表用户的读权限,2 代表组的写权限,1 代表其他用户的执行权限)<br>chmod 354 file1—–&gt; -rwxrwxw-x file1<br>9,安装软件<br>=======================安装软件 rpm: 安装麻烦 不建议使用 yum: 支持在线升级<br>1,关联 dvd 磁盘到本地: 右键 CentOS 选择 Settings, 然后找到 CD/DVD 选择 connected 即可. </p>
<p>2,Yum 命令支持在线升级,执行 yum 命令的时候,检测/etc/yum.repos.d/下面所有 repo 文件. repo 文件里面存储的是网址,yum 命令检测 repo 文件里面网址直接去网上下载. 可以把 repo 文件修改, 让 repo 文件指向本地的 dvd 盘.<br>3,挂载 dvd 盘到 mnt 目录<br>挂载命令:mount /dev/cdrom/ mnt/<br>挂载成功截图: </p>
<p>4,修改 repo 文件先备份 repo 文件: rename .repo .bak * //将所有 repo 扩展名的文件修改为后缀为.bak 创建自己的 repo 文件,指向本地文件:touch mine.repo 进入 vim 编辑 repo 文件: vim mine.repo<br>[centos6.6] name=centos-dvd<br>baseurl=file:///mnt gpgcheck=0 enabled=1 清空 yum 源:yum clean all 加载 yum 源:yum repolist all </p>
<p>安装 mysql: yum install mysql-server  </p>
<p>启动 mysql:service mysqld start </p>
<p>登录数据库:mysql -uroot p </p>
<p>查询数据库:show databases; </p>
<p>======================安装 jdk 和 tomcat<br>1, 先将 jdk 和 tomcat 传输到 Linux root 目录下 </p>
<p>2, 在 usr/local 下建立文件夹存放 jdk 和 tomcat 安装包: mkdir hadoop </p>
<p>3, 移动 root 目录下安装包 到 usr/local 目录下: mv jdk-7u55-linux-i586.tar.gz apache-tomcat7.0.47.tar.gz /usr/local/hadoop/ </p>
<p>4, 解压安装包: tar -zxvf jdk-7u55-linux-i586.tar.gz  tar -zxvf apache-tomcat-7.0.47.tar.gz 5,配置环境变量: vim profile 在最后一行添加: export JAVA_HOME=/usr/local/hadoop/jdk1.7.0_55 export PATH=$JAVA_HOME/bin:$PATH </p>
<p>6,刷新设置: source /etc/profile<br>7,查看是否安装成功:java -version </p>
<p>常见问题:<br>1,修复/lib/ld-linux.so.2: bad ELF interpreter: No such file or directory 问题<br>解决方案:在 64 系统里执行 32 位程序如果出现/lib/ld-linux.so.2:<br>bad ELF interpreter: No such file or directory，<br>安装下 glic 即可:sudo yum install glibc.i686<br>2,error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory 使用:sudo yum install zlib.i686  </p>
<p>====================安装 lrzsz(可以上传文件到指定目录)<br>1,安装:yum install lrzsz<br>2,安装后使用命令: cd /usr/local/hadoop/<br>rz: 直接弹出传输对话框<br>3,将 tomcat 传递到 hadoop 目录下<br>4,启动 tomcat<br>cd /usr/local/hadoop/apache-tomcat-7.0.47/bin/<br>./startup.sh </p>
]]></content>
  </entry>
  <entry>
    <title>Java输入输出</title>
    <url>/Java%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><p>在前面的代码中，我们总是使用System.out.println()来向屏幕输出一些内容。</p>
<p>println是print line的缩写，表示输出并换行。因此，如果输出后不想换行，可以用print()：</p>
<figure class="highlight plain"><figcaption><span>class Main &#123;</span></figcaption><table><tr><td class="code"><pre><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.print(&quot;A,&quot;);</span><br><span class="line">        System.out.print(&quot;B,&quot;);</span><br><span class="line">        System.out.print(&quot;C.&quot;);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(&quot;END&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>格式化输出<br>Java还提供了格式化输出的功能。为什么要格式化输出？因为计算机表示的数据不一定适合人来阅读：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        double d &#x3D; 12900000;</span><br><span class="line">        System.out.println(d); &#x2F;&#x2F; 1.29E7</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要把数据显示成我们期望的格式，就需要使用格式化输出的功能。格式化输出使用System.out.printf()，通过使用占位符%?，printf()可以把后面的参数格式化成指定格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        double d &#x3D; 3.1415926;</span><br><span class="line">        System.out.printf(&quot;%.2f\n&quot;, d); &#x2F;&#x2F; 显示两位小数3.14</span><br><span class="line">        System.out.printf(&quot;%.4f\n&quot;, d); &#x2F;&#x2F; 显示4位小数3.1416</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java的格式化功能提供了多种占位符，可以把各种数据类型“格式化”成指定的字符串：</p>
<table>
<thead>
<tr>
<th>占位符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%d</td>
<td>格式化输出整数</td>
</tr>
<tr>
<td>%x</td>
<td>格式化输出十六进制整数</td>
</tr>
<tr>
<td>%f</td>
<td>格式化输出浮点数</td>
</tr>
<tr>
<td>%e</td>
<td>格式化输出科学计数法表示的浮点数</td>
</tr>
<tr>
<td>%s</td>
<td>格式化字符串</td>
</tr>
</tbody></table>
<p>注意，由于%表示占位符，因此，连续两个%%表示一个%字符本身。</p>
<p>占位符本身还可以有更详细的格式化参数。下面的例子把一个整数格式化成十六进制，并用0补足8位：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int n &#x3D; 12345000;</span><br><span class="line">        System.out.printf(&quot;n&#x3D;%d, hex&#x3D;%08x&quot;, n, n); &#x2F;&#x2F; 注意，两个%占位符必须传入两个数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详细的格式化参数请参考JDK文档<a href="java.util.Formatter">java.util.Formatter</a></p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>和输出相比，Java的输入就要复杂得多。</p>
<p>我们先看一个从控制台读取一个字符串和一个整数的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner &#x3D; new Scanner(System.in); &#x2F;&#x2F; 创建Scanner对象</span><br><span class="line">        System.out.print(&quot;Input your name: &quot;); &#x2F;&#x2F; 打印提示</span><br><span class="line">        String name &#x3D; scanner.nextLine(); &#x2F;&#x2F; 读取一行输入并获取字符串</span><br><span class="line">        System.out.print(&quot;Input your age: &quot;); &#x2F;&#x2F; 打印提示</span><br><span class="line">        int age &#x3D; scanner.nextInt(); &#x2F;&#x2F; 读取一行输入并获取整数</span><br><span class="line">        System.out.printf(&quot;Hi, %s, you are %d\n&quot;, name, age); &#x2F;&#x2F; 格式化输出</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，我们通过import语句导入java.util.Scanner，import是导入某个类的语句，必须放到Java源代码的开头，后面我们在Java的package中会详细讲解如何使用import。</p>
<p>然后，创建Scanner对象并传入System.in。System.out代表标准输出流，而System.in代表标准输入流。直接使用System.in读取用户输入虽然是可以的，但需要更复杂的代码，而通过Scanner就可以简化后续的代码。</p>
<p>有了Scanner对象后，要读取用户输入的字符串，使用scanner.nextLine()，要读取用户输入的整数，使用scanner.nextInt()。Scanner会自动转换数据类型，因此不必手动转换。</p>
<p>要测试输入，我们不能在线运行它，因为输入必须从命令行读取，因此，需要走编译、执行的流程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ javac Main.java</span><br></pre></td></tr></table></figure>
<p>这个程序编译时如果有警告，可以暂时忽略它，在后面学习IO的时候再详细解释。编译成功后，执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ java Main</span><br><span class="line">Input your name: Bob</span><br><span class="line">Input your age: 12</span><br><span class="line">Hi, Bob, you are 12</span><br></pre></td></tr></table></figure>
<p>根据提示分别输入一个字符串和整数后，我们得到了格式化的输出。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Java提供的输出包括：System.out.println() / print() / printf()，其中printf()可以格式化输出；</p>
<p>Java提供Scanner对象来方便输入，读取对应的类型可以使用：scanner.nextLine() / nextInt() / nextDouble() / …</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>最全常用正则表达式大全</title>
    <url>/%E6%9C%80%E5%85%A8%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%A4%A7%E5%85%A8.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>一、校验数字的表达式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 数字：^[0-9]*$</span><br><span class="line"></span><br><span class="line">2. n位的数字：^\d&#123;n&#125;$</span><br><span class="line"></span><br><span class="line">3. 至少n位的数字：^\d&#123;n,&#125;$</span><br><span class="line"></span><br><span class="line">4. m-n位的数字：^\d&#123;m,n&#125;$</span><br><span class="line"></span><br><span class="line">5. 零和非零开头的数字：^(0|[1-9][0-9]*)$</span><br><span class="line"></span><br><span class="line">6. 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$</span><br><span class="line"></span><br><span class="line">7. 带1-2位小数的正数或负数：^(\-)?\d+(\.\d&#123;1,2&#125;)?$</span><br><span class="line"></span><br><span class="line">8. 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$</span><br><span class="line"></span><br><span class="line">9. 有两位小数的正实数：[0-9]+(.[0-9]&#123;2&#125;)?$</span><br><span class="line"></span><br><span class="line">10. 有1~3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$</span><br><span class="line"></span><br><span class="line">11. 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\+?[1-9][0-9]*$</span><br><span class="line"></span><br><span class="line">12. 非零的负整数：^\-[1-9][]0-9&quot;*$ 或 ^-[1-9]\d*$</span><br><span class="line"></span><br><span class="line">13. 非负整数：^\d+$ 或 ^[1-9]\d*|0$</span><br><span class="line"></span><br><span class="line">14. 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$</span><br><span class="line"></span><br><span class="line">15. 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$</span><br><span class="line"></span><br><span class="line">16. 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$</span><br><span class="line"></span><br><span class="line">17. 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$</span><br><span class="line"></span><br><span class="line">18. 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$</span><br><span class="line"></span><br><span class="line">19. 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">二、校验字符的表达式</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">1. 汉字：^[\u4e00-\u9fa5]&#123;0,&#125;$</span><br><span class="line"></span><br><span class="line">2. 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$</span><br><span class="line"></span><br><span class="line">3. 长度为3-20的所有字符：^.&#123;3,20&#125;$</span><br><span class="line"></span><br><span class="line">4. 由26个英文字母组成的字符串：^[A-Za-z]+$</span><br><span class="line"></span><br><span class="line">5. 由26个大写英文字母组成的字符串：^[A-Z]+$</span><br><span class="line"></span><br><span class="line">6. 由26个小写英文字母组成的字符串：^[a-z]+$</span><br><span class="line"></span><br><span class="line">7. 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$</span><br><span class="line"></span><br><span class="line">8. 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w&#123;3,20&#125;$</span><br><span class="line"></span><br><span class="line">9. 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$</span><br><span class="line"></span><br><span class="line">10. 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]&#123;2,20&#125;$</span><br><span class="line"></span><br><span class="line">11. 可以输入含有^%&amp;&#39;,;&#x3D;?$\&quot;等字符：[^%&amp;&#39;,;&#x3D;?$\x22]+ 12 禁止输入含有~的字符：[^~\x22]+</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">其它：</span><br><span class="line"></span><br><span class="line">.*匹配除 \n 以外的任何字符。</span><br><span class="line"></span><br><span class="line">&#x2F;[\u4E00-\u9FA5]&#x2F; 汉字</span><br><span class="line"></span><br><span class="line">&#x2F;[\uFF00-\uFFFF]&#x2F; 全角符号</span><br><span class="line"></span><br><span class="line">&#x2F;[\u0000-\u00FF]&#x2F; 半角符号</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">三、特殊需求表达式</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">1. Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</span><br><span class="line"></span><br><span class="line">2. 域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(&#x2F;.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+&#x2F;.?</span><br><span class="line"></span><br><span class="line">3. InternetURL：[a-zA-z]+:&#x2F;&#x2F;[^\s]* 或 ^http:&#x2F;&#x2F;([\w-]+\.)+[\w-]+(&#x2F;[\w-.&#x2F;?%&amp;&#x3D;]*)?$</span><br><span class="line"></span><br><span class="line">4. 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$</span><br><span class="line"></span><br><span class="line">5. 电话号码(&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX)：^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$</span><br><span class="line"></span><br><span class="line">6. 国内电话号码(0511-4405222、021-87888822)：\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;</span><br><span class="line"></span><br><span class="line">7. 身份证号(15位、18位数字)：^\d&#123;15&#125;|\d&#123;18&#125;$</span><br><span class="line"></span><br><span class="line">8. 短身份证号码(数字、字母x结尾)：^([0-9])&#123;7,18&#125;(x|X)?$ 或 ^\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?$</span><br><span class="line"></span><br><span class="line">9. 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$</span><br><span class="line"></span><br><span class="line">10. 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w&#123;5,17&#125;$</span><br><span class="line"></span><br><span class="line">11. 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?&#x3D;.*\d)(?&#x3D;.*[a-z])(?&#x3D;.*[A-Z]).&#123;8,10&#125;$</span><br><span class="line"></span><br><span class="line">12. 日期格式：^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;</span><br><span class="line"></span><br><span class="line">13. 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$</span><br><span class="line"></span><br><span class="line">14. 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$</span><br><span class="line"></span><br><span class="line">15. 钱的输入格式：</span><br><span class="line"></span><br><span class="line">16. 1.有四种钱的表示形式我们可以接受:&quot;10000.00&quot; 和 &quot;10,000.00&quot;, 和没有 &quot;分&quot; 的 &quot;10000&quot; 和 &quot;10,000&quot;：^[1-9][0-9]*$</span><br><span class="line"></span><br><span class="line">17. 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符&quot;0&quot;不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$</span><br><span class="line"></span><br><span class="line">18. 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$</span><br><span class="line"></span><br><span class="line">19. 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$</span><br><span class="line"></span><br><span class="line">20. 5.必须说明的是,小数点后面至少应该有1位数,所以&quot;10.&quot;是不通过的,但是 &quot;10&quot; 和 &quot;10.2&quot; 是通过的：^[0-9]+(.[0-9]&#123;2&#125;)?$</span><br><span class="line"></span><br><span class="line">21. 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]&#123;1,2&#125;)?$</span><br><span class="line"></span><br><span class="line">22. 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$</span><br><span class="line"></span><br><span class="line">23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$</span><br><span class="line"></span><br><span class="line">24. 备注：这就是最终结果了,别忘了&quot;+&quot;可以用&quot;*&quot;替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里</span><br><span class="line"></span><br><span class="line">25. xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$</span><br><span class="line"></span><br><span class="line">26. 中文字符的正则表达式：[\u4e00-\u9fa5]</span><br><span class="line"></span><br><span class="line">27. 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))</span><br><span class="line"></span><br><span class="line">28. 空白行的正则表达式：\n\s*\r (可以用来删除空白行)</span><br><span class="line"></span><br><span class="line">29. HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;&#x2F;\1&gt;|&lt;.*? &#x2F;&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)</span><br><span class="line"></span><br><span class="line">30. 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</span><br><span class="line"></span><br><span class="line">31. 腾讯QQ号：[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始)</span><br><span class="line"></span><br><span class="line">32. 中国邮政编码：[1-9]\d&#123;5&#125;(?!\d) (中国邮政编码为6位数字)</span><br><span class="line"></span><br><span class="line">33. IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用)</span><br><span class="line"></span><br><span class="line">34. IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))</span><br><span class="line"></span><br><span class="line">35. IP-v4地址：\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b (提取IP地址时有用)</span><br><span class="line">36. 校验IP-v6地址:(([0-9a-fA-F]&#123;1,4&#125;:)&#123;7,7&#125;[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,7&#125;:|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,6&#125;:[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,5&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,2&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,3&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,3&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,2&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,5&#125;|[0-9a-fA-F]&#123;1,4&#125;:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,6&#125;)|:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,7&#125;|:)|fe80:(:[0-9a-fA-F]&#123;0,4&#125;)&#123;0,4&#125;%[0-9a-zA-Z]&#123;1,&#125;|::(ffff(:0&#123;1,4&#125;)&#123;0,1&#125;:)&#123;0,1&#125;((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;:((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9]))</span><br><span class="line">37. 子网掩码：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))</span><br><span class="line">38. 校验日期:^(?:(?!0000)[0-9]&#123;4&#125;-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]&#123;2&#125;(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$(“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。)</span><br><span class="line">39. 抽取注释：&lt;!--(.*?)--&gt;</span><br><span class="line">40. 查找CSS属性:^\\s*[a-zA-Z\\-]+\\s*[:]&#123;1&#125;\\s[a-zA-Z0-9\\s.#]+[;]&#123;1&#125;</span><br><span class="line">41. 提取页面超链接:(&lt;a\\s*(?!.*\\brel&#x3D;)[^&gt;]*)(href&#x3D;&quot;https?:\\&#x2F;\\&#x2F;)((?!(?:(?:www\\.)?&#39;.implode(&#39;|(?:www\\.)?&#39;, $follow_list).&#39;))[^&quot; rel&#x3D;&quot;external nofollow&quot; ]+)&quot;((?!.*\\brel&#x3D;)[^&gt;]*)(?:[^&gt;]*)&gt;</span><br><span class="line">42. 提取网页图片:\\&lt; *[img][^\\\\&gt;]*[src] *&#x3D; *[\\&quot;\\&#39;]&#123;0,1&#125;([^\\&quot;\\&#39;\\ &gt;]*)</span><br><span class="line">43. 提取网页颜色代码:^#([A-Fa-f0-9]&#123;6&#125;|[A-Fa-f0-9]&#123;3&#125;)$</span><br><span class="line">44. 文件扩展名效验:^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\&#x2F;:*?&quot;&lt;&gt;|]+\\.txt(l)?$</span><br><span class="line">45. 判断IE版本：^.*MSIE [5-8](?:\\.[0-9]+)?(?!.*Trident\\&#x2F;[5-9]\\.0).*$</span><br></pre></td></tr></table></figure>
<p>::: hljs-center</p>
<p>表达式全集</p>
<p>:::<br>正则表达式有多种不同的风格。下表是在PCRE中元字符及其在正则表达式上下文中的行为的一个完整列表：<br><img src="/images/2020/07/30/4b94a700-9b71-4da7-9f0d-a51964525447.png" alt="image.png"><br><img src="/images/2020/07/30/62562774-c2de-40c5-b08b-aa383afc7a61.png" alt="image.png"><br><img src="/images/2020/07/30/85516dd0-52c4-4941-b44f-3b1c943ac5e5.png" alt="image.png"><br>以下是以PHP的语法所写的示例</p>
<p>验证字符串是否只含数字与英文，字符串长度并在4~16个字符之间</p>
<?php $str = 'a1234'; if (preg_match("^[a-zA-Z0-9]{4,16}$", $str)) { echo "驗證成功"; } else { echo "驗證失敗"; } ?><p><br>简易的台湾身份证字号验证</p>
<?php $str = 'a1234'; if (preg_match("/^\w[12]\d{8}$/", $str)) { echo "驗證成功"; } else { echo "驗證失敗"; } ?><p><br>以下示例是用 Perl 语言写的，与上面的示例功能相同</p>
<p>print $str = “a1234” =~ m:^[a-zA-Z0-9]{4,16}$: ? “COMFIRM” : “FAILED”;<br>print $str = “a1234” =~ m”^\w[12]\d{8}$” ? “COMFIRM” : “INVAILD”;<br>::: hljs-center</p>
<p>如何写出高效率的正则表达式</p>
<p>:::</p>
<p>如果纯粹是为了挑战自己的正则水平，用来实现一些特效（例如使用正则表达式计算质数、解线性方程），效率不是问题；如果所写的正则表达式只是为了满足一两次、几十次的运行，优化与否区别也不太大。但是，如果所写的正则表达式会百万次、千万次地运行，效率就是很大的问题了。我这里总结了几条提升正则表达式运行效率的经验（工作中学到的，看书学来的，自己的体会），贴在这里。如果您有其它的经验而这里没有提及，欢迎赐教。</p>
<p>为行文方便，先定义两个概念。</p>
<p>误匹配：指正则表达式所匹配的内容范围超出了所需要范围，有些文本明明不符合要求，但是被所写的正则式“击中了”。例如，如果使用\d{11}来匹配11位的手机号，\d{11}不单能匹配正确的手机号，它还会匹配98765432100这样的明显不是手机号的字符串。我们把这样的匹配称之为误匹配。</p>
<p>漏匹配：指正则表达式所匹配的内容所规定的范围太狭窄，有些文本确实是所需要的，但是所写的正则没有将这种情况囊括在内。例如，使用\d{18}来匹配18位的身份证号码，就会漏掉结尾是字母X的情况。</p>
<p>写出一条正则表达式，既可能只出现误匹配（条件写得极宽松，其范围大于目标文本），也可能只出现漏匹配（只描述了目标文本中多种情况种的一种），还可能既有误匹配又有漏匹配。例如，使用\w+.com来匹配.com结尾的域名，既会误匹配abc_.com这样的字串（合法的域名中不含下划线，\w包含了下划线这种情况），又会漏掉ab-c.com这样的域名（合法域名中可以含中划线，但是\w不匹配中划线）。</p>
<p>精准的正则表达式意味着既无误匹配且无漏匹配。当然，现实中存在这样的情况：只能看到有限数量的文本，根据这些文本写规则，但是这些规则将会用到海量的文本中。这种情况下，尽可能地（如果不是完全地）消除误匹配以及漏匹配，并提升运行效率，就是我们的目标。本文所提出的经验，主要是针对这种情况。</p>
<p>掌握语法细节。正则表达式在各种语言中，其语法大致相同，细节各有千秋。明确所使用语言的正则的语法的细节，是写出正确、高效正则表达式的基础。例如，perl中与\w等效的匹配范围是[a-zA-Z0-9_]；perl正则式不支持肯定逆序环视中使用可变的重复（variable repetition inside lookbehind，例如(?&lt;=.*)abc），但是.Net语法是支持这一特性的；又如，JavaScript连逆序环视（Lookbehind,如(?&lt;=ab)c）都不支持，而perl和Python是支持的。《精通正则表达式》第3章《正则表达式的特性和流派概览》明确地列出了各大派系正则的异同，这篇文章也简要地列出了几种常用语言、工具中正则的比较。对于具体使用者而言，至少应该详细了解正在使用的那种工作语言里正则的语法细节。</p>
<p>先粗后精，先加后减。使用正则表达式语法对于目标文本进行描述和界定，可以像画素描一样，先大致勾勒出框架，再逐步在局步实现细节。仍举刚才的手机号的例子，先界定\d{11}，总不会错；再细化为1[358]\d{9}，就向前迈了一大步（至于第二位是不是3、5、8，这里无意深究，只举这样一个例子，说明逐步细化的过程）。这样做的目的是先消除漏匹配（刚开始先尽可能多地匹配，做加法），然后再一点一点地消除误匹配（做减法）。这样有先有后，在考虑时才不易出错，从而向“不误不漏”这个目标迈进。</p>
<p>留有余地。所能看到的文本sample是有限的，而待匹配检验的文本是海量的，暂时不可见的。对于这样的情况，在写正则表达式时要跳出所能见到的文本的圈子，开拓思路，作出“战略性前瞻”。例如，经常收到这样的垃圾短信：“发<em>票”、“发#漂”。如果要写规则屏蔽这样烦人的垃圾短信，不但要能写出可以匹配当前文本的正则表达式 发[</em>#](?:票|漂)，还要能够想到 发.(?:票|漂|飘)之类可能出现的“变种”。这在具体的领域或许会有针对性的规则，不多言。这样做的目的是消除漏匹配，延长正则表达式的生命周期。</p>
<p>明确。具体说来，就是谨慎用点号这样的元字符，尽可能不用星号和加号这样的任意量词。只要能确定范围的，例如\w，就不要用点号；只要能够预测重复次数的，就不要用任意量词。例如，写析取twitter消息的脚本，假设一条消息的xml正文部分结构是<span class=”msg”>…</span>且正文中无尖括号，那么<span class=”msg”>[^&lt;]{1,480}</span>这种写法的思路要好于<span class=”msg”>.*</span>，原因有二：一是使用[^&lt;]，它保证了文本的范围不会超出下一个小于号所在的位置；二是明确长度范围，{1,480}，其依据是一条twitter消息大致能的字符长度范围。当然，480这个长度是否正确还可推敲，但是这种思路是值得借鉴的。说得狠一点，“滥用点号、星号和加号是不环保、不负责任的做法”。</p>
<p>不要让稻草压死骆驼。每使用一个普通括号()而不是非捕获型括号(?:…)，就会保留一部分内存等着你再次访问。这样的正则表达式、无限次地运行次数，无异于一根根稻草的堆加，终于能将骆驼压死。养成合理使用(?:…)括号的习惯。</p>
<p>宁简勿繁。将一条复杂的正则表达式拆分为两条或多条简单的正则表达式，编程难度会降低，运行效率会提升。例如用来消除行首和行尾空白字符的正则表达式s/^\s+|\s+$//g;，其运行效率理论上要低于s/^\s+//g; s/\s+$//g; 。这个例子出自《精通正则表达式》第五章，书中对它的评论是“它几乎总是最快的，而且显然最容易理解”。既快又容易理解，何乐而不为？工作中我们还有其它的理由要将C==(A|B)这样的正则表达式拆为A和B两条表达式分别执行。例如，虽然A和B这两种情况只要有一种能够击中所需要的文本模式就会成功匹配，但是如果只要有一条子表达式（例如A）会产生误匹配，那么不论其它的子表达式（例如B）效率如何之高，范围如何精准，C的总体精准度也会因A而受到影响。</p>
<p>巧妙定位。有时候，我们需要匹配的the，是作为单词的the（两边有空格），而不是作为单词一部分的t-h-e的有序排列（例如together中的the）。在适当的时候用上^，$，\b等等定位锚点，能有效提升找到成功匹配、淘汰不成功匹配的效率。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>华为ENSP命令大全</title>
    <url>/%E5%8D%8E%E4%B8%BAENSP%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>一、 生成树STP</p>
<p>注：桥优先级取值越小，则优先级越高，通过配置优先级（开销值cost）可控制根桥选举。当根桥发生故障则会选举新的根桥，当故障恢复根桥重新选举。通过设置端口优先级会改变对端交换机的端口角色。当非根交换机根端口发生故障另外一个端口会自动变为根端口</p>
<p>1、        stp enable启用stp</p>
<p>2、        stp mode stp</p>
<p>3、        stp root primary配置为根桥</p>
<p>4、        stp root secondary 次要的（备份根桥）</p>
<p>5、        display stp brief 查看stp信息</p>
<p>6、        display stp interface命令查看端口的STP状态</p>
<p>7、        display stp查看根桥信息</p>
<p>8、        stp priority 8192设置优先级</p>
<p>9、        stp por priority 16修改端口优先级</p>
<p>10、    display stp interface GigabitEthernet 0/0/9查看端口信息，优先级等….</p>
<p>11、    stp port priority 32设置端口优先级</p>
<p>12、    display current-configuration查看主要配置</p>
<p>13、    stp cost 200000修改端口开销值</p>
<p>二、 生成树RSTP</p>
<p>注：连接用户终端的端口为边缘端口。边缘端口可以不通过RSTP计算直接由Discarding状态转变为Forwarding状态。</p>
<p>边缘端口直接与用户终端相连，正常情况下不会收到BPDU报文。但如果攻击者向交换机的边缘端口发送伪造的BPDU报文，交换机会自动将边缘端口设置为非边缘端口，并重新进行生成树计算，从而引起网络震荡。在交换机上配置BPDU保护功能，可以防止该类攻击。</p>
<p>在运行RSTP协议的网络中，交换机依靠不断接收来自上游设备的BPDU报文维持根端口和Alternate端口的状态。如果由于链路拥塞或者单向链路故障导致交换机收不到来自上游设备的BPDU报文，交换机会重新选择根端口。原先的根端口会转变为指定端口，而原先的阻塞端口会迁移到转发状态，从而会引起网络环路。可以在交换机上配置环路保护功能，避免此种情况发生。</p>
<p>1、        stp mode rstp开启rstp</p>
<p>2、        display stp查看rstp的简要信息</p>
<p>3、        stp edged-port enable</p>
<p>4、        stp bpdu-protection开启边缘端口保护功能</p>
<p>5、        display stp brief查看stp端口信息</p>
<p>6、        stp loop-protection配置环路保护功能</p>
<p>三、 路由配置</p>
<p>注：当链路发生故障时链路将不能实现通信，如果配置了备份静态路由网络则不受影响。需要注意的是，如果链路完好时路由表中则不存在备份路由条目，只有当链路故障时路由表中才会出现备份路由。备份路由的优先级必须低于链路的优先级，否则则会降低效率。</p>
<p>1、        display ip interface brief查看接口配置</p>
<p>2、        display ip routing-table查看路由表</p>
<p>3、        ip route-static 10.0.23.0 24 10.0.13.3配置静态路由（目标地址/下一跳）</p>
<p>4、        ip route-static 10.0.3.0 24 10.0.12.1 preference 80备份静态路由并配置优先级为80</p>
<p>5、        ip route-static 0.0.0.0 0.0.0.0 10.0.23.2 preference 80配置缺省路由</p>
<p>四、 配置RIPv1 和RIPv2</p>
<p>1、        rip 1启动rip协议</p>
<p>2、        network 10.0.0.0将网段发布到rip协议中</p>
<p>3、        debugging rip 1开启RIP调测功能，注意只能在用户视图下执行debugging命令</p>
<p>4、        display debugging查看当前的调测信息（用户视图）</p>
<p>5、        terminal debugging开启debug信息在终端屏幕上显示的功能</p>
<p>6、        undo debugging rip <process-id> or undo debugging all关闭调测功</p>
<p>7、        （rip 1）version 2配置RIPv2 协议</p>
<p>五、 RIPv2 路由汇总和认证</p>
<p>1、        rip 1启动rip协议</p>
<p>2、        [Huawei-rip-1]version 2启动ripv2协议</p>
<p>3、        rip summary-address IPadd 255.255.0.0 地址汇总（在进接口配置，相邻路由器查看）</p>
<p>4、        rip authentication-mode simple Huawei 配置明文认证</p>
<p>5、        reset ip routing-table statistics protocol rip清除在密码错误之前学到的路由信息（用户模式下）</p>
<p>6、        rip authentication-mode md5 usual Huawei 开启MD5认证</p>
<p>六、 OSPF 单区域配置</p>
<p>1、        ospf 1 router-id 10.0.1.1配置router id进入ospf1</p>
<p>2、        area 0 划分区域</p>
<p>3、        network 10.0.1.0 0.0.0.255 通告</p>
<p>4、        display ospf peer 查看邻居状态</p>
<p>5、        display ospf peer brief 查看简要的邻居状态信息</p>
<p>6、        display ospf interface GigabitEthernet 0/0/0查看接口信息（hello、dead时间参数）</p>
<p>7、        ospf timer hello/dead 15进接口修改报文时间</p>
<p>8、        ip route-static 0.0.0.0 0.0.0.0 LoopBack 2 创建缺省路由</p>
<p>9、        default-route-advertise 把缺省路由发布到ospf内</p>
<p>10、    ospf dr-priority 100修改端口dr优先级（修改优先级控制dr/bdr的选举）</p>
]]></content>
      <tags>
        <tag>ensp</tag>
      </tags>
  </entry>
  <entry>
    <title>思科模拟器配置命令大全</title>
    <url>/%E6%80%9D%E7%A7%91%E6%A8%A1%E6%8B%9F%E5%99%A8%E9%85%8D%E7%BD%AE%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><ol>
<li>计算机命令：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PCA login: root                                  ；使用root用户</span><br><span class="line"></span><br><span class="line">password: linux                                  ；口令是linux</span><br><span class="line"></span><br><span class="line"># shutdown -h now                               ；同init 0 关机</span><br><span class="line"></span><br><span class="line"># logout</span><br><span class="line"></span><br><span class="line"># login</span><br><span class="line"></span><br><span class="line"># ifconfig                                        ；显示IP地址</span><br><span class="line"></span><br><span class="line"># ifconfig eth0 &lt;ip address&gt; netmask &lt;netmask&gt;    ；设置IP地址</span><br><span class="line"></span><br><span class="line"># ifconfig eht0 &lt;ip address&gt; netmask &lt;netmask&gt; down ； 删除IP地址</span><br><span class="line"></span><br><span class="line"># route add 0.0.0.0 gw &lt;ip&gt;</span><br><span class="line"></span><br><span class="line"># route del 0.0.0.0 gw &lt;ip&gt;</span><br><span class="line"></span><br><span class="line"># route add default gw &lt;ip&gt;                      ；设置网关</span><br><span class="line"></span><br><span class="line"># route del default gw &lt;ip&gt;                      ；删除网关</span><br><span class="line"></span><br><span class="line"># route                                            ；显示网关</span><br><span class="line"></span><br><span class="line"># ping &lt;ip&gt;</span><br><span class="line"></span><br><span class="line"># telnet &lt;ip&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. 交换机支持的命令：</span><br><span class="line"></span><br><span class="line">交换机基本状态：</span><br><span class="line"></span><br><span class="line">switch:                                            ；交换机的ROM状态</span><br><span class="line"></span><br><span class="line">rommon&gt;                                            ；路由器的ROM状态</span><br><span class="line"></span><br><span class="line">hostname&gt;                                        ；用户模式</span><br><span class="line"></span><br><span class="line">hostname#                                        ；特权模式</span><br><span class="line"></span><br><span class="line">hostname(config)#                               ；全局配置模式</span><br><span class="line"></span><br><span class="line">hostname(config-if)#                                ；接口状态</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">交换机口令设置：</span><br><span class="line"></span><br><span class="line">switch&gt;enable                                      ；进入特权模式</span><br><span class="line"></span><br><span class="line">switch#config terminal                            ；进入全局配置模式</span><br><span class="line"></span><br><span class="line">switch(config)#hostname &lt;hostname&gt;                ；设置交换机的主机名</span><br><span class="line"></span><br><span class="line">switch(config)#enable secret xxx                    ；设置特权加密口令</span><br><span class="line"></span><br><span class="line">switch(config)#enable password xxa                ；设置特权非密口令</span><br><span class="line"></span><br><span class="line">switch(config)#line console 0                   ；进入控制台口</span><br><span class="line"></span><br><span class="line">switch(config-line)#line vty 0 4                    ；进入虚拟终端</span><br><span class="line"></span><br><span class="line">switch(config-line)#login                          ；允许登录</span><br><span class="line"></span><br><span class="line">switch(config-line)#password xx                    ；设置登录口令xx</span><br><span class="line"></span><br><span class="line">switch#exit                                     ；返回命令</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">交换机VLAN设置：</span><br><span class="line"></span><br><span class="line">switch#vlan database                                ；进入VLAN设置</span><br><span class="line"></span><br><span class="line">switch(vlan)#vlan 2                                ；建VLAN 2</span><br><span class="line"></span><br><span class="line">switch(vlan)#no vlan 2                            ；删vlan 2</span><br><span class="line"></span><br><span class="line">switch(config)#int f0&#x2F;1                         ；进入端口1</span><br><span class="line"></span><br><span class="line">switch(config-if)#switchport access vlan 2       ；当前端口加入vlan 2</span><br><span class="line"></span><br><span class="line">switch(config-if)#switchport mode trunk          ；设置为干线</span><br><span class="line"></span><br><span class="line">switch(config-if)#switchport trunk allowed vlan 1,2 ；设置允许的vlan</span><br><span class="line"></span><br><span class="line">switch(config-if)#switchport trunk encap dot1q    ；设置vlan 中继</span><br><span class="line"></span><br><span class="line">switch(config)#vtp domain &lt;name&gt;                    ；设置发vtp域名</span><br><span class="line"></span><br><span class="line">switch(config)#vtp password &lt;word&gt;                ；设置发vtp密码</span><br><span class="line"></span><br><span class="line">switch(config)#vtp mode server                   ；设置发vtp模式</span><br><span class="line"></span><br><span class="line">switch(config)#vtp mode client                   ；设置发vtp模式</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">交换机设置IP地址：</span><br><span class="line"></span><br><span class="line">switch(config)#interface vlan 1                    ；进入vlan 1</span><br><span class="line"></span><br><span class="line">switch(config-if)#ip address &lt;IP&gt; &lt;mask&gt;          ；设置IP地址</span><br><span class="line"></span><br><span class="line">switch(config)#ip default-gateway &lt;IP&gt;              ；设置默认网关</span><br><span class="line"></span><br><span class="line">switch#dir flash:                               ；查看闪存</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">交换机显示命令：</span><br><span class="line"></span><br><span class="line">switch#write                                     ；保存配置信息</span><br><span class="line"></span><br><span class="line">switch#show vtp                                  ；查看vtp配置信息</span><br><span class="line"></span><br><span class="line">switch#show run                                  ；查看当前配置信息</span><br><span class="line"></span><br><span class="line">switch#show vlan                                  ；查看vlan配置信息</span><br><span class="line"></span><br><span class="line">switch#show interface                            ；查看端口信息</span><br><span class="line"></span><br><span class="line">switch#show int f0&#x2F;0                                ；查看指定端口信息</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">3. 路由器支持的命令：</span><br><span class="line"></span><br><span class="line">路由器显示命令：</span><br><span class="line"></span><br><span class="line">router#show run                                  ；显示配置信息</span><br><span class="line"></span><br><span class="line">router#show interface                            ；显示接口信息</span><br><span class="line"></span><br><span class="line">router#show ip route                                ；显示路由信息</span><br><span class="line"></span><br><span class="line">router#show cdp nei                                ；显示邻居信息</span><br><span class="line"></span><br><span class="line">router#reload              　   　                ；重新起动</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">路由器口令设置：</span><br><span class="line"></span><br><span class="line">router&gt;enable                                      ；进入特权模式</span><br><span class="line"></span><br><span class="line">router#config terminal                            ；进入全局配置模式</span><br><span class="line"></span><br><span class="line">router(config)#hostname &lt;hostname&gt;                ；设置交换机的主机名</span><br><span class="line"></span><br><span class="line">router(config)#enable secret xxx                    ；设置特权加密口令</span><br><span class="line"></span><br><span class="line">router(config)#enable password xxb                ；设置特权非密口令</span><br><span class="line"></span><br><span class="line">router(config)#line console 0                   ；进入控制台口</span><br><span class="line"></span><br><span class="line">router(config-line)#line vty 0 4                    ；进入虚拟终端</span><br><span class="line"></span><br><span class="line">router(config-line)#login                          ；要求口令验证</span><br><span class="line"></span><br><span class="line">router(config-line)#password xx                    ；设置登录口令xx</span><br><span class="line"></span><br><span class="line">router(config)#(Ctrl+z)                         ； 返回特权模式</span><br><span class="line"></span><br><span class="line">router#exit                                     ；返回命令</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">路由器配置：</span><br><span class="line"></span><br><span class="line">router(config)#int s0&#x2F;0                         ；进入Serail接口</span><br><span class="line"></span><br><span class="line">router(config-if)#no shutdown                   ；激活当前接口</span><br><span class="line"></span><br><span class="line">router(config-if)#clock rate 64000                ；设置时钟频率</span><br><span class="line"></span><br><span class="line">router(config-if)#ip address &lt;ip&gt; &lt;netmask&gt;        ；设置IP地址</span><br><span class="line"></span><br><span class="line">router(config-if)#ip address &lt;ip&gt; &lt;netmask&gt; second   ；设置第二个IP</span><br><span class="line"></span><br><span class="line">router(config-if)#int f0&#x2F;0.1                      ；进入子接口</span><br><span class="line"></span><br><span class="line">router(config-subif.1)#ip address &lt;ip&gt; &lt;netmask&gt; ；设置子接口IP</span><br><span class="line"></span><br><span class="line">router(config-subif.1)#encapsulation dot1q &lt;n&gt;    ；绑定vlan中继协议</span><br><span class="line"></span><br><span class="line">router(config)#config-register 0x2142              ；跳过配置文件</span><br><span class="line"></span><br><span class="line">router(config)#config-register 0x2102              ；正常使用配置文件</span><br><span class="line"></span><br><span class="line">router#reload                                      ；重新引导</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">路由器文件操作：</span><br><span class="line"></span><br><span class="line">router#copy running-config startup-config       ；保存配置</span><br><span class="line"></span><br><span class="line">router#copy running-config tftp                    ；保存配置到tftp</span><br><span class="line"></span><br><span class="line">router#copy startup-config tftp                    ；开机配置存到tftp</span><br><span class="line"></span><br><span class="line">router#copy tftp flash:                         ；下传文件到flash</span><br><span class="line"></span><br><span class="line">router#copy tftp startup-config                    ；下载配置文件</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">ROM状态：</span><br><span class="line"></span><br><span class="line">Ctrl+Break                                        ；进入ROM监控状态</span><br><span class="line"></span><br><span class="line">rommon&gt;confreg 0x2142                            ；跳过配置文件</span><br><span class="line"></span><br><span class="line">rommon&gt;confreg 0x2102                            ；恢复配置文件</span><br><span class="line"></span><br><span class="line">rommon&gt;reset                                     ；重新引导</span><br><span class="line"></span><br><span class="line">rommon&gt;copy xmodem:&lt;sname&gt; flash:&lt;dname&gt;          ；从console传输文件</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">rommon&gt;IP_ADDRESS&#x3D;10.65.1.2                      ；设置路由器IP</span><br><span class="line"></span><br><span class="line">rommon&gt;IP_SUBNET_MASK&#x3D;255.255.0.0                ；设置路由器掩码</span><br><span class="line"></span><br><span class="line">rommon&gt;TFTP_SERVER&#x3D;10.65.1.1                      ；指定TFTP服务器IP</span><br><span class="line"></span><br><span class="line">rommon&gt;TFTP_FILE&#x3D;c2600.bin                          ；指定下载的文件</span><br><span class="line"></span><br><span class="line">rommon&gt;tftpdnld                                  ；从tftp下载</span><br><span class="line"></span><br><span class="line">rommon&gt;dir flash:                               ；查看闪存内容</span><br><span class="line"></span><br><span class="line">rommon&gt;boot                                     ；引导IOS</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">静态路由：</span><br><span class="line"></span><br><span class="line">ip route &lt;ip-address&gt; &lt;subnet-mask&gt; &lt;gateway&gt;    ；命令格式</span><br><span class="line"></span><br><span class="line">router(config)#ip route 2.0.0.0 255.0.0.0 1.1.1.2   ；静态路由举例</span><br><span class="line"></span><br><span class="line">router(config)#ip route 0.0.0.0 0.0.0.0 1.1.1.2 ；默认路由举例</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">动态路由：</span><br><span class="line"></span><br><span class="line">router(config)#ip routing                          ；启动路由转发</span><br><span class="line"></span><br><span class="line">router(config)#router rip                          ；启动RIP路由协议。</span><br><span class="line"></span><br><span class="line">router(config-router)#network &lt;netid&gt;              ；设置发布路由</span><br><span class="line"></span><br><span class="line">router(config-router)#negihbor &lt;ip&gt;             ；点对点帧中继用。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">帧中继命令：</span><br><span class="line"></span><br><span class="line">router(config)#frame-relay switching             ；使能帧中继交换</span><br><span class="line"></span><br><span class="line">router(config-s0)#encapsulation frame-relay        ；使能帧中继</span><br><span class="line"></span><br><span class="line">router(config-s0)#fram-relay lmi-type cisco        ；设置管理类型</span><br><span class="line"></span><br><span class="line">router(config-s0)#frame-relay intf-type DCE        ；设置为DCE</span><br><span class="line"></span><br><span class="line">router(config-s0)#frame-relay dlci 16              ；</span><br><span class="line"></span><br><span class="line">router(config-s0)#frame-relay local-dlci 20        ；设置虚电路号</span><br><span class="line"></span><br><span class="line">router(config-s0)#frame-relay interface-dlci 16 ；</span><br><span class="line"></span><br><span class="line">router(config)#log-adjacency-changes             ；记录邻接变化</span><br><span class="line"></span><br><span class="line">router(config)#int s0&#x2F;0.1 point-to-point          ；设置子接口点对点</span><br><span class="line"></span><br><span class="line">router#show frame pvc                            ；显示永久虚电路</span><br><span class="line"></span><br><span class="line">router#show frame map                            ；显示映射</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">基本访问控制列表：</span><br><span class="line"></span><br><span class="line">router(config)#access-list &lt;number&gt; permit|deny &lt;source_ip&gt; &lt;wild|any&gt;</span><br><span class="line"></span><br><span class="line">router(config)#interface &lt;interface&gt;             ；default:deny any</span><br><span class="line"></span><br><span class="line">router(config-if)#ip access-group &lt;number&gt; in|out   ；defaultut</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">例1：</span><br><span class="line"></span><br><span class="line">router(config)#access-list 1 deny host 10.65.1.1</span><br><span class="line"></span><br><span class="line">router(config)#access-list 1 permit any</span><br><span class="line"></span><br><span class="line">router(config)#int f0&#x2F;0</span><br><span class="line"></span><br><span class="line">router(config-if)#ip access-group 4 in</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">例2：</span><br><span class="line"></span><br><span class="line">router(config)#access-list 4 permit 10.8.1.1</span><br><span class="line"></span><br><span class="line">router(config)#access-list 4 deny 10.8.1.0 0.0.0.255</span><br><span class="line"></span><br><span class="line">router(config)#access-list 4 permit 10.8.0.0 0.0.255.255</span><br><span class="line"></span><br><span class="line">router(config)#access-list 4 deny 10.0.0.0 0.255.255.255</span><br><span class="line"></span><br><span class="line">router(config)#access-list 4 permit any</span><br><span class="line"></span><br><span class="line">router(config)#int f0&#x2F;1</span><br><span class="line"></span><br><span class="line">router(config-if)#ip access-group 4 in</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">扩展访问控制列表：</span><br><span class="line"></span><br><span class="line">access-list &lt;number&gt; permit|deny icmp &lt;S_IP wild&gt; &lt;D_IP wild&gt;[type]</span><br><span class="line"></span><br><span class="line">access-list &lt;number&gt; permit|deny tcp &lt;S_IP wild&gt; &lt;D_IP wild&gt;[port]</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">例1：</span><br><span class="line"></span><br><span class="line">router(config)#access-list 101 deny icmp any 10.64.0.2 0.0.0.0 echo</span><br><span class="line"></span><br><span class="line">router(config)#access-list 101 permit ip any any</span><br><span class="line"></span><br><span class="line">router(config)#int s0&#x2F;0</span><br><span class="line"></span><br><span class="line">router(config-if)#ip access-group 101 in</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">例2：</span><br><span class="line"></span><br><span class="line">router(config)#access-list 102 deny tcp any 10.65.0.2 0.0.0.0 eq 80</span><br><span class="line"></span><br><span class="line">router(config)#access-list 102 permit ip any any</span><br><span class="line"></span><br><span class="line">router(config)#interface s0&#x2F;1</span><br><span class="line"></span><br><span class="line">router(config-if)#ip access-group 102 out</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">删除访问控制例表:</span><br><span class="line"></span><br><span class="line">router(config)#no access-list 102</span><br><span class="line"></span><br><span class="line">router(config-if)#no ip access-group 101 in</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">路由器的nat配置</span><br><span class="line"></span><br><span class="line">Router(config-if)#ip nat inside              ；当前接口指定为内部接口</span><br><span class="line"></span><br><span class="line">Router(config-if)#ip nat outside              ；当前接口指定为外部接口</span><br><span class="line"></span><br><span class="line">Router(config)#ip nat inside source static [p] &lt;私有IP&gt;&lt;公网IP&gt; [port]</span><br><span class="line"></span><br><span class="line">Router(config)#ip nat inside source static 10.65.1.2 60.1.1.1</span><br><span class="line"></span><br><span class="line">Router(config)#ip nat inside source static tcp 10.65.1.3 80 60.1.1.1 80</span><br><span class="line"></span><br><span class="line">Router(config)#ip nat pool p1 60.1.1.1 60.1.1.20 255.255.255.0</span><br><span class="line"></span><br><span class="line">Router(config)#ip nat inside source list 1 pool p1</span><br><span class="line"></span><br><span class="line">Router(config)#ip nat inside destination list 2 pool p2</span><br><span class="line"></span><br><span class="line">Router(config)#ip nat inside source list 2 interface s0&#x2F;0 overload</span><br><span class="line"></span><br><span class="line">Router(config)#ip nat pool p2 10.65.1.2 10.65.1.4 255.255.255.0 type rotary</span><br><span class="line"></span><br><span class="line">Router#show ip nat translation</span><br><span class="line"></span><br><span class="line">rotary 参数是轮流的意思，地址池中的IP轮流与NAT分配的地址匹配。</span><br><span class="line"></span><br><span class="line">overload参数用于PAT 将内部IP映射到一个公网IP不同的端口上。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">外部网关协议配置</span><br><span class="line"></span><br><span class="line">routerA(config)#router bgp 100</span><br><span class="line"></span><br><span class="line">routerA(config-router)#network 19.0.0.0</span><br><span class="line"></span><br><span class="line">routerA(config-router)#neighbor 8.1.1.2 remote-as 200</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">配置PPP验证：</span><br><span class="line"></span><br><span class="line">RouterA(config)#username &lt;RouterB&gt; password &lt;word&gt;</span><br><span class="line"></span><br><span class="line">RouterA(config)#int s0</span><br><span class="line"></span><br><span class="line">RouterA(config-if)#ppp authentication &#123;chap|pap&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">4．PIX防火墙命令</span><br><span class="line"></span><br><span class="line">Pix525(config)#nameif ethernet0 outside security0    ；命名接口和级别</span><br><span class="line"></span><br><span class="line">Pix525(config)#interface ethernet0 auto             ；设置接口方式</span><br><span class="line"></span><br><span class="line">Pix525(config)#interface ethernet1 100full              ；设置接口方式</span><br><span class="line"></span><br><span class="line">Pix525(config)#interface ethernet1 100full shutdown</span><br><span class="line"></span><br><span class="line">Pix525(config)#ip address inside 192.168.0.1 255.255.255.0</span><br><span class="line"></span><br><span class="line">Pix525(config)#ip address outside 133.0.0.1 255.255.255.252</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Pix525(config)#global (if_name) natid ip-ip          ；定义公网IP区间</span><br><span class="line"></span><br><span class="line">Pix525(config)#global (outside) 1 7.0.0.1-7.0.0.15    ；例句</span><br><span class="line"></span><br><span class="line">Pix525(config)#global (outside) 1 133.0.0.1          ；例句</span><br><span class="line"></span><br><span class="line">Pix525(config)#no global (outside) 1 133.0.0.1       ；去掉设置</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Pix525(config)#nat (if_name) nat_id local_ip [netmark]</span><br><span class="line"></span><br><span class="line">Pix525(config)#nat (inside) 1 0 0</span><br><span class="line"></span><br><span class="line">内网所有主机(0代表0.0.0.0)可以访问global 1指定的外网。</span><br><span class="line"></span><br><span class="line">Pix525(config)#nat (inside) 1 172.16.5.0 255.255.0.0</span><br><span class="line"></span><br><span class="line">内网172.16.5.0&#x2F;16网段的主机可以访问global 1指定的外网。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Pix525(config)#route if_name 0 0 gateway_ip [metric]        ；命令格式</span><br><span class="line"></span><br><span class="line">Pix525(config)#route outside 0 0 133.0.0.1 1             ；例句</span><br><span class="line"></span><br><span class="line">Pix525(config)#route inside 10.1.0.0 255.255.0.0 10.8.0.1 1 ；例句</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Pix525(config)#static (inside， outside) 133.0.0.1 192.168.0.8</span><br><span class="line"></span><br><span class="line">表示内部ip地址192.168.0.8，访问外部时被翻译成133.0.0.1全局地址。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Pix525(config)#static (dmz， outside) 133.0.0.1 172.16.0.8</span><br><span class="line"></span><br><span class="line">中间区域ip地址172.16.0.8，访问外部时被翻译成133.0.0.1全局地址。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">1. switch配置命令</span><br><span class="line"></span><br><span class="line">(1)模式转换命令</span><br><span class="line"></span><br><span class="line">用户模式----特权模式,使用命令&quot;enable&quot;</span><br><span class="line"></span><br><span class="line">特权模式----全局配置模式,使用命令&quot;config t&quot;</span><br><span class="line"></span><br><span class="line">全局配置模式----接口模式,使用命令&quot;interface+接口类型+接口号&quot;</span><br><span class="line"></span><br><span class="line">全局配置模式----线控模式,使用命令&quot;line+接口类型+接口号&quot;</span><br><span class="line"></span><br><span class="line">注:</span><br><span class="line"></span><br><span class="line">用户模式:查看初始化的信息.</span><br><span class="line"></span><br><span class="line">特权模式:查看所有信息、调试、保存配置信息</span><br><span class="line"></span><br><span class="line">全局模式：配置所有信息、针对整个路由器或交换机的所有接口</span><br><span class="line"></span><br><span class="line">接口模式：针对某一个接口的配置</span><br><span class="line"></span><br><span class="line">线控模式：对路由器进行控制的接口配置</span><br><span class="line"></span><br><span class="line">（2）配置命令</span><br><span class="line"></span><br><span class="line">show running config 显示所有的配置</span><br><span class="line"></span><br><span class="line">show versin 显示版本号和寄存器值</span><br><span class="line"></span><br><span class="line">shut down 关闭接口</span><br><span class="line"></span><br><span class="line">no shutdown 打开接口</span><br><span class="line"></span><br><span class="line">ip add +ip地址 配置IP地址</span><br><span class="line"></span><br><span class="line">secondary+IP地址 为接口配置第二个IP地址</span><br><span class="line"></span><br><span class="line">show interface+接口类型+接口号 查看接口管理性</span><br><span class="line"></span><br><span class="line">show controllers interface 查看接口是否有DCE电缆</span><br><span class="line"></span><br><span class="line">show history 查看历史记录</span><br><span class="line"></span><br><span class="line">show terminal 查看终端记录大小</span><br><span class="line"></span><br><span class="line">hostname+主机名 配置路由器或交换机的标识</span><br><span class="line"></span><br><span class="line">config memory 修改保存在NVRAM中的启动配置</span><br><span class="line"></span><br><span class="line">exec timeout 0 0 设置控制台会话超时为0</span><br><span class="line"></span><br><span class="line">service password-encryptin 手工加密所有密码</span><br><span class="line"></span><br><span class="line">enable password +密码 配置明文密码</span><br><span class="line"></span><br><span class="line">ena sec +密码 配置密文密码</span><br><span class="line"></span><br><span class="line">line vty 0 4&#x2F;15 进入telnet接口</span><br><span class="line"></span><br><span class="line">password +密码 配置telnet密码</span><br><span class="line"></span><br><span class="line">line aux 0 进入AUX接口</span><br><span class="line"></span><br><span class="line">password +密码 配置密码</span><br><span class="line"></span><br><span class="line">line con 0 进入CON接口</span><br><span class="line"></span><br><span class="line">password +密码 配置密码</span><br><span class="line"></span><br><span class="line">bandwidth+数字 配置带宽</span><br><span class="line"></span><br><span class="line">no ip address 删除已配置的IP地址</span><br><span class="line"></span><br><span class="line">show startup config 查看NVRAM中的配置信息</span><br><span class="line"></span><br><span class="line">copy run-config startup config 保存信息到NVRAM</span><br><span class="line"></span><br><span class="line">write 保存信息到NVRAM</span><br><span class="line"></span><br><span class="line">erase startup-config 清除NVRAM中的配置信息</span><br><span class="line"></span><br><span class="line">show ip interface brief 查看接口的谪要信息</span><br><span class="line"></span><br><span class="line">banner motd # +信息 + # 配置路由器或交换机的描素信息</span><br><span class="line"></span><br><span class="line">description+信息 配置接口听描素信息</span><br><span class="line"></span><br><span class="line">vlan database 进入VLAN数据库模式</span><br><span class="line"></span><br><span class="line">vlan +vlan号+ 名称 创建VLAN</span><br><span class="line"></span><br><span class="line">switchport access vlan +vlan号 为VLAN为配接口</span><br><span class="line"></span><br><span class="line">interface vlan +vlan号 进入VLAN接口模式</span><br><span class="line"></span><br><span class="line">ip add +ip地址 为VLAN配置管理IP地址</span><br><span class="line"></span><br><span class="line">vtp+service&#x2F;tracsparent&#x2F;client 配置SW的VTP工作模式</span><br><span class="line"></span><br><span class="line">vtp +domain+域名 配置SW的VTP域名</span><br><span class="line"></span><br><span class="line">vtp +password +密码 配置SW的密码</span><br><span class="line"></span><br><span class="line">switchport mode trunk 启用中继</span><br><span class="line"></span><br><span class="line">no vlan +vlan号 删除VLAN</span><br><span class="line"></span><br><span class="line">show spamming-tree vlan +vlan号 查看VLA怕生成树议</span><br><span class="line"></span><br><span class="line">2. 路由器配置命令</span><br><span class="line"></span><br><span class="line">ip route+非直连网段+子网掩码+下一跳地址 配置静态&#x2F;默认路由</span><br><span class="line"></span><br><span class="line">show ip route 查看路由表</span><br><span class="line"></span><br><span class="line">show protocols 显示出所有的被动路由协议和接口上哪些协议被设置</span><br><span class="line"></span><br><span class="line">show ip protocols 显示了被配置在路由器上的路由选择协议,同时给出了在路由选择协议中使用</span><br><span class="line"></span><br><span class="line">的定时器</span><br><span class="line"></span><br><span class="line">                                   等信息</span><br><span class="line"></span><br><span class="line">router rip 激活RIP协议</span><br><span class="line"></span><br><span class="line">network +直连网段 发布直连网段</span><br><span class="line"></span><br><span class="line">interface lookback 0 激活逻辑接口</span><br><span class="line"></span><br><span class="line">passive-interface +接口类型+接口号 配置接口为被动模式</span><br><span class="line"></span><br><span class="line">debug ip +协议 动态查看路由更新信息</span><br><span class="line"></span><br><span class="line">undebug all 关闭所有DEBUG信息</span><br><span class="line"></span><br><span class="line">router eigrp +as号 激活EIGRP路由协议</span><br><span class="line"></span><br><span class="line">network +网段+子网掩码 发布直连网段</span><br><span class="line"></span><br><span class="line">show ip eigrp neighbors 查看邻居表</span><br><span class="line"></span><br><span class="line">show ip eigrp topology 查看拓扑表</span><br><span class="line"></span><br><span class="line">show ip eigrp traffic 查看发送包数量</span><br><span class="line"></span><br><span class="line">router ospf +process-ID 激活OSPF协议</span><br><span class="line"></span><br><span class="line">network+直连网段+area+区域号 发布直连网段</span><br><span class="line"></span><br><span class="line">show ip ospf 显示OSPF的进程号和ROUTER-ID</span><br><span class="line"></span><br><span class="line">encapsulation+封装格式 更改封装格式</span><br><span class="line"></span><br><span class="line">no ip admain-lookup 关闭路由器的域名查找</span><br><span class="line"></span><br><span class="line">ip routing 在三层交换机上启用路由功能</span><br><span class="line"></span><br><span class="line">show user 查看SW的在线用户</span><br><span class="line"></span><br><span class="line">clear line +线路号 清除线路</span><br><span class="line"></span><br><span class="line">3. 三层交换机配置命令</span><br><span class="line"></span><br><span class="line">配置一组二层端口</span><br><span class="line"></span><br><span class="line">configure terminal 进入配置状态</span><br><span class="line"></span><br><span class="line">nterface range &#123;port-range&#125; 进入组配置状态</span><br><span class="line"></span><br><span class="line">配置三层端口</span><br><span class="line"></span><br><span class="line">configure terminal 进入配置状态</span><br><span class="line"></span><br><span class="line">interface &#123;&#123;fastethernet | gigabitethernet&#125; interface-id&#125; | &#123;vlan vlan-id&#125; | &#123;port-</span><br><span class="line"></span><br><span class="line">channel port-channel-number&#125; 进入端口配置状态</span><br><span class="line"></span><br><span class="line">no switchport 把物理端口变成三层口</span><br><span class="line"></span><br><span class="line">ip address ip_address subnet_mask 配置IP地址和掩码</span><br><span class="line"></span><br><span class="line">no shutdown 激活端口</span><br><span class="line"></span><br><span class="line">     例：</span><br><span class="line"></span><br><span class="line">     Switch(config)# interface gigabitethernet0&#x2F;2</span><br><span class="line"></span><br><span class="line">     Switch(config-if)# no switchport</span><br><span class="line"></span><br><span class="line">     Switch(config-if)# ip address 192.20.135.21 255.255.255.0</span><br><span class="line"></span><br><span class="line">     Switch(config-if)# no shutdown</span><br><span class="line"></span><br><span class="line">配置VLAN</span><br><span class="line"></span><br><span class="line">configure terminal 进入配置状态</span><br><span class="line"></span><br><span class="line">vlan vlan-id 输入一个VLAN号, 然后进入vlan配态，可以输入一个新的VLAN号或旧的来进行修改</span><br><span class="line"></span><br><span class="line">。</span><br><span class="line"></span><br><span class="line">name vlan-name 可选)输入一个VLAN名，如果没有配置VLAN名，缺省的名字是VLAN号前面用0填满</span><br><span class="line"></span><br><span class="line">的4位数，如VLAN0004是VLAN4的缺省名字</span><br><span class="line"></span><br><span class="line">mtu mtu-size (可选) 改变MTU大小</span><br><span class="line"></span><br><span class="line">     例</span><br><span class="line"></span><br><span class="line">     Switch# configure terminal</span><br><span class="line"></span><br><span class="line">     Switch(config)# vlan 20</span><br><span class="line"></span><br><span class="line">     Switch(config-vlan)# name test20</span><br><span class="line"></span><br><span class="line">     Switch(config-vlan)# end</span><br><span class="line"></span><br><span class="line">     或</span><br><span class="line"></span><br><span class="line">     Switch# vlan database</span><br><span class="line"></span><br><span class="line">     Switch(vlan)# vlan 20 name test20</span><br><span class="line"></span><br><span class="line">     Switch(vlan)# exit</span><br><span class="line"></span><br><span class="line">将端口分配给一个VLAN</span><br><span class="line"></span><br><span class="line">configure terminal 进入配置状态</span><br><span class="line"></span><br><span class="line">interface interface-id 进入要分配的端口</span><br><span class="line"></span><br><span class="line">switchport mode access 定义二层口</span><br><span class="line"></span><br><span class="line">switchport access vlan vlan-id 把端口分配给某一VLAN</span><br><span class="line"></span><br><span class="line">     例</span><br><span class="line"></span><br><span class="line">     Switch# configure terminal</span><br><span class="line"></span><br><span class="line">     Enter configuration commands, one per line. End with CNTL&#x2F;Z.</span><br><span class="line"></span><br><span class="line">     Switch(config)# interface fastethernet0&#x2F;1</span><br><span class="line"></span><br><span class="line">     Switch(config-if)# switchport mode access</span><br><span class="line"></span><br><span class="line">     Switch(config-if)# switchport access vlan 2</span><br><span class="line"></span><br><span class="line">     Switch(config-if)# end</span><br><span class="line"></span><br><span class="line">     Switch#</span><br><span class="line"></span><br><span class="line">配置VLAN trunk</span><br><span class="line"></span><br><span class="line">configure terminal 进入配置状态</span><br><span class="line"></span><br><span class="line">interface interface-Id 进入端口配置状态</span><br><span class="line"></span><br><span class="line">switchport trunk encapsulation &#123;isl | dot1q | negotiate&#125;配置trunk封装ISL 或 802.1Q 或</span><br><span class="line"></span><br><span class="line">自动协商</span><br><span class="line"></span><br><span class="line">switchport mode &#123;dynamic &#123;auto | desirable&#125; | trunk&#125; 配置二层trunk模式。</span><br><span class="line"></span><br><span class="line">dynamic auto—自动协商是否成为trunk</span><br><span class="line"></span><br><span class="line">dynamic desirable—把端口设置为trunk如果对方端口是trunk, desirable, 配置Native VLAN</span><br><span class="line"></span><br><span class="line">（802.1q）</span><br><span class="line"></span><br><span class="line">或自动模式，trunk—设置端口为强制的trunk方式，而不理会对方端口是否为trunk</span><br><span class="line"></span><br><span class="line">switchport access vlan vlan-id 可选) 指定一个缺省VLAN, 如果此端口不再是trunk</span><br><span class="line"></span><br><span class="line">switchport trunk native vlan vlan-id 指定802.1Q native VLAN号</span><br><span class="line"></span><br><span class="line">     例：</span><br><span class="line"></span><br><span class="line">     Switch# configure terminal</span><br><span class="line"></span><br><span class="line">     Enter configuration commands, one per line. End with CNTL&#x2F;Z.</span><br><span class="line"></span><br><span class="line">     Switch(config)# interface fastethernet0&#x2F;4</span><br><span class="line"></span><br><span class="line">     Switch(config-if)# switchport mode trunk</span><br><span class="line"></span><br><span class="line">     Switch(config-if)# switchport trunk encapsulation dot1q</span><br><span class="line"></span><br><span class="line">     Switch(config-if)# end</span><br><span class="line"></span><br><span class="line">定义TRUNK允许的VLAN</span><br><span class="line"></span><br><span class="line">configure terminal子 进入配置状态</span><br><span class="line"></span><br><span class="line">interface interface-id 进入端口配置</span><br><span class="line"></span><br><span class="line">switchport mode trunk 配置二层口为trunk</span><br><span class="line"></span><br><span class="line">switchport trunk allowed vlan &#123;add | all | except | remove&#125; vlan-list可选) 配置trunk允</span><br><span class="line"></span><br><span class="line">许的VLAN.使用add, all, except, remove关健字</span><br><span class="line"></span><br><span class="line">no switchport trunk allowed vlan 允许所有VLAN通过</span><br><span class="line"></span><br><span class="line">     例</span><br><span class="line"></span><br><span class="line">     Switch(config)# interface fastethernet0&#x2F;1</span><br><span class="line"></span><br><span class="line">     Switch(config-if)# switchport trunk allowed vlan remove 2</span><br><span class="line"></span><br><span class="line">     Switch(config-if)# end</span><br><span class="line"></span><br><span class="line">配置Native VLAN（802.1q）</span><br><span class="line"></span><br><span class="line">configure terminal 进入配置状态</span><br><span class="line"></span><br><span class="line">interface interface-id 进入配置成802.1qtrunk的端口</span><br><span class="line"></span><br><span class="line">switchport trunk native vlan vlan-Id 配置native VLAN号</span><br><span class="line"></span><br><span class="line">no switchport trunk native vlan 端口配置命令回到缺省的状态</span><br><span class="line"></span><br><span class="line">配置基于端口权值的负载均衡</span><br><span class="line"></span><br><span class="line">configure terminal 进入Switch 1配置状态</span><br><span class="line"></span><br><span class="line">vtp domain domain-name 配置VTP域</span><br><span class="line"></span><br><span class="line">vtp mode server 将Switch 1配置成VTP server.</span><br><span class="line"></span><br><span class="line">show vtp status 验证VTP的配置</span><br><span class="line"></span><br><span class="line">show vlan 验证VLAN</span><br><span class="line"></span><br><span class="line">configure terminal 进入配置状态</span><br><span class="line"></span><br><span class="line">interface fastethernet 0&#x2F;1 进入F0&#x2F;1端口</span><br><span class="line"></span><br><span class="line">switchport trunk encapsulation &#123;isl | dot1q | negotiate&#125;配置trunk封装</span><br><span class="line"></span><br><span class="line">switchport mode trunk 配置成trunk</span><br><span class="line"></span><br><span class="line">show interfaces fastethernet0&#x2F;1 switchport 验证VLAN配置</span><br><span class="line"></span><br><span class="line">按以上步骤对想要负载均衡的接口进行配置</span><br><span class="line"></span><br><span class="line">在另一个交换机上进行此配置</span><br><span class="line"></span><br><span class="line">show vlan 当trunk已经起来，在switch2上验证已经学到相的vlan配置</span><br><span class="line"></span><br><span class="line">configure terminal 在Switch 1上进入配置状态</span><br><span class="line"></span><br><span class="line">interface fastethernet0&#x2F;1 进入要配置的端口</span><br><span class="line"></span><br><span class="line">spanning-tree vlan 8 port-priority 10 将端口权值10赋与VLAN 8.</span><br><span class="line"></span><br><span class="line">spanning-tree vlan 9 port-priority 10 将端口权值10赋与VLAN 9.</span><br><span class="line"></span><br><span class="line">spanning-tree vlan 10 port-priority 10 将端口权值10赋与VLAN 10.</span><br><span class="line"></span><br><span class="line">interface fastethernet0&#x2F;2 进入F0&#x2F;2</span><br><span class="line"></span><br><span class="line">spanning-tree vlan 3 port-priority 10 将端口权值10赋与VLAN 3.</span><br><span class="line"></span><br><span class="line">spanning-tree vlan 4 port-priority 10 将端口权值10赋与VLAN 4</span><br><span class="line"></span><br><span class="line">spanning-tree vlan 5 port-priority 10 将端口权值10赋与VLAN 5</span><br><span class="line"></span><br><span class="line">spanning-tree vlan 6 port-priority 10 将端口权值10赋与VLAN 10</span><br><span class="line"></span><br><span class="line">end 退出</span><br><span class="line"></span><br><span class="line">show running-config 验证配置</span><br><span class="line"></span><br><span class="line">copy running-config startup-config 保存配置</span><br><span class="line"></span><br><span class="line">配置STP路径值的负载均衡</span><br><span class="line"></span><br><span class="line">Trunk1走VLAN8－10，Trunk2走VLAN2－4</span><br><span class="line"></span><br><span class="line">configure terminal 进入 Switch 1配置状态</span><br><span class="line"></span><br><span class="line">interface fastethernet 0&#x2F;1 进入F0&#x2F;1</span><br><span class="line"></span><br><span class="line">switchport trunk encapsulation &#123;isl | dot1q | negotiate&#125;配置封装</span><br><span class="line"></span><br><span class="line">switchport mode trunk 配置Trunk,缺省是ISL封装</span><br><span class="line"></span><br><span class="line">exit 退回</span><br><span class="line"></span><br><span class="line">在F0&#x2F;2口上重复2－4步骤</span><br><span class="line"></span><br><span class="line">exit 退回</span><br><span class="line"></span><br><span class="line">show running-config 验证配置</span><br><span class="line"></span><br><span class="line">show vlan验证switch1 已经学到Vlan</span><br><span class="line"></span><br><span class="line">configure terminal 进入配置状态</span><br><span class="line"></span><br><span class="line">interface fastethernet 0&#x2F;1 进入F0&#x2F;1</span><br><span class="line"></span><br><span class="line">spanning-tree vlan 2 cost 30 设置Vlan2生成树路径值为30</span><br><span class="line"></span><br><span class="line">spanning-tree vlan 3 cost 30 设置Vlan3生成树路径值为30</span><br><span class="line"></span><br><span class="line">spanning-tree vlan 4 cost 30 设置Vlan4生成树路径值为30</span><br><span class="line"></span><br><span class="line">end 退出</span><br><span class="line"></span><br><span class="line">在switch1的F0&#x2F;2上重复9－11步骤设置VLAN8,9，10生成树路径值为30</span><br><span class="line"></span><br><span class="line">end 退出</span><br><span class="line"></span><br><span class="line">show running-config 验证配置</span><br><span class="line"></span><br><span class="line">copy running-config startup-config 保存配置</span><br><span class="line"></span><br><span class="line">补充:CISCO命令集——路由选择协议及排障</span><br><span class="line"></span><br><span class="line">     *ip route命令</span><br><span class="line"></span><br><span class="line">Router(config)# ip route &lt;目录网络或子网号&gt; [子网掩码] &lt;下一路由器IP地址 | 从本地出口</span><br><span class="line"></span><br><span class="line">的地址&gt; [管理距离0~255，默认为1]</span><br><span class="line"></span><br><span class="line">     （注：静态地址配置）</span><br><span class="line"></span><br><span class="line">     *ip default-network命令</span><br><span class="line"></span><br><span class="line">Router(config)# ip default-network &lt;目标网络号&gt;</span><br><span class="line"></span><br><span class="line">     (注：配合路由协使用，用其中的一个动态路由号作默认路由配置)</span><br><span class="line"></span><br><span class="line">Router(config)# ip route 0.0.0.0 0.0.0.0 &lt;下一路由器IP地址 | 从本地出口的地址&gt;</span><br><span class="line"></span><br><span class="line">     (注：只有一个公网地址时，在出口路由器上的配置)</span><br><span class="line"></span><br><span class="line">     *内部路由选择协议</span><br><span class="line"></span><br><span class="line">     *使用router和network命令</span><br><span class="line"></span><br><span class="line">Router(config)# router &lt;路由协议rip | igrp | eigrp | ospf | is-is等&gt; [自主系统号]</span><br><span class="line"></span><br><span class="line">Router(config-router)# network &lt;直接相连的要用此路由协议的网络号&gt;</span><br><span class="line"></span><br><span class="line">Router(config-router)# network &lt;直接相连的要用此路由协议的网络号&gt;</span><br><span class="line"></span><br><span class="line">     *路由信息协议RIP</span><br><span class="line"></span><br><span class="line">Router(config)# router rip</span><br><span class="line"></span><br><span class="line">Router(config-router)# network &lt;直接相连的要用rip协议的有类别网络号&gt;</span><br><span class="line"></span><br><span class="line">Router# show ip protocols</span><br><span class="line"></span><br><span class="line">Router# show ip route</span><br><span class="line"></span><br><span class="line">Router# debug ip rip</span><br><span class="line"></span><br><span class="line">     *内部网关路由协议IGRP</span><br><span class="line"></span><br><span class="line">Router(config)# router igrp &lt;自主系统号&gt;</span><br><span class="line"></span><br><span class="line">Router(config-router)# network &lt;直接相连的要用igrp协议的有类别网络号&gt;</span><br><span class="line"></span><br><span class="line">Router# show ip interface</span><br><span class="line"></span><br><span class="line">Router# show ip protocols</span><br><span class="line"></span><br><span class="line">Router# show ip route</span><br><span class="line"></span><br><span class="line">Router# debug ip rip</span><br><span class="line"></span><br><span class="line">     *排除网络故障</span><br><span class="line"></span><br><span class="line">     排除网络故障的一个总体模型</span><br><span class="line"></span><br><span class="line">Router# ping &lt;有故障的主机 | 有故障的IP地址&gt;</span><br><span class="line"></span><br><span class="line">Router# show ip route</span><br><span class="line"></span><br><span class="line">Router# show interface &lt;有故障的接口&gt;</span><br><span class="line"></span><br><span class="line">Router# show run</span><br><span class="line"></span><br><span class="line">     *IP的故故障排除</span><br><span class="line"></span><br><span class="line">     检查可用的路由</span><br><span class="line"></span><br><span class="line">Router# show ip route &lt;有故障的IP地址&gt;</span><br><span class="line"></span><br><span class="line">27.4.4 跟踪路由(Tracing the Route)</span><br><span class="line"></span><br><span class="line">SUN-A&gt; traceroute &lt;有故障的主机 | 有故障的IP地址&gt;</span><br><span class="line"></span><br><span class="line">C:\windows\&gt; winipcfg</span><br><span class="line"></span><br><span class="line">C:\windows\&gt; ipconfig</span><br><span class="line"></span><br><span class="line">C:\windows\&gt; ipconfig &#x2F; all</span><br><span class="line"></span><br><span class="line">C:\windows\&gt; tracert &lt;有故障的主机 | 有故障的IP地址&gt;</span><br><span class="line"></span><br><span class="line">     使用扩展的ping来跟踪连接性</span><br><span class="line"></span><br><span class="line">Router# ping</span><br><span class="line"></span><br><span class="line">     *其它可能的故障</span><br><span class="line"></span><br><span class="line">     一个地址解析（ARP）的故障</span><br><span class="line"></span><br><span class="line">Router# show arp</span><br><span class="line"></span><br><span class="line">Router# show interface &lt;有故障的接口&gt;</span><br><span class="line"></span><br><span class="line">C:\windows\&gt; arp -a</span><br><span class="line"></span><br><span class="line">SUN-A&gt; arp –a</span><br><span class="line"></span><br><span class="line">     验证终端系统的路由表</span><br><span class="line"></span><br><span class="line">C:\windows\&gt; netstat –rn</span><br><span class="line"></span><br><span class="line">C:\windows\&gt; route –f add 0.0.0.0 mask 0.0.0.0 &lt;需要添加入的网关地址&gt;</span><br><span class="line"></span><br><span class="line">C:\windows\&gt; route [–f ] [[print | add | delete | change] [destination] [mask</span><br><span class="line"></span><br><span class="line">netmask] [gateway]]</span><br><span class="line"></span><br><span class="line">C:\windows\&gt; route add mask &lt;网络掩码&gt; &lt;网关ip地址&gt;</span><br><span class="line"></span><br><span class="line">C:\windows\&gt; route delete mask &lt;网络掩码&gt; &lt;网关ip地址&gt;</span><br><span class="line"></span><br><span class="line">C:\windows\&gt; nbtstat &lt;相应的参数&gt;</span><br><span class="line"></span><br><span class="line">SUN-A&gt; netstat -rn路由器</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>思科</tag>
      </tags>
  </entry>
  <entry>
    <title>python的一些常用操作</title>
    <url>/python%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="连接-mongodb-数据库方法："><a href="#连接-mongodb-数据库方法：" class="headerlink" title="连接 mongodb 数据库方法："></a>连接 mongodb 数据库方法：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pymongo import MongoClient</span><br><span class="line">client &#x3D; MongoClient(&#39;localhost&#39;, 27017)</span><br><span class="line">client.database(用户名对应的数据库名称).authenticate(&quot;user&quot;,&quot;password&quot;)</span><br><span class="line">print(&#39;连接数据库成功&#39;)</span><br><span class="line">users &#x3D; client.oneDB.users(client.数据库.表名)</span><br></pre></td></tr></table></figure>
<h1 id="数据库操-pip"><a href="#数据库操-pip" class="headerlink" title="数据库操 pip"></a>数据库操 pip</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 定义json对象</span><br><span class="line">post &#x3D; &#123;</span><br><span class="line">        &quot;name&quot;: name,</span><br><span class="line">        &quot;hex&quot;: hex,</span><br><span class="line">        &quot;style&quot;: style</span><br><span class="line">    &#125;</span><br><span class="line"># 使用数据库操作命令操作表</span><br><span class="line">users.insert_one(post)</span><br></pre></td></tr></table></figure>
<h1 id="打印数据库中存储字段方法："><a href="#打印数据库中存储字段方法：" class="headerlink" title="打印数据库中存储字段方法："></a>打印数据库中存储字段方法：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pprint</span><br><span class="line">for user in users.find():</span><br><span class="line">pprint.pprint(user)</span><br></pre></td></tr></table></figure>
<p>抓取网页：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">url &#x3D; &quot;http:&#x2F;&#x2F;html-color-codes.info&#x2F;color-names&#x2F;&quot;</span><br><span class="line">hdrs &#x3D; &#123;&#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (X11; Fedora; Linux x86_64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko)&#39;&#125;</span><br><span class="line">r &#x3D; requests.get(url, headers&#x3D;hdrs)</span><br><span class="line">soup &#x3D; BeautifulSoup(r.content)</span><br></pre></td></tr></table></figure>
<h1 id="通过-class-名获取标签的方法："><a href="#通过-class-名获取标签的方法：" class="headerlink" title="通过 class 名获取标签的方法："></a>通过 class 名获取标签的方法：</h1><ol>
<li>如果获取的结果是数组(tds=[])，需要先转换成字符串 string = ‘’.join(str(i) for i in tds)</li>
<li>通过方法 soup=BeautifulSoup(string)</li>
<li>soup.find_all(attrs={‘class’,’demo’})即可找到所有 class 名为 demo 的标签</li>
</ol>
<h1 id="flask-写后台接口："><a href="#flask-写后台接口：" class="headerlink" title="flask 写后台接口："></a>flask 写后台接口：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># coding&#x3D;utf-8</span><br><span class="line"># mongo.py</span><br><span class="line">from flask import Flask,abort</span><br><span class="line">from flask import jsonify</span><br><span class="line">from flask import request</span><br><span class="line"># from flask_pymongo import PyMongo</span><br><span class="line">from pymongo import MongoClient</span><br><span class="line"></span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line"></span><br><span class="line">client &#x3D; MongoClient(&quot;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;&quot;)</span><br><span class="line">client.myblog.authenticate(&quot;user&quot;,&quot;password&quot;)</span><br><span class="line">database &#x3D; client[&quot;myblog&quot;]</span><br><span class="line">collection &#x3D; database[&quot;article&quot;]</span><br><span class="line"></span><br><span class="line">query &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line"># app.config[&#39;MONGO_DBNAME&#39;] &#x3D; &#39;myblog&#39;</span><br><span class="line"># app.config[&#39;MONGO_URI&#39;] &#x3D; &#39;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;myblog&#39;  </span><br><span class="line"># 如果部署在本上，其中ip地址可填127.0.0.1</span><br><span class="line">#</span><br><span class="line"># mongo &#x3D; PyMongo(app)</span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;login&#39;, methods&#x3D;[&#39;GET&#39;])</span><br><span class="line">def get_all_users():</span><br><span class="line">    star &#x3D; collection.find(query)</span><br><span class="line">    output &#x3D; []</span><br><span class="line">    for s in star:</span><br><span class="line">        output.append(&#123;&#39;name&#39; : s[&#39;name&#39;]&#125;)</span><br><span class="line">    return jsonify(&#123;&#39;result&#39; : output&#125;)</span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;register&#39;, methods&#x3D;[&#39;POST&#39;])</span><br><span class="line">def add_user():</span><br><span class="line">    star &#x3D; mongo.db.userInfo</span><br><span class="line">    name &#x3D; request.json[&#39;name&#39;]</span><br><span class="line">    pwd &#x3D; request.json[&#39;pwd&#39;]</span><br><span class="line">    star_id &#x3D; star.insert(&#123;&#39;name&#39;: name, &#39;pwd&#39;: pwd&#125;)</span><br><span class="line">    new_star &#x3D; star.find_one(&#123;&#39;_id&#39;: star_id &#125;)</span><br><span class="line">    output &#x3D; &#123;&#39;name&#39; : new_star[&#39;name&#39;], &#39;pwd&#39; : new_star[&#39;pwd&#39;]&#125;</span><br><span class="line">    return jsonify(&#123;&#39;result&#39; : output&#125;)</span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;modify&#x2F;&lt;string:name&gt;&#39;, methods&#x3D;[&#39;PUT&#39;])</span><br><span class="line">def update_user(name):</span><br><span class="line">    user &#x3D; mongo.db.userInfo.find(&#123;&quot;name&quot;:name&#125;)</span><br><span class="line">    output &#x3D; []</span><br><span class="line">    for s in user:</span><br><span class="line">        output.append(&#123;&#39;name&#39;: s[&#39;name&#39;], &#39;pwd&#39;: s[&#39;pwd&#39;]&#125;)</span><br><span class="line">    if len(output) &#x3D;&#x3D; 0:</span><br><span class="line">        abort(404)</span><br><span class="line">    mongo.db.userInfo.update(&#123;&quot;name&quot;:name&#125;,&#123;&#39;$set&#39;:&#123;&quot;name&quot;:&quot;LZ111&quot;&#125;&#125;)</span><br><span class="line">    return jsonify(&#123;&#39;result&#39;: output&#125;)</span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;delete&#x2F;&lt;string:name&gt;&#39;, methods&#x3D;[&#39;DELETE&#39;])</span><br><span class="line">def delete_user(name):</span><br><span class="line">    user &#x3D; mongo.db.userInfo.find(&#123;&quot;name&quot;: name&#125;)</span><br><span class="line">    output &#x3D; []</span><br><span class="line">    for s in user:</span><br><span class="line">        output.append(&#123;&#39;name&#39;: s[&#39;name&#39;], &#39;pwd&#39;: s[&#39;pwd&#39;]&#125;)</span><br><span class="line">    if len(output) &#x3D;&#x3D; 0:</span><br><span class="line">        abort(404)</span><br><span class="line">    mongo.db.userInfo.remove(&#123;&#39;name&#39;: name&#125;)</span><br><span class="line">    return jsonify(&#123;&#39;result&#39;: True&#125;)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    # app.run(host &#x3D; &#39;0.0.0.0&#39;, port &#x3D; 80, debug &#x3D; True)</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql_front连接报错，sql执行错误#3167的解决方案</title>
    <url>/mysql-front%E8%BF%9E%E6%8E%A5%E6%8A%A5%E9%94%99%EF%BC%8Csql%E6%89%A7%E8%A1%8C%E9%94%99%E8%AF%AF-3167%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>在使用myql_front连接mysql时出现了:The ‘INFORMATION_SCHEMA.SESSION_VARIABLES’ feature is disabled; see the documentation for ‘show_compatibility_56’<br><img src="/images/2020/08/02/c26c91e6-cbff-4b10-a5b7-98edbe907f4e.png" alt="image.png"><br>百度后得知-从mysql5.7.6开始information_schema.global_status已经开始被舍弃，为了兼容性，此时需要打开 show_compatibility_56</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from information_schema.global_status limit 3;</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/08/02/e2d686c1-ae6e-4d06-9268-e64a632c21de.png" alt="image.png"><br>查看一下show_compatibility_56的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;%show_compatibility_56%&#39;;</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/08/02/5be22427-fcce-40de-bcaa-9bfa86d0bffb.png" alt="image.png"><br>把show_compatibility_56打开</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global show_compatibility_56&#x3D;on;</span><br><span class="line">show variables like &#39;%show_compatibility_56%&#39;;</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/08/02/eeb4b7be-0fbc-46da-a8d0-f1519b91a2a8.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from information_schema.global_status limit 3;</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/08/02/abc7d072-69be-466f-8452-50eabc00c7e6.png" alt="image.png"><br>然后即可使用mysql_front连接到mysql数据库了<br><img src="/images/2020/08/02/967f9772-4350-4768-84d2-0dcdb044d757.png" alt="image.png"></p>
]]></content>
  </entry>
  <entry>
    <title>猫眼电影top100爬取</title>
    <url>/%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1top100%E7%88%AC%E5%8F%96.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">import re</span><br><span class="line">import urllib.request,urllib.error</span><br><span class="line">import xlwt</span><br><span class="line">import sqlite3</span><br><span class="line">def main():</span><br><span class="line">    baseurl &#x3D; &quot;https:&#x2F;&#x2F;maoyan.com&#x2F;board&#x2F;4?offset&#x3D;&quot;</span><br><span class="line">    datalist &#x3D; getData(baseurl)</span><br><span class="line">    savepath &#x3D; &quot;.\\猫眼电影Top100.xls&quot;</span><br><span class="line">    saveData(datalist,savepath)</span><br><span class="line">findName &#x3D; re.compile(r&#39;&lt;p class&#x3D;&quot;name&quot;&gt;(.*)&lt;&#x2F;p&gt;&#39;)</span><br><span class="line">finfStar &#x3D; re.compile(r&#39;&lt;p class&#x3D;&quot;star&quot;&gt;(.*?)&lt;&#x2F;p&gt;&#39;,re.S)</span><br><span class="line">findRating &#x3D; re.compile(r&#39;&lt;p class&#x3D;&quot;score&quot;&gt;&lt;i class&#x3D;&quot;integer&quot;&gt;(.*)&lt;&#x2F;i&gt;&lt;i class&#x3D;&quot;fraction&quot;&gt;(.*)&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;&#39;)</span><br><span class="line">def getData(baseurl):</span><br><span class="line">    datalist &#x3D; []</span><br><span class="line">    for i in range(0,10):</span><br><span class="line">        url &#x3D; baseurl + str(i*10)</span><br><span class="line">        html &#x3D; askURL(url)</span><br><span class="line">        soup &#x3D; BeautifulSoup(html,&quot;html.parser&quot;)</span><br><span class="line">        for item in soup.find_all(&#39;div&#39;,class_&#x3D;&quot;board-item-main&quot;):</span><br><span class="line">            data &#x3D; []</span><br><span class="line">            item &#x3D; str(item)</span><br><span class="line">            names &#x3D; re.findall(findName,item)[0]</span><br><span class="line">            data.append(names)</span><br><span class="line">            rating &#x3D; re.findall(findRating,item)[0]</span><br><span class="line">            data.append(rating)</span><br><span class="line">            star &#x3D; re.findall(finfStar,item)</span><br><span class="line">            if len(star) !&#x3D; 0:</span><br><span class="line">                inq &#x3D; star[0].replace(&quot;。&quot;,&quot;&quot;)</span><br><span class="line">                data.append(star)</span><br><span class="line">            else:</span><br><span class="line">                data.append(&quot; &quot;)</span><br><span class="line">            datalist.append(data)</span><br><span class="line">    return datalist</span><br><span class="line">def askURL(url):</span><br><span class="line">    head &#x3D; &#123;</span><br><span class="line">        &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;72.0.3626.81 Safari&#x2F;537.36 SE 2.X MetaSr 1.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    request &#x3D; urllib.request.Request(url,headers &#x3D; head)</span><br><span class="line">    html &#x3D; &quot;&quot;</span><br><span class="line">    try:</span><br><span class="line">        response &#x3D; urllib.request.urlopen(request)</span><br><span class="line">        html &#x3D; response.read().decode(&quot;utf-8&quot;)</span><br><span class="line">    except urllib.error.URLError as e:</span><br><span class="line">        if hasattr(e,&quot;code&quot;):</span><br><span class="line">            print(e.code)</span><br><span class="line">        if hasattr(e,&quot;reason&quot;):</span><br><span class="line">            print(e.reason)</span><br><span class="line">    return html</span><br><span class="line">def saveData(datalist,savepath):</span><br><span class="line">    print(&quot;save......&quot;)</span><br><span class="line">    book &#x3D; xlwt.Workbook(encoding&#x3D;&quot;utf-8&quot;,style_compression&#x3D;0)</span><br><span class="line">    sheet &#x3D; book.add_sheet(&#39;电影&#39;,cell_overwrite_ok&#x3D;True)</span><br><span class="line">    col &#x3D; (&quot;影片名&quot;,&quot;评分&quot;,&quot;主演&quot;)</span><br><span class="line">    for i in range(0,3):</span><br><span class="line">        sheet.write(0,i,col[i])</span><br><span class="line">    for i in range(0,100):</span><br><span class="line">        print(&quot;第%d条&quot;%(i+1))</span><br><span class="line">        data &#x3D; datalist[i]</span><br><span class="line">        for j in range(0,3):</span><br><span class="line">            sheet.write(i+1,j,data[j])</span><br><span class="line">    book.save(savepath)</span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    main()</span><br><span class="line">    print(&quot;爬取完毕&quot;)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/08/02/e70ca014-cca8-485b-90ac-2be128e90384.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>百度贴吧爬取</title>
    <url>/%E7%99%BE%E5%BA%A6%E8%B4%B4%E5%90%A7%E7%88%AC%E5%8F%96.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from bs4 import BeautifulSoup  # 网页解析，获取数据</span><br><span class="line">import re  # 正则表达式，进行文字匹配</span><br><span class="line">import urllib.request, urllib.error  # 制定URL，获取网页数据</span><br><span class="line">import xlwt  # 进行excel操作</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    url &#x3D; &quot;https:&#x2F;&#x2F;tieba.baidu.com&#x2F;f?kw&#x3D;%E6%AD%A6%E6%B1%89&amp;ie&#x3D;utf-8&amp;pn&#x3D;0&quot;</span><br><span class="line">    html &#x3D; askURL(url)</span><br><span class="line">    soup &#x3D; BeautifulSoup(html,&quot;html.parser&quot;)</span><br><span class="line">    for item in soup.find_all(&#39;div&#39;,class_&#x3D; &quot;j_thread_list clearfix&quot;):</span><br><span class="line">        item &#x3D; str(item)</span><br><span class="line">        print(item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def askURL(url):</span><br><span class="line">    head &#x3D; &#123;</span><br><span class="line">        &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;76.0.3809.87 Safari&#x2F;537.36 SLBrowser&#x2F;6.0.1.6181&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    request &#x3D; urllib.request.Request(url, headers&#x3D;head)</span><br><span class="line">    html &#x3D; &quot;&quot;</span><br><span class="line">    try:</span><br><span class="line">        response &#x3D; urllib.request.urlopen(request)</span><br><span class="line">        html &#x3D; response.read().decode(&quot;utf-8&quot;)</span><br><span class="line">    except urllib.error.URLError as e:</span><br><span class="line">        if hasattr(e, &quot;code&quot;):</span><br><span class="line">            print(e.code)</span><br><span class="line">        if hasattr(e, &quot;reason&quot;):</span><br><span class="line">            print(e.reason)</span><br><span class="line">    return html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    main()</span><br><span class="line">    print(&quot;爬取完毕！&quot;)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/08/02/6bb76f0a-a216-46ad-abfc-8362fe248a89.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>国外疫情数据爬取</title>
    <url>/%E5%9B%BD%E5%A4%96%E7%96%AB%E6%83%85%E6%95%B0%E6%8D%AE%E7%88%AC%E5%8F%96.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    divs &#x3D; driver.find_elements_by_xpath(&#39;&#x2F;&#x2F;*[@id&#x3D;&quot;foreignWraper&quot;]&#x2F;table&#x2F;tbody&#x2F;tr&#39;)</span><br><span class="line">    for div in divs:</span><br><span class="line">        area &#x3D; div.find_element_by_xpath(&#39;.&#x2F;&#x2F;th&#39;).text</span><br><span class="line">        new &#x3D; div.find_element_by_xpath(&#39;.&#x2F;&#x2F;td[1]&#39;).text</span><br><span class="line">        total &#x3D; div.find_element_by_xpath(&#39;.&#x2F;&#x2F;td[2]&#39;).text</span><br><span class="line">        cured &#x3D; div.find_element_by_xpath(&#39;.&#x2F;&#x2F;td[3]&#39;).text</span><br><span class="line">        die &#x3D; div.find_element_by_xpath(&#39;.&#x2F;&#x2F;td[4]&#39;).text</span><br><span class="line">        print(area,new,total,cured,die,sep&#x3D;&#39;|&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    url &#x3D; &#39;https:&#x2F;&#x2F;news.qq.com&#x2F;zt2020&#x2F;page&#x2F;feiyan.htm#&#x2F;global?nojump&#x3D;1&#39;</span><br><span class="line"></span><br><span class="line">    driver &#x3D; webdriver.Chrome()</span><br><span class="line">    driver.get(url)</span><br><span class="line"></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p><img src="/images/2020/08/02/94afed6c-883a-4c23-b91c-12d74a85c6b1.png" alt="image.png"><br><img src="/images/2020/08/02/df67da6d-1967-4247-a349-e30d30068795.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>爬取电影天堂磁力链接</title>
    <url>/%E7%88%AC%E5%8F%96%E7%94%B5%E5%BD%B1%E5%A4%A9%E5%A0%82%E7%A3%81%E5%8A%9B%E9%93%BE%E6%8E%A5.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"># @Time : 2020&#x2F;8&#x2F;2 17:46</span><br><span class="line"># @Author : zc</span><br><span class="line"># @File : 爬取电影天堂磁力链接.py</span><br><span class="line"># @Software: PyCharm</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Created on Fri Jul 10 13:17:16 2020</span><br><span class="line">程序功能：可以爬取电影天堂网站所有的电影名称，电影详情，磁力链接</span><br><span class="line">@author: emperor</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line"># import re</span><br><span class="line">import bs4</span><br><span class="line">import pandas as pd</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 获取网页</span><br><span class="line">def getHTMLText(url):</span><br><span class="line">    try:</span><br><span class="line">        headers &#x3D; &#123;&#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:77.0) Gecko&#x2F;20100101 Firefox&#x2F;77.0&#39;&#125;</span><br><span class="line">        r &#x3D; requests.get(url, headers&#x3D;headers, timeout&#x3D;30)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding &#x3D; r.apparent_encoding</span><br><span class="line">        return r.text</span><br><span class="line">    except requests.HTTPError as e:</span><br><span class="line">        print(e)</span><br><span class="line">        print(&quot;HTTPError&quot;)</span><br><span class="line">    except requests.RequestException as e:</span><br><span class="line">        print(e)</span><br><span class="line">    except:</span><br><span class="line">        print(&quot;Unknown Error !&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 解析网页</span><br><span class="line">def parseHtml(html):</span><br><span class="line">    bsObj &#x3D; bs4.BeautifulSoup(html, &quot;html.parser&quot;)</span><br><span class="line">    info &#x3D; []  # 储存所有信息</span><br><span class="line">    # 获取电影列表</span><br><span class="line">    tblist &#x3D; bsObj.find_all(&#39;table&#39;, attrs&#x3D;&#123;&#39;class&#39;: &#39;tbspan&#39;&#125;)</span><br><span class="line">    # 对一页里面的每一个电影单独解析处理</span><br><span class="line">    for item in tblist:</span><br><span class="line">        movie &#x3D; []</span><br><span class="line">        link &#x3D; item.b.find_all(&#39;a&#39;)[1]</span><br><span class="line"></span><br><span class="line">        # 获取电影名称</span><br><span class="line">        movie_name &#x3D; link[&quot;title&quot;]</span><br><span class="line"></span><br><span class="line">        # 获取电影详情的url</span><br><span class="line">        url &#x3D; &quot;https:&#x2F;&#x2F;www.dy2018.com&quot; + link[&quot;href&quot;]</span><br><span class="line"></span><br><span class="line">        # 将电影的名称和详情链接放入movie列表</span><br><span class="line">        movie.append(movie_name)</span><br><span class="line">        movie.append(url)</span><br><span class="line">        # print(movie)</span><br><span class="line">        try:</span><br><span class="line">            temp &#x3D; bs4.BeautifulSoup(getHTMLText(url), &quot;html.parser&quot;)  # 解析电影详情页</span><br><span class="line">            tbody &#x3D; temp.find_all(&#39;tbody&#39;)</span><br><span class="line">            # 将电影下载链接放入movie列表</span><br><span class="line">            for i in tbody:</span><br><span class="line">                download &#x3D; i.a.text</span><br><span class="line">                movie.append(download)</span><br><span class="line">            # print(movie)</span><br><span class="line">            # 将电影信息全部放入电影列表中</span><br><span class="line">            info.append(movie)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(e)</span><br><span class="line">    return info</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 储存电影信息</span><br><span class="line">def saveDate(data):</span><br><span class="line">    file_name &#x3D; &#39;电影天堂.csv&#39;  # 可用正则表达式，自动选取名字</span><br><span class="line"></span><br><span class="line">    dataFrame &#x3D; pd.DataFrame(data)</span><br><span class="line">    dataFrame.to_csv(file_name, mode&#x3D;&#39;a&#39;, index&#x3D;False, sep&#x3D;&#39;,&#39;, header&#x3D;False)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 主函数</span><br><span class="line">def main():</span><br><span class="line">    start_url &#x3D; &quot;https:&#x2F;&#x2F;www.dy2018.com&#x2F;&quot;</span><br><span class="line">    depth &#x3D; 1  # 翻页器，可以自定义翻页数</span><br><span class="line">    style &#x3D; 20  # 不同类型的电影，共20类</span><br><span class="line">    for j in range(style):</span><br><span class="line">        print(&quot;正在爬取第&quot; + str(1 + j) + &quot;类电影信息&quot;)</span><br><span class="line">        first_url &#x3D; start_url + str(1 + j) + &quot;&#x2F;index&quot;</span><br><span class="line">        for i in range(depth):</span><br><span class="line">            print(&quot;正在爬取第&quot; + str(1 + i) + &quot;页电影信息&quot;)</span><br><span class="line">            if i &#x3D;&#x3D; 0:</span><br><span class="line">                url &#x3D; first_url + &quot;.html&quot;  # 处理第一页,可设计处理“1”，实现不同类型的电影爬取</span><br><span class="line">            else:</span><br><span class="line">                url &#x3D; first_url + &quot;_&quot; + str(i * 2) + &quot;.html&quot;  # 翻页</span><br><span class="line">            html &#x3D; getHTMLText(url)</span><br><span class="line">            movies &#x3D; parseHtml(html)</span><br><span class="line">            saveDate(movies)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    print(&#39;爬虫开始启动&#39;)</span><br><span class="line">    start_time &#x3D; datetime.datetime.now()</span><br><span class="line">    main()</span><br><span class="line">    end_time &#x3D; datetime.datetime.now()</span><br><span class="line">    print(&quot;程序总共用时：&#123;:&#125;&quot;.format(end_time - start_time))</span><br><span class="line">    print(&#39;爬取页面结束&#39;)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/08/02/f7aed2c6-4faf-4134-9016-12e5cd072e8c.png" alt="image.png"><br><img src="/images/2020/08/02/1b43eb8c-becd-43ea-b22a-cf63ab28a279.png" alt="image.png"><br><img src="/images/2020/08/02/ddf0e025-8810-437d-b4d8-2a2ca1e5da14.png" alt="image.png"><br><img src="/images/2020/08/02/35eb3d08-6046-4e79-a40d-fb458be74000.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>hadoop平台搭建基本指令</title>
    <url>/hadoop%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.改主机Windows的ip</span><br><span class="line">ip：192.168.2.138</span><br><span class="line">子网掩码：255.255.255.0</span><br><span class="line">网关：192.168.2.1</span><br><span class="line">DNS：114.114.114.114</span><br><span class="line"></span><br><span class="line">2.相互ping通</span><br><span class="line">ping 192.168.2.138</span><br><span class="line">ping 192.168.2.127</span><br><span class="line"></span><br><span class="line">3.关闭防火墙</span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line">systemctl status firewalld</span><br><span class="line"></span><br><span class="line">4.关闭selinux</span><br><span class="line">vim &#x2F;etc&#x2F;sysconfig&#x2F;selinux</span><br><span class="line"></span><br><span class="line">5.配置虚拟机的网络</span><br><span class="line">vim &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-enp0s3</span><br><span class="line"></span><br><span class="line">IPADDR&#x3D;192.168.2.111</span><br><span class="line">NETMASK&#x3D;255.255.255.0</span><br><span class="line">DNS&#x3D;114.114.114.114</span><br><span class="line">GATEWAY&#x3D;192.168.1.1</span><br><span class="line"></span><br><span class="line">service network restart</span><br><span class="line"></span><br><span class="line">6.配置hosts文件</span><br><span class="line">192.168.2.127</span><br><span class="line"></span><br><span class="line">7.安装JDK</span><br><span class="line">rpm -qa|grep java </span><br><span class="line">rpm -e --nodeps ......</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;opt&#x2F;hadoop&#x2F;java&#x2F;jdk1.8.0_241</span><br><span class="line"></span><br><span class="line">tar -xvf jdk-8u241-linux-x64.tar.gz -C &#x2F;opt&#x2F;hadoop&#x2F;java&#x2F;</span><br><span class="line"></span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br><span class="line"></span><br><span class="line">8.安装hadoop（&#x2F;opt&#x2F;hadoop&#x2F;hadoop-2.10.0）</span><br><span class="line"> tar -xvf hadoop-2.10.0.tar.gz -C &#x2F;opt&#x2F;hadoop&#x2F;</span><br><span class="line"></span><br><span class="line">	8.1 配置Hadoop环境变量</span><br><span class="line">		HADOOP_HOME&#x3D;&#x2F;opt&#x2F;hadoop&#x2F;hadoop-2.10.0</span><br><span class="line">		#JAVA_HOME</span><br><span class="line">		JAVA_HOME&#x3D;&#x2F;opt&#x2F;hadoop&#x2F;java&#x2F;jdk1.8.0_241</span><br><span class="line"></span><br><span class="line">		#HADOOP_HOME</span><br><span class="line">		HADOOP_HOME&#x3D;&#x2F;opt&#x2F;hadoop&#x2F;hadoop-2.10.0</span><br><span class="line"></span><br><span class="line">		export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$HADOOP_HOME&#x2F;bin:$HADOOP_HOME&#x2F;sbin</span><br><span class="line">		</span><br><span class="line">		source &#x2F;etc&#x2F;profile</span><br><span class="line">		</span><br><span class="line">	8.2 配置Hadoop运行环境</span><br><span class="line">	&#x2F;opt&#x2F;hadoop&#x2F;hadoop-2.10.0&#x2F;etc&#x2F;hadoop</span><br><span class="line">	</span><br><span class="line">	vim hadoop-env.sh</span><br><span class="line">	export JAVA_HOME&#x3D;&#x2F;opt&#x2F;hadoop&#x2F;java&#x2F;jdk1.8.0_241</span><br><span class="line">	</span><br><span class="line">	8.3 配置core-site.xml</span><br><span class="line">	</span><br><span class="line">	&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;fs.defaultFS&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;hdfs:&#x2F;&#x2F;bp01:9000&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hadoop.tmp.dir&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;&#x2F;opt&#x2F;hadoop&#x2F;hadoop-2.10.0&#x2F;tmp&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">	&lt;&#x2F;configuration&gt;</span><br><span class="line">	</span><br><span class="line">	8.4配置hdfs-site.xml</span><br><span class="line">	&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.replication&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;1&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">	&lt;&#x2F;configuration&gt;</span><br><span class="line">	</span><br><span class="line">	8.5配置mapred-site.xml</span><br><span class="line">	&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.framework.name&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;yarn&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">	&lt;&#x2F;configuration&gt;</span><br><span class="line"></span><br><span class="line">	8.6配置yarn-site.xml</span><br><span class="line">	&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.hostname&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;bp01&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.aux-services&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;mapreduce_shuffle&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">	&lt;&#x2F;configuration&gt;</span><br><span class="line">	</span><br><span class="line">9.免密登录SSH</span><br><span class="line">	9.1 在家目录下面创建.ssh隐藏文件夹</span><br><span class="line">	9.2 进入.ssh文件夹下，然后运行ssh-keygen,回车</span><br><span class="line">	9.3 cp id_rsa.pub authorized_keys</span><br><span class="line">	9.4 ssh bp01,然后yes</span><br><span class="line">	</span><br><span class="line">10.格式化HDFS</span><br><span class="line">hdfs namenode -format</span><br><span class="line"></span><br><span class="line">11.查看启动成功</span><br><span class="line">jps</span><br><span class="line">22912 NameNode</span><br><span class="line">23200 SecondaryNameNode</span><br><span class="line">23441 NodeManager</span><br><span class="line">23347 ResourceManager</span><br><span class="line">23756 Jps</span><br><span class="line">23039 DataNode</span><br><span class="line"></span><br><span class="line">.&#x2F;start-all.sh</span><br><span class="line">http:&#x2F;&#x2F;192.168.1.111:50070&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;192.168.1.111:8088&#x2F;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop实验一</title>
    <url>/Hadoop%E5%AE%9E%E9%AA%8C%E4%B8%80.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>实验1 MapReduce编程入门及实战</p>
<p>课程目标：</p>
<blockquote>
<blockquote>
<p>掌握以IDEA创建MapReduce工程<br>理解MapReduce的基本原理及执行流程<br>读懂Hadoop官方示例WordCount的源码<br>掌握MapReduce编程的基本思路<br>理解Map函数和Reduce函数的处理逻辑<br>能够编写MapReduce程序来处理简单任务</p>
</blockquote>
</blockquote>
<p>第1节 项目概述<br>1.1 项目介绍<br>    【项目背景】<br>校园社区网站有数百万的注册用户，网站服务器上保留了用户登录网站的日志记录，即用户登录一次网站就在日志文件中记录一次用户的学号。 目前有2019年某一天的原始数据文件login.log,共800万行记录，部分内容如下：<br>     2016001,20190319<br>     2016002,20190319<br>     2016001,20190319<br>运营部门希望能定期获得用户的登录次数信息，进行用户行为分析，从而制定有效的运营计划。<br>    【解决方案】<br>    通过理论加实践的方式逐层深入剖析MapReduce的分析计算。<br>通过MapReduce分析计算框架来解决校园社区网站的数据分析问题。</p>
<p>【项目任务】<br>▲ 任务1：MapReduce原理<br>▲ 任务2：MapReduce开发环境搭建<br>▲ 任务3：校园社区网站访问次数统计<br>▲ 任务4：校园社区网站访问次数排序<br>【拓展任务】<br>▲ 任务5：获取成绩表的最高分记录<br>▲ 任务6：对两个文件中的数据进行合并去重<br>第2节  项目任务<br>2.1 MapReduce原理<br> <img src="/images/2020/08/02/9ec1dd94-eefb-43eb-bd25-41ca744418f3.png" alt="image.png"><br>图2-1 MapReduce WordCount处理流程<br>2.1.1实验准备<br>启动大数据实验平台，浏览器登录大数据平台管理界面；准备实验数据；准备WordCount代码。<br>2.1.2实验步骤<br>【数据准备】</p>
<p>Dear Bear River<br>Car Car River<br>Dear Car Bear</p>
<p>【数据上传】<br>通过HDFS Shell将实验数据上传到HDFS（如果没有搭建好Hadoop平台的同学，可以在本地进行测试）<br>【准备WordCount代码】<br>自行手写WordCount代码<br>2.2 MapReduce开发环境搭建<br>2.2.1实验准备<br>启动大数据实验平台，浏览器登录大数据平台管理界面；准备MapReduce开发环境配置软件包。<br>2.2.2实验步骤<br>【下载与安装IDEA】<br>   详细内容见【Hadoop平台搭建.txt】</p>
<p>【Windows环境变量配置】<br> <img src="/images/2020/08/02/3ff269b8-bca4-441c-babe-afb1168d7ef9.png" alt="image.png"><br>图2-2Windows环境变量配置</p>
<p>2.3 校园社区网站访问次数统计<br>2.3.1实验准备<br>启动大数据实验平台，浏览器登录大数据平台管理界面。准备样例数据：<br>     2016001,20190319<br>     2016002,20190319<br>     2016001,20190319<br>2.3.2实验步骤<br>【上传数据】<br>通过HDFS Shell将实验数据上传到HDFS。<br> <img src="/images/2020/08/02/c0869682-cb34-4dbb-aa55-dc3a80e7d885.png" alt="image.png"><br>【创建MapReduce项目】<br>启动IDEA，创建MapReduce项目。<br> <img src="/images/2020/08/02/38629559-4f5f-43b3-8ab9-465b41cf316a.png" alt="image.png"><br>【编写MapReduce程序】<br>编写核心模块代码：<br>    编写Mapper模块代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package zc.mapreduce;</span><br><span class="line">import org.apache.hadoop.io.IntWritable;</span><br><span class="line">import org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line">import org.apache.hadoop.io.Text;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class MyMapper extends Mapper&lt;Object, Text,Text, IntWritable&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void map(Object key,Text value,Context context) throws IOException,InterruptedException&#123;</span><br><span class="line">        String line &#x3D;value.toString();</span><br><span class="line">        String[] words &#x3D; line.split(&quot;,&quot;);</span><br><span class="line">        for (String word: words)&#123;</span><br><span class="line">            context.write(new Text(word),new IntWritable(1));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<pre><code>编写Reducer模块代码</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package zc.mapreduce;</span><br><span class="line">import org.apache.hadoop.io.IntWritable;</span><br><span class="line">import org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line">import org.apache.hadoop.io.Text;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class MyReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt; &#123;</span><br><span class="line"></span><br><span class="line">private IntWritable result &#x3D; new IntWritable() ;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"></span><br><span class="line">protected void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException,InterruptedException &#123;</span><br><span class="line">    int sum&#x3D; 0;</span><br><span class="line">    for (IntWritable value : values)&#123;</span><br><span class="line">        sum +&#x3D; value.get();</span><br><span class="line">&#125;</span><br><span class="line">        result.set(sum);</span><br><span class="line">    context. write (key, result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>编写Driver模块代码</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package zc.mapreduce;</span><br><span class="line">import org.apache.hadoop.conf.Configuration;</span><br><span class="line">import org.apache.hadoop.fs.Path;</span><br><span class="line">import org.apache.hadoop.io.IntWritable;</span><br><span class="line">import org.apache.hadoop.io.Text;</span><br><span class="line">import org.apache.hadoop.mapreduce.Job;</span><br><span class="line">import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line">import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line">import zc.mapreduce.MyMapper;</span><br><span class="line">import zc.mapreduce.MyReducer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class WebsiteVistors &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException, InterruptedException &#123;</span><br><span class="line">        Configuration conf &#x3D; new Configuration();</span><br><span class="line">        Job job &#x3D; Job.getInstance(conf,&quot;websitevistors&quot;);</span><br><span class="line">        job.setJarByClass(WebsiteVistors.class);</span><br><span class="line">        job.setMapperClass(MyMapper.class);</span><br><span class="line">        job.setReducerClass(MyReducer.class);</span><br><span class="line">        &#x2F;&#x2F;map reduce输出</span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(IntWritable.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        FileInputFormat.addInputPath(job,new Path(&quot;d:\\校园社区网站访问次数统计.txt&quot;));</span><br><span class="line">        FileOutputFormat.setOutputPath(job,new Path(&quot;d:\\output\\访问次数统计结果&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.exit(job.waitForCompletion(true)?0:1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【测试运行】<br>通过IDEA运行</p>
<p> <img src="/images/2020/08/02/aeacaa5e-01b3-4102-84d1-a00e8867628d.png" alt="image.png"><br><img src="/images/2020/08/02/86d01633-7ca3-4086-bcf9-b5aa1c41edc0.png" alt="image.png"><br><img src="/images/2020/08/02/5eae2f9f-c94a-4710-9649-3f3a464734bd.png" alt="image.png"><br> <img src="/images/2020/08/02/1f43a0ee-56a3-4eb4-932e-d7267b9fd011.png" alt="image.png"></p>
<p>2.4 校园社区网站访问次数排序<br>2.4.1实验准备<br>启动大数据实验平台，浏览器登录大数据平台管理界面。准备样例数据：<br>  20160101,100<br>20160102,200<br>20160103,151<br>20160120,120<br>20160121,1000<br>2.4.2实验步骤<br>【上传数据】<br>通过HDFS Shell将实验数据上传到HDFS。<br> <img src="/images/2020/08/02/15c7ba28-2e52-483b-bf4a-fb9ffab93da3.png" alt="image.png"><br>【创建MapReduce项目】<br>启动IDEA，创建MapReduce项目。<br> <img src="/images/2020/08/02/ecd97d6a-16de-45b0-b720-34f8bdb0ea8a.png" alt="image.png"><br>【编写MapReduce程序】<br>编写核心模块代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	编写Mapper模块代码</span><br><span class="line">	package sort;</span><br><span class="line"></span><br><span class="line">import org.apache.hadoop.io.IntWritable;</span><br><span class="line">import org.apache.hadoop.io.Text;</span><br><span class="line">import org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class MyMapper extends Mapper &lt;Object, Text, IntWritable, Text&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void map(Object key, Text value, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">        String lines &#x3D; value.toString();</span><br><span class="line">        String[] words &#x3D; lines.split(&quot;,&quot;);</span><br><span class="line">        int keyOut &#x3D; Integer.parseInt(words[1]);</span><br><span class="line">        String valueOut &#x3D; words[0];</span><br><span class="line">        context.write(new IntWritable(keyOut), new Text(valueOut));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>编写Reducer模块代码</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package sort;</span><br><span class="line">import org.apache.hadoop.io.IntWritable;</span><br><span class="line">import org.apache.hadoop.io.Text;</span><br><span class="line">import org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">class MyReducer extends Reducer&lt;IntWritable, Text,Text,IntWritable&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void reduce(IntWritable key, Iterable&lt;Text&gt; values, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">        for (Text value : values) &#123;</span><br><span class="line">            context.write(value, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>编写Driver模块代码    </code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package sort;</span><br><span class="line">import org.apache.hadoop.conf.Configuration;</span><br><span class="line">import org.apache.hadoop.fs.Path;</span><br><span class="line"></span><br><span class="line">import org.apache.hadoop.io.IntWritable;</span><br><span class="line">import org.apache.hadoop.io.Text;</span><br><span class="line"></span><br><span class="line">import org.apache.hadoop.mapreduce.Job;</span><br><span class="line">import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line">import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">import static org.apache.hadoop.mapreduce.Job.getInstance;</span><br><span class="line"></span><br><span class="line">public class VistSorted &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException, InterruptedException&#123;</span><br><span class="line">        Configuration conf&#x3D;new Configuration() ;</span><br><span class="line">        Job job &#x3D; getInstance(conf,&quot;VistSorted&quot;);</span><br><span class="line">        job.setJarByClass(VistSorted.class);</span><br><span class="line">        job.setMapperClass(MyMapper.class);</span><br><span class="line">        job.setReducerClass(MyReducer.class);</span><br><span class="line">        &#x2F;&#x2F;map reduce输出</span><br><span class="line">        job.setMapOutputKeyClass(IntWritable.class);</span><br><span class="line">        job.setMapOutputValueClass(Text.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        FileInputFormat.addInputPath(job,new Path(&quot;d:\\校园社区网站访问次数排序.txt&quot;));</span><br><span class="line">        FileOutputFormat.setOutputPath(job,new Path(&quot;d:\\output\\访问次数排序结果&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.exit(job.waitForCompletion(true)?0:1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>【测试运行】<br>通过IDEA运行<br> <img src="/images/2020/08/02/f4f8d6b0-9f84-4476-9834-08b342fc2a47.png" alt="image.png"><br><img src="/images/2020/08/02/22d43e51-bb88-440f-a6b2-641367640ecb.png" alt="image.png"><br><img src="/images/2020/08/02/aa6e5405-243d-4bec-a14d-cd84f02a6d24.png" alt="image.png"><br><img src="/images/2020/08/02/04084b00-88d2-4103-877f-6b0a223eaeb1.png" alt="image.png"></p>
<p>第3节  拓展任务<br>3.1 获取成绩表的最高分记录<br>3.1.1实验准备<br>启动大数据实验平台，浏览器登录大数据平台管理界面。准备实验数据。<br>语文,95<br>数学,98<br>英语,99<br>英语,88<br>语文,78<br>数学,100<br>3.1.2实验步骤<br>【上传数据】<br>将实验数据上传至HDFS大数据实验平台<br> <img src="/images/2020/08/02/a34f7dc8-5b0d-48fb-a3e1-bf565cfb0c58.png" alt="image.png"><br>【创建MapReduce项目】<br>启动IDEA，创建MapReduce项目。<br> <img src="/images/2020/08/02/32c597a9-e2d1-477c-b6d5-b73443e6ec14.png" alt="image.png"><br>【编写MapReduce程序】<br>编写核心模块代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	编写Mapper模块代码</span><br><span class="line">	package score;</span><br><span class="line"></span><br><span class="line">import org.apache.hadoop.io.IntWritable;</span><br><span class="line">import org.apache.hadoop.io.Text;</span><br><span class="line">import org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class MyMapper extends Mapper&lt;Object, Text,Text, IntWritable&gt;  &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void map(Object key,Text value,Context context) throws IOException,InterruptedException&#123;</span><br><span class="line">        String line&#x3D;value.toString();</span><br><span class="line">        String[] words&#x3D;line.split(&quot;,&quot;);</span><br><span class="line">        context.write(new Text(words[0]),new IntWritable(Integer.parseInt(words[1])));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	编写Reducer模块代码</span><br><span class="line">	package score;</span><br><span class="line"></span><br><span class="line">import org.apache.hadoop.io.IntWritable;</span><br><span class="line">import org.apache.hadoop.io.Text;</span><br><span class="line">import org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class MyReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt; &#123;</span><br><span class="line">    private IntWritable result &#x3D; new IntWritable() ;</span><br><span class="line">    @Override</span><br><span class="line">    protected void reduce(Text key, Iterable&lt;IntWritable&gt; values,Context context) throws IOException, InterruptedException&#123;</span><br><span class="line">        int high &#x3D; 0;</span><br><span class="line">        for (IntWritable value : values)&#123;</span><br><span class="line">            if (value. get() &gt; high) &#123;</span><br><span class="line">            high &#x3D; value. get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result.set(high);</span><br><span class="line">    context. write (key, result) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	编写Driver模块代码</span><br><span class="line">	package score;</span><br><span class="line"></span><br><span class="line">import org.apache.hadoop.conf.Configuration;</span><br><span class="line"></span><br><span class="line">import org.apache.hadoop.fs.Path;</span><br><span class="line">import org.apache.hadoop.io.IntWritable;</span><br><span class="line">import org.apache.hadoop.io.Text;</span><br><span class="line">import org.apache.hadoop.mapreduce.Job;</span><br><span class="line">import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line">import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class HighestScore &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException, InterruptedException&#123;</span><br><span class="line">        Configuration conf &#x3D; new Configuration();</span><br><span class="line">        Job job &#x3D; Job. getInstance(conf,&quot;highestScore&quot; );</span><br><span class="line">        job. setJarByClass (HighestScore. class) ;</span><br><span class="line">        job. setMapperClass (MyMapper. class) ;</span><br><span class="line">        job. setReducerClass (MyReducer. class) ;</span><br><span class="line">        job. setMapOutputKeyClass(Text. class);</span><br><span class="line">        job. setOutputValueClass (IntWritable. class);</span><br><span class="line">        job. setOutputKeyClass (Text. class) ;</span><br><span class="line">        job. setOutputValueClass (IntWritable. class);</span><br><span class="line">        FileInputFormat.addInputPath(job, new Path( &quot;d:\\获取成绩表的最高分记录.txt&quot;));</span><br><span class="line">        FileOutputFormat.setOutputPath(job,new Path(&quot;d:\\output\\成绩表的最高分记录结果&quot;));</span><br><span class="line"></span><br><span class="line">        System.exit(job.waitForCompletion(true)?0:1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【测试运行】<br>通过IDEA运行<br> <img src="/images/2020/08/02/dad965c9-d9b0-443f-8035-4d7866d5b2f6.png" alt="image.png"><br><img src="/images/2020/08/02/29313513-d63e-44fa-817d-b71eeced932a.png" alt="image.png"><br> <img src="/images/2020/08/02/2e2c0785-cd58-487c-a8bd-1c9d61761c5a.png" alt="image.png"><br>  <img src="/images/2020/08/02/480ff089-758d-445b-bc2a-32e52e0a042d.png" alt="image.png"></p>
<p>3.2 对两个文件中的数据进行合并去重<br>3.2.1实验准备<br>启动大数据实验平台，浏览器登录大数据平台管理界面，准备实验数据。<br>XX.txt<br>20160102<br>20160103<br>20160105<br>YY.txt<br>20160101<br>20160102<br>20160106<br>3.2.2实验步骤<br>【上传数据】<br>将实验数据上传至HDFS大数据实验平台<br> <img src="/images/2020/08/02/2cd6c6f4-eda0-44d3-ac50-d5e228cea2ab.png" alt="image.png"><br>【创建MapReduce项目】<br>启动IDEA，创建MapReduce项目。<br> <img src="/images/2020/08/02/92d0a240-4155-41ae-85ee-fc41e5fd5203.png" alt="image.png"><br>【编写MapReduce程序】<br>编写核心模块代码：<br>    编写Mapper模块代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package ComBiner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import org.apache.hadoop.io.IntWritable;</span><br><span class="line">import org.apache.hadoop.io.Text;</span><br><span class="line">import org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class CombinerMapper extends Mapper&lt;Object, Text, Text, IntWritable&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void map (Object key, Text value,Context context) throws IOException,InterruptedException &#123;</span><br><span class="line">        context. write (value, new IntWritable( 1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>编写Reducer模块代码</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package ComBiner;</span><br><span class="line"></span><br><span class="line">import org.apache.hadoop.io.IntWritable;</span><br><span class="line">import org.apache.hadoop.io.NullWritable;</span><br><span class="line">import org.apache.hadoop.io.Text;</span><br><span class="line">import org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class CombinerReducer extends Reducer&lt;Text, IntWritable, Text, NullWritable&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void reduce (Text key,Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">        context. write (key, null) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>    编写Driver模块代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package ComBiner;</span><br><span class="line"></span><br><span class="line">import org.apache.hadoop.conf.Configuration;</span><br><span class="line">import org.apache.hadoop.fs.Path;</span><br><span class="line">import org.apache.hadoop.io.IntWritable;</span><br><span class="line">import org.apache.hadoop.io.NullWritable;</span><br><span class="line">import org.apache.hadoop.io.Text;</span><br><span class="line">import org.apache.hadoop.mapreduce.Job;</span><br><span class="line">import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line">import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Combiner &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException,ClassNotFoundException, InterruptedException &#123;</span><br><span class="line">        Configuration conf &#x3D; new Configuration() ;</span><br><span class="line">        Job job &#x3D; Job. getInstance(conf,&quot;Combiner&quot; );</span><br><span class="line">        job. setJarByClass (Combiner.class) ;</span><br><span class="line">        job. setMapperClass (CombinerMapper.class) ;</span><br><span class="line">        job. setReducerClass (CombinerReducer.class) ;</span><br><span class="line">        job. setMapOutputKeyClass(Text. class);</span><br><span class="line">        job. setMapOutputValueClass (IntWritable. class);</span><br><span class="line">        job. setOutputKeyClass (Text. class) ;</span><br><span class="line">        job. setOutputValueClass (NullWritable. class);</span><br><span class="line">        FileInputFormat.addInputPath(job,new Path(&quot;d:\\对两个文件中的数据进行合并去重&quot;));</span><br><span class="line"></span><br><span class="line">        FileOutputFormat.setOutputPath(job,new Path(&quot;d:\\output\\合并去重结果&quot;));</span><br><span class="line">        System.exit(job.waitForCompletion(true)?0:1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【测试运行】<br>通过IDEA运行<br> <img src="/images/2020/08/02/0816d696-dd75-46ba-b518-10408c8d4d2f.png" alt="image.png"><br> <img src="/images/2020/08/02/af47a762-1817-42e5-80e7-9dca25ef215f.png" alt="image.png"><br> <img src="/images/2020/08/02/11727aa8-7c71-4bec-8683-9a7ddcfc45b2.png" alt="image.png"><br> <img src="/images/2020/08/02/ff3f5a48-b523-4cc2-b8f3-a81de7c38ac7.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>python实列</title>
    <url>/python%E5%AE%9E%E5%88%97.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="猜拳游戏"><a href="#猜拳游戏" class="headerlink" title="猜拳游戏"></a>猜拳游戏</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import random  # 调用随机库</span><br><span class="line"># 用户</span><br><span class="line">user &#x3D; int(input(&#39;请输入：剪刀（0)、石头（1）、布（2）：&#39;))</span><br><span class="line">chinese &#x3D; &quot;剪刀&quot;</span><br><span class="line">if user &#x3D;&#x3D; 1 and user !&#x3D; 0:</span><br><span class="line">    chinese &#x3D; &quot;石头&quot;</span><br><span class="line">else:</span><br><span class="line">    chinese &#x3D; &quot;布&quot;</span><br><span class="line">print(&quot;你的输入为%s（%d）&quot;%(chinese,user))</span><br><span class="line"># 电脑</span><br><span class="line">computer &#x3D; random.randint(0,2)</span><br><span class="line">print(&quot;随机生成数字为%d&quot;%computer)</span><br><span class="line"># 判断输赢</span><br><span class="line">if user &#x3D;&#x3D; 0:</span><br><span class="line">    if computer &#x3D;&#x3D; 1:</span><br><span class="line">        print(&quot;哈哈，你输了&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;这次不算，再来一次吧&quot;)</span><br><span class="line">elif user &#x3D;&#x3D; 1:</span><br><span class="line">    if computer &gt; user:</span><br><span class="line">        print(&quot;哈哈，你输了&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;这次不算，再来一次吧&quot;)</span><br><span class="line">elif user &#x3D;&#x3D; 2:</span><br><span class="line">    if computer &#x3D;&#x3D; 0:</span><br><span class="line">        print(&quot;哈哈，你输了&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;这次不算，再来一次吧&quot;)</span><br></pre></td></tr></table></figure>

<p><img src="/images/2020/08/03/9fccf378-bcd7-4e6b-b7c6-129587656eef.png" alt="image.png"></p>
<h1 id="用Python打印九九乘法表"><a href="#用Python打印九九乘法表" class="headerlink" title="用Python打印九九乘法表"></a>用Python打印九九乘法表</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i &#x3D; 1</span><br><span class="line">j &#x3D; 1</span><br><span class="line"></span><br><span class="line">while j &lt;&#x3D; i &lt; 10 and j &lt; 10:</span><br><span class="line">    print(&quot;%d*%d&#x3D;%d&quot; % (i, j, i*j), end&#x3D;&quot;\t&quot;)</span><br><span class="line">    if i &gt; j:</span><br><span class="line">        j +&#x3D; 1</span><br><span class="line">    else:               # i &#x3D;&#x3D; j</span><br><span class="line">        i +&#x3D; 1</span><br><span class="line">        j &#x3D; 1</span><br><span class="line">        print(&quot;\n&quot;)</span><br><span class="line">        continue</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m &#x3D; 1</span><br><span class="line">n &#x3D; 1</span><br><span class="line">i &#x3D; 1</span><br><span class="line">for i in range(45):</span><br><span class="line">    while m &lt; n:</span><br><span class="line">        m +&#x3D; 1</span><br><span class="line">        n &#x3D; 1</span><br><span class="line">        print(&quot;\n&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;%d*%d&#x3D;%d&quot; %(m, n, m*n), end&#x3D;&quot;\t&quot;)</span><br><span class="line">        n +&#x3D; 1</span><br></pre></td></tr></table></figure>

<p><img src="/images/2020/08/03/3b7b24d3-45f1-4198-b4c9-02461e81fd12.png" alt="image.png"></p>
<h1 id="用Python完成购物车简单操作"><a href="#用Python完成购物车简单操作" class="headerlink" title="用Python完成购物车简单操作"></a>用Python完成购物车简单操作</h1><p><img src="/images/2020/08/03/b825f626-9cf1-4973-8560-10afbc0085e0.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">products &#x3D; [[&quot;iphone&quot;, 6888], [&quot;MacPro&quot;, 14800], [&quot;小米6&quot;, 2499], [&quot;Coffee&quot;, 31], [&quot;Book&quot;, 60], [&quot;Nike&quot;, 699]]</span><br><span class="line"></span><br><span class="line">print(&quot;-&quot;*5, &quot;\t&quot;, &quot;商品列表&quot;, &quot;-&quot;*5)</span><br><span class="line"></span><br><span class="line">for i in range(6):</span><br><span class="line">    print(i, end&#x3D;&quot;\t&quot;)</span><br><span class="line">    print(products[i][0], end&#x3D;&quot;\t&quot;)</span><br><span class="line">    print(products[i][1])</span><br><span class="line"></span><br><span class="line">shopping_cart &#x3D; []</span><br><span class="line">sum_money &#x3D; 0</span><br><span class="line">while 1:</span><br><span class="line">    user &#x3D; input(&quot;请输入要购买的商品编号(q为结账)：&quot;)</span><br><span class="line">    if user !&#x3D; &quot;q&quot; and 0-1 &lt; int(user) &lt; 5+1:</span><br><span class="line">        user &#x3D; int(user)</span><br><span class="line">        shopping_cart.append(products[user][0])</span><br><span class="line">        sum_money +&#x3D; products[user][1]</span><br><span class="line">        print(&quot;请问还需要其他的商品吗？（q为结账）&quot;)</span><br><span class="line">    elif user &#x3D;&#x3D; &quot;q&quot;:</span><br><span class="line">        print(&quot;你购买的商品有：&quot;, end&#x3D;&quot;&quot;)</span><br><span class="line">        for i in shopping_cart:</span><br><span class="line">            print(i,end&#x3D;&quot;、&quot;)</span><br><span class="line">        print(&quot;\b&quot;)</span><br><span class="line">        print(&quot;一共%d元，谢谢光临！&quot;%sum_money)</span><br><span class="line">        break</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;你输入的商品编号不存在，请重新输入&quot;)</span><br></pre></td></tr></table></figure>
<h1 id="用Python将多名人员分配进房间"><a href="#用Python将多名人员分配进房间" class="headerlink" title="用Python将多名人员分配进房间"></a>用Python将多名人员分配进房间</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line">girl &#x3D; [&quot;欧阳娜娜&quot;, &quot;杨幂&quot;, &quot;佘诗曼&quot;, &quot;迪丽热巴&quot;, &quot;钟嘉欣&quot;]</span><br><span class="line">room &#x3D; [[], [], []]</span><br><span class="line"></span><br><span class="line">print(&quot;你旗下的女艺人有&quot;,end&#x3D;&quot;&quot;)</span><br><span class="line">for girl_name in girl:</span><br><span class="line">    print(girl_name,end&#x3D;&quot;、&quot;)</span><br><span class="line">print(&quot;\b&quot;)</span><br><span class="line"></span><br><span class="line"># 邀请女孩进房间</span><br><span class="line">for girl_name in girl:</span><br><span class="line">    number &#x3D; random.randint(0,2)</span><br><span class="line">    room[number].append(girl_name)</span><br><span class="line"></span><br><span class="line">roomA_len &#x3D; len(room[0])</span><br><span class="line">roomB_len &#x3D; len(room[1])</span><br><span class="line">roomC_len &#x3D; len(room[2])</span><br><span class="line"></span><br><span class="line">print(&quot;你好，我是客服伊兹！\n请输入以下命令进行查询\na代表打印所有房间信息；b代表查询房间号；c代表查询女艺人&quot;)</span><br><span class="line">print(&quot;-&quot;*50)</span><br><span class="line">order &#x3D; input(&quot;请输入命令：&quot;)</span><br><span class="line"></span><br><span class="line">if order &#x3D;&#x3D; &quot;a&quot;:</span><br><span class="line">    d &#x3D; 0</span><br><span class="line">    for i in range(0,2+1):</span><br><span class="line">        if i &#x3D;&#x3D; 0:</span><br><span class="line">            print(&quot;房间%d有%d人&quot;%(i,roomA_len))</span><br><span class="line">            if roomA_len !&#x3D; 0:</span><br><span class="line">                print(&quot;名字为&quot;,end&#x3D;&quot;&quot;)</span><br><span class="line">                for i in room[i]:</span><br><span class="line">                    print(i,end&#x3D;&quot;、&quot;)</span><br><span class="line">                print(&quot;\b&quot;)</span><br><span class="line">            print(&quot;*&quot;*50)</span><br><span class="line">        if i &#x3D;&#x3D; 1:</span><br><span class="line">            print(&quot;房间%d有%d人&quot;%(i,roomB_len))</span><br><span class="line">            if roomB_len !&#x3D; 0:</span><br><span class="line">                print(&quot;名字为&quot;, end&#x3D;&quot;&quot;)</span><br><span class="line">                for i in room[i]:</span><br><span class="line">                    print(i, end&#x3D;&quot;、&quot;)</span><br><span class="line">                print(&quot;\b&quot;)</span><br><span class="line">            print(&quot;*&quot; * 50)</span><br><span class="line">        if i &#x3D;&#x3D; 2:</span><br><span class="line">            print(&quot;房间%d有%d人&quot;%(i,roomC_len))</span><br><span class="line">            if roomC_len !&#x3D; 0:</span><br><span class="line">                print(&quot;名字为&quot;, end&#x3D;&quot;&quot;)</span><br><span class="line">                for i in room[i]:</span><br><span class="line">                    print(i, end&#x3D;&quot;、&quot;)</span><br><span class="line">                print(&quot;\b&quot;)</span><br><span class="line">            print(&quot;*&quot; * 50)</span><br><span class="line"></span><br><span class="line">elif order &#x3D;&#x3D; &quot;b&quot;:</span><br><span class="line">    room_number &#x3D; int(input(&quot;请输入你要查询的房间号：&quot;))</span><br><span class="line">    print(&quot;-&quot; * 50)</span><br><span class="line">    print(&quot;该房间一共有%d人&quot; % len(room[room_number]))</span><br><span class="line">    if len(room[room_number]) !&#x3D; 0:</span><br><span class="line">        print(&quot;名字为&quot;,end&#x3D;&quot;&quot;)</span><br><span class="line">    for i in room[room_number]:</span><br><span class="line">        print(i,end&#x3D;&quot;、&quot;)</span><br><span class="line">    print(&quot;\b&quot;)</span><br><span class="line"></span><br><span class="line">elif order &#x3D;&#x3D; &quot;c&quot;:</span><br><span class="line">    name &#x3D; input(&quot;请输入你要查询的女艺人名字:&quot;)</span><br><span class="line">    print(&quot;-&quot; * 50)</span><br><span class="line">    save &#x3D; 100</span><br><span class="line">    if name in room[0]:</span><br><span class="line">        save &#x3D; 0</span><br><span class="line">    elif name in room[1]:</span><br><span class="line">        save &#x3D; 1</span><br><span class="line">    elif name in room[2]:</span><br><span class="line">        save &#x3D; 2</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;抱歉，这位女士她不在我们的房间内入住&quot;)</span><br><span class="line">    if save &lt;&#x3D; 2:</span><br><span class="line">        print(&quot;她在%d号房间&quot;%save)</span><br><span class="line">    else:</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/08/03/f840b026-307e-4052-9b76-a9564a5425e7.png" alt="image.png"></p>
<h1 id="用Python完成新建文档写古诗-复制"><a href="#用Python完成新建文档写古诗-复制" class="headerlink" title="用Python完成新建文档写古诗+复制"></a>用Python完成新建文档写古诗+复制</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 写古诗</span><br><span class="line">f &#x3D; open(&quot;gushi.txt&quot;, &quot;w&quot;, encoding&#x3D;&quot;utf-8&quot;)</span><br><span class="line">f.write(&quot;&quot;&quot;</span><br><span class="line">        静夜思</span><br><span class="line">         李白</span><br><span class="line"> 床前明月光，疑是地上霜。</span><br><span class="line"> 举头望明月，低头思故乡。&quot;&quot;&quot;)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"># 复制</span><br><span class="line">f &#x3D; open(&quot;gushi.txt&quot;, &quot;r&quot;, encoding&#x3D;&quot;utf-8&quot;)</span><br><span class="line">m &#x3D; open(&quot;copy.txt&quot;, &quot;w&quot;, encoding&#x3D;&quot;utf-8&quot;)</span><br><span class="line"></span><br><span class="line">content &#x3D; f.readlines()</span><br><span class="line">for i in content:</span><br><span class="line">    m.write(i)</span><br><span class="line">f.close()</span><br><span class="line">m.close()</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/08/03/81ac9c74-cf97-45f9-a41c-e0196fcfbf3c.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>豆瓣top250</title>
    <url>/%E8%B1%86%E7%93%A3top250.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># encoding:utf-8</span><br><span class="line"># !&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># @author:wei</span><br><span class="line"># @file: spider.py</span><br><span class="line"># @time: 2020&#x2F;07&#x2F;16</span><br><span class="line">from bs4 import BeautifulSoup  # 网页解析，获取数据</span><br><span class="line">import re  # 正则表达式</span><br><span class="line">import urllib.request, urllib.error  # 制定url，获取网页数据</span><br><span class="line">import xlwt  # 进行excel操作</span><br><span class="line">import sqlite3  # 进行Sqlite 数据库操作</span><br><span class="line"></span><br><span class="line">findLink &#x3D; re.compile(r&#39;&lt;a href&#x3D;&quot;(.*)&quot;&gt;&#39;)  # 创建正则表达式，表示规则 获取电影链接</span><br><span class="line">findImg &#x3D; re.compile(r&#39;&lt;img.*src&#x3D;&quot;(.*?)&quot;&#39;, re.S)  # 影片图片地址</span><br><span class="line">findTitle &#x3D; re.compile(r&#39;&lt;span class&#x3D;&quot;title&quot;&gt;(.*)&lt;&#x2F;span&gt;&#39;)  # 电影名</span><br><span class="line">findRating &#x3D; re.compile(r&#39;&lt;span class&#x3D;&quot;rating_num&quot; property&#x3D;&quot;v:average&quot;&gt;(.*)&lt;&#x2F;span&gt;&#39;)  # 评分</span><br><span class="line">findJudge &#x3D; re.compile(r&#39;&lt;span&gt;(\d*)人评价&lt;&#x2F;span&gt;&#39;)  # 评价人数</span><br><span class="line">findInq &#x3D; re.compile(r&#39;&lt;span class&#x3D;&quot;inq&quot;&gt;(.*)。&lt;&#x2F;span&gt;&#39;)  # 找到概况</span><br><span class="line">findBd &#x3D; re.compile(r&#39;&lt;p class&#x3D;&quot;&quot;&gt;(.*?)&lt;&#x2F;p&gt;&#39;, re.S)  # 电影描述</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># url&#x3D;&quot;https:&#x2F;&#x2F;movie.douban.com&#x2F;top250?start&#x3D;&quot;</span><br><span class="line">def getData(baseurl):</span><br><span class="line">    # 1爬取网页</span><br><span class="line">    datalist &#x3D; []</span><br><span class="line">    for i in range(0, 10):</span><br><span class="line">        url &#x3D; baseurl + str(i * 25)</span><br><span class="line">        html &#x3D; askUrl(url)  # 保存获取的网页</span><br><span class="line">        # 2逐一解析</span><br><span class="line">        soup &#x3D; BeautifulSoup(html, &quot;html.parser&quot;)</span><br><span class="line"></span><br><span class="line">        for item in soup.findAll(&#39;div&#39;, class_&#x3D;&quot;item&quot;):</span><br><span class="line">            # print(item) #测试获取item</span><br><span class="line">            data &#x3D; []  # 保存一部电影item全部信息</span><br><span class="line">            item &#x3D; str(item)</span><br><span class="line">            link_item_ &#x3D; re.findall(findLink, item)[0]</span><br><span class="line">            data.append(link_item_)</span><br><span class="line">            img_item_ &#x3D; re.findall(findImg, item)[0]</span><br><span class="line">            data.append(img_item_)</span><br><span class="line">            title_item_ &#x3D; re.findall(findTitle, item)</span><br><span class="line">            if len(title_item_) &#x3D;&#x3D; 2:</span><br><span class="line">                data.append(title_item_[0])</span><br><span class="line">                data.append(title_item_[1].replace(&quot;&#x2F;&quot;, &quot;&quot;))</span><br><span class="line">            else:</span><br><span class="line">                data.append(title_item_[0])</span><br><span class="line">                data.append(&quot;&quot;)</span><br><span class="line">            rating_item_ &#x3D; re.findall(findRating, item)[0]</span><br><span class="line">            data.append(rating_item_)</span><br><span class="line">            judge_item_ &#x3D; re.findall(findJudge, item)</span><br><span class="line">            data.append(judge_item_)</span><br><span class="line">            inq_item_ &#x3D; re.findall(findInq, item)</span><br><span class="line">            if len(inq_item_) !&#x3D; 0:</span><br><span class="line">                inq_item_ &#x3D; inq_item_[0].replace(&quot;。&quot;, &quot;&quot;)  # 去掉中文句号</span><br><span class="line">                data.append(inq_item_)</span><br><span class="line">            else:</span><br><span class="line">                data.append(&quot;&quot;)  # 留空</span><br><span class="line">            bd_item_ &#x3D; re.findall(findBd, item)[0]</span><br><span class="line">            bd_item_ &#x3D; re.sub(&#39;&lt;br(\s)?&#x2F;&gt;&#39;, &quot; &quot;, bd_item_)  # 去掉br</span><br><span class="line">            bd_item_ &#x3D; re.sub(&#39;&#x2F;&#39;, &quot; &quot;, bd_item_)  # 去掉&#x2F;</span><br><span class="line">            data.append(bd_item_)</span><br><span class="line">            datalist.append(data)  # 把处理好的一部电影放入datalist</span><br><span class="line">    return datalist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 访问网页</span><br><span class="line">def askUrl(url):</span><br><span class="line">    headers &#x3D; &#123;</span><br><span class="line">        &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;83.0.4103.116 Safari&#x2F;537.36&quot;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    req &#x3D; urllib.request.Request(url&#x3D;url, headers&#x3D;headers)</span><br><span class="line">    html &#x3D; urllib.request.urlopen(req)</span><br><span class="line">    # print(response.read().decode(&quot;utf-8&quot;))</span><br><span class="line">    return html</span><br><span class="line">def saveData(datalist,saveUrl):</span><br><span class="line">    print(&quot;save...&quot;)</span><br><span class="line">    book&#x3D;xlwt.Workbook(encoding&#x3D;&quot;utf-8&quot;,style_compression&#x3D;0)#创建Workbook对象</span><br><span class="line">    sheet&#x3D;book.add_sheet(&#39;豆瓣电影Top250&#39;,cell_overwrite_ok&#x3D;True)#创建工作表</span><br><span class="line">    col&#x3D;(&quot;电影链接&quot;,&quot;图片链接&quot;,&quot;影片中文名&quot;,&quot;影片英文名&quot;,&quot;评分&quot;,&quot;评价数&quot;,&quot;概况&quot;,&quot;相关信息&quot;)</span><br><span class="line">    for i in range(0,8):</span><br><span class="line">        sheet.write(0,i,col[i])#列名</span><br><span class="line">    for i in range(0,250):</span><br><span class="line">        print(&quot;第%d条&quot;%(i+1))</span><br><span class="line">        data &#x3D; datalist[i]</span><br><span class="line">        for j in range(0,8):</span><br><span class="line">            sheet.write(i+1,j,data[j]) #保存每行每列的数据</span><br><span class="line">    book.save(saveUrl)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    url &#x3D; &quot;https:&#x2F;&#x2F;movie.douban.com&#x2F;top250?start&#x3D;&quot;</span><br><span class="line">    datalist &#x3D; getData(url)</span><br><span class="line">    # print(data)</span><br><span class="line">    saveUrl &#x3D; &quot;豆瓣电影Top250.xls&quot;</span><br><span class="line">    #保存数据</span><br><span class="line">    saveData(datalist,saveUrl)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br><span class="line">    print(&quot;爬取完毕...&quot;)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/08/03/1adeb491-5a26-42e7-9561-4f035a0d185a.png" alt="image.png"><br><img src="/images/2020/08/03/13b221c4-c709-447e-ad9f-c919c7476d04.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>爬取小说</title>
    <url>/%E7%88%AC%E5%8F%96%E5%B0%8F%E8%AF%B4.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;&#39;&#39;</span><br><span class="line">    此程序用于下载笔趣阁（网址：https:&#x2F;&#x2F;www.duquanben.com&#x2F;book&#x2F;monthvisit&#x2F;0&#x2F;1&#x2F;）</span><br><span class="line">    月排行榜的小说（按页下载）</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">from bs4 import BeautifulSoup     #网页解析，获取数据</span><br><span class="line">import re       #正则表达式，进行文字匹配</span><br><span class="line">import urllib.request,urllib.error      #制定url，获取网页数据</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    baseurl &#x3D; &quot;https:&#x2F;&#x2F;www.duquanben.com&#x2F;book&#x2F;monthvisit&#x2F;0&#x2F;&quot;</span><br><span class="line"></span><br><span class="line">    #1.爬取网页</span><br><span class="line">    datalist &#x3D; getData(baseurl)</span><br><span class="line"></span><br><span class="line">    #3.保存数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#小说链接</span><br><span class="line">findLink &#x3D; re.compile(&#39;&lt;a href&#x3D;&quot;(.*?)&quot; target&#x3D;&quot;_blank&quot;&gt;&#39;)</span><br><span class="line">#小说名字</span><br><span class="line">findTitle &#x3D; re.compile(&#39;&lt;li class&#x3D;&quot;two&quot;&gt;&lt;a href&#x3D;&quot;.*?&quot; target&#x3D;&quot;_blank&quot;&gt;(.*?)全文阅读&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;)</span><br><span class="line">#章节链接</span><br><span class="line">findChapter &#x3D; re.compile(&#39;&lt;a href&#x3D;&quot;(.*?)&quot;&gt;&#39;)</span><br><span class="line">#章节名字</span><br><span class="line">findChName &#x3D; re.compile(&#39;&lt;li&gt;&lt;a href&#x3D;&quot;.*?&quot;&gt;(.*?)&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;)</span><br><span class="line">#小说内容</span><br><span class="line">findTxt &#x3D; re.compile(&#39;&lt;div id&#x3D;&quot;htmlContent&quot; class&#x3D;&quot;contentbox&quot; style&#x3D;&quot;font-size: 20px; color: rgb(0, 0, 0);&quot;&gt;(.*?)&lt;&#x2F;div&gt;&#39;)</span><br><span class="line">#爬取网页</span><br><span class="line">def getData(baseurl):</span><br><span class="line">    #一.爬取小说排行</span><br><span class="line">    datalist &#x3D; []</span><br><span class="line">    x &#x3D; 0       #小说标题计数</span><br><span class="line">    for i in range(0,1):                #下载的页数[开始页数，结束页数)</span><br><span class="line">        url1 &#x3D; baseurl +str(i+1)        #排行页面链接</span><br><span class="line">        html1 &#x3D; askURL(url1)</span><br><span class="line">        # print(html)</span><br><span class="line">    #2.1 解析数据</span><br><span class="line">        soup1 &#x3D; BeautifulSoup(html1,&quot;html.parser&quot;)</span><br><span class="line">        for item in soup1.find_all(&#39;li&#39;,class_&#x3D;&quot;two&quot;):</span><br><span class="line">             # print(item)</span><br><span class="line">            data &#x3D; []       #保存一部小说的链接以及名字</span><br><span class="line">            item &#x3D; str(item)</span><br><span class="line"></span><br><span class="line">            #获取小说链接</span><br><span class="line">            link &#x3D; re.findall(findLink,item)</span><br><span class="line">            data.append(link)   #保存小说链接</span><br><span class="line">            titles &#x3D; re.findall(findTitle,item)</span><br><span class="line">            titles &#x3D; str(titles)</span><br><span class="line">            titles &#x3D; titles.strip(&quot;[&quot;)  # 去掉[</span><br><span class="line">            titles &#x3D; titles.rstrip(&quot;]&quot;)  # 去掉]</span><br><span class="line">            titles &#x3D; re.sub(&quot; &quot;, &quot;&quot;, titles)  # 去掉空格</span><br><span class="line">            titles &#x3D; re.sub(&quot;\&#39;&quot;, &quot;&quot;, titles)  # 去掉多余的”</span><br><span class="line">            if(titles &#x3D;&#x3D; &#39;&#39;):continue</span><br><span class="line">            # print(titles)         #测试小说名字</span><br><span class="line">            data.append(titles)     #保存小说名字</span><br><span class="line">            datalist.append(data)</span><br><span class="line">    # print(datalist)       #测试小说排行</span><br><span class="line"></span><br><span class="line">    #二 .爬取小说章节</span><br><span class="line">    # i &#x3D; 1</span><br><span class="line">    for data in datalist:</span><br><span class="line">        url2 &#x3D; data[0]       #小说页面链接</span><br><span class="line">        url2 &#x3D; str(url2)</span><br><span class="line">        url2 &#x3D; url2.strip(&quot;[&quot;)          #去掉[</span><br><span class="line">        url2 &#x3D; url2.rstrip(&quot;]&quot;)         #去掉]</span><br><span class="line">        # url2 &#x3D; url2.strip()</span><br><span class="line">        # url2 &#x3D; url2.rstrip()</span><br><span class="line">        url2 &#x3D; re.sub(&quot; &quot;,&quot;&quot;,url2)      #去掉空格</span><br><span class="line">        url2 &#x3D; re.sub(&quot;\&#39;&quot;,&quot;&quot;,url2)     #去掉多余的”</span><br><span class="line">        if(url2 &#x3D;&#x3D; &quot;&quot;):continue</span><br><span class="line">        # print(&quot;%d : &quot;%i+url2)</span><br><span class="line">        # i &#x3D; i +1</span><br><span class="line">        #test : 多了“ “ 导致无法找到适配器</span><br><span class="line">        # html2 &#x3D; askURL(&quot;https:&#x2F;&#x2F;www.duquanben.com&#x2F;xiaoshuo&#x2F;28&#x2F;28536&#x2F;&quot;)</span><br><span class="line">        # url &#x3D; &quot;https:&#x2F;&#x2F;www.duquanben.com&#x2F;xiaoshuo&#x2F;28&#x2F;28536&#x2F;&quot;</span><br><span class="line">        # if(url &#x3D;&#x3D; url2):print(&quot;same&quot;)</span><br><span class="line">        # else:print(&quot;NO same&quot;)</span><br><span class="line">        # print(&quot;url:&quot;,url)</span><br><span class="line">        # print(&quot;url2:&quot;,url2)</span><br><span class="line">        html2 &#x3D; askURL(url2)</span><br><span class="line"></span><br><span class="line">        #2.2解析数据</span><br><span class="line">        soup2 &#x3D; BeautifulSoup(html2,&quot;html.parser&quot;)</span><br><span class="line">        datalist2 &#x3D; []</span><br><span class="line">        for item in soup2.find_all(&quot;li&quot;):</span><br><span class="line">            # print(item)</span><br><span class="line">            data2&#x3D;[]        #保存章节名以及链接</span><br><span class="line">            item &#x3D; str(item)</span><br><span class="line"></span><br><span class="line">            #获取章节链接</span><br><span class="line">            ChapterLink &#x3D;str(re.findall(findChapter,item))</span><br><span class="line">            ChapterLink &#x3D; ChapterLink.strip(&quot;[&quot;)  # 去掉[</span><br><span class="line">            ChapterLink &#x3D; ChapterLink.rstrip(&quot;]&quot;)  # 去掉]</span><br><span class="line">            if ChapterLink &#x3D;&#x3D; &quot;&quot;:continue</span><br><span class="line">            ChapterLink &#x3D; re.sub(&quot;&#39;&quot;,&quot;&quot;,ChapterLink)</span><br><span class="line">            ChapterLink &#x3D; url2 + ChapterLink    #获得章节完整链接</span><br><span class="line">            data2.append(ChapterLink)</span><br><span class="line"></span><br><span class="line">            #获取章节名字</span><br><span class="line">            chName &#x3D; re.findall(findChName,item)</span><br><span class="line">            chName &#x3D; str(chName)</span><br><span class="line">            chName &#x3D; chName.strip(&quot;[&quot;)</span><br><span class="line">            chName &#x3D; chName.strip(&quot;]&quot;)</span><br><span class="line">            chName &#x3D; re.sub(&quot;&#39;&quot;,&quot;&quot;,chName)</span><br><span class="line">            # print(chName)</span><br><span class="line">            data2.append(chName)</span><br><span class="line">            datalist2.append(data2)</span><br><span class="line">            # print(data2[1])</span><br><span class="line">        # print(datalist2)      #测试章节获取</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        # for data3 in datalist2:</span><br><span class="line">        #     name &#x3D; data3[1]</span><br><span class="line">        #     print(name)</span><br><span class="line">        # print(datalist2)</span><br><span class="line">        #三.爬取小说内容</span><br><span class="line">        z &#x3D; 0               #章节计数</span><br><span class="line">        print(&quot;第%d本&quot;%x+datalist[x][1])       #小说名字</span><br><span class="line">        for data in datalist2:</span><br><span class="line">            url3 &#x3D; data[0]      # 小说页面链接</span><br><span class="line">            url3 &#x3D; str(url3)</span><br><span class="line">            url3 &#x3D; url3.strip(&quot;[&quot;)  # 去掉[</span><br><span class="line">            url3 &#x3D; url3.rstrip(&quot;]&quot;)  # 去掉]</span><br><span class="line">            url3 &#x3D; re.sub(&quot; &quot;, &quot;&quot;, url3)  # 去掉空格</span><br><span class="line">            url3 &#x3D; re.sub(&quot;\&#39;&quot;, &quot;&quot;, url3)  # 去掉多余的”</span><br><span class="line">            if (url3 &#x3D;&#x3D; &quot;&quot;): continue</span><br><span class="line">            # print(&quot;%d:&quot;%i+url3)       #测试章节链接</span><br><span class="line">            html3 &#x3D; askURL(url3)</span><br><span class="line"></span><br><span class="line">            #2.3解析数据</span><br><span class="line">            soup3 &#x3D; BeautifulSoup(html3,&quot;html.parser&quot;)</span><br><span class="line">            # print(type(datalist2[1][1]))</span><br><span class="line">            for item in zip(soup3.find_all(&#39;div&#39;,class_&#x3D;&quot;contentbox&quot;)):  #得到小说一章的内容</span><br><span class="line">                item &#x3D; str(item)</span><br><span class="line">                item &#x3D; item.replace(&#39;&amp;nbsp;&#39;, &#39; &#39;)      #根据html规则手动转变文本</span><br><span class="line">                item &#x3D; item.replace(&#39;&lt;br&#x2F;&gt;&#39;, &#39;\n&#39;)</span><br><span class="line">                item &#x3D; item.replace(&#39;\n\n\n\n&#39;, &#39;\n&#39;)</span><br><span class="line">                item &#x3D; item.replace(&#39;,)&#39;,&#39;&#39;)</span><br><span class="line">                item &#x3D; re.sub(&#39;&lt;script.*?&gt;(.*?)&lt;&#x2F;script&gt;&#39;,&#39;&#39;,item)  #去掉多余内容</span><br><span class="line">                item &#x3D; re.sub(&#39;&lt;a .*?&gt;(.*?)&lt;&#x2F;a&gt;&#39;,&#39;&#39;,item)</span><br><span class="line">                item &#x3D; re.sub(r&#39;&lt;div .*?&gt;&#39;, &#39;&#39;, item)</span><br><span class="line">                item &#x3D; re.sub(r&#39;&lt;&#x2F;div&gt;&#39;, &#39;&#39;, item)</span><br><span class="line">                # print(item)     #测试小说内容</span><br><span class="line"></span><br><span class="line">                textTitle &#x3D; datalist2[z][1]</span><br><span class="line">                print(textTitle)      #测试章节名</span><br><span class="line">                z &#x3D; z + 1</span><br><span class="line">                item &#x3D; textTitle+&quot;\n&quot;+item</span><br><span class="line">                # print(item)      #测试整个章节</span><br><span class="line"></span><br><span class="line">                save(&quot;D:\小说\%s.txt&quot;%(datalist[x][1]),item)</span><br><span class="line"></span><br><span class="line">        x &#x3D; x + 1</span><br><span class="line">            # print(datalist3)</span><br><span class="line">            # break       #测试一章是否能打印成功</span><br><span class="line">        # break       #由于章节过多，循环一次进行测试</span><br><span class="line">#得到指定一个url的内容</span><br><span class="line"></span><br><span class="line">#保存小说</span><br><span class="line">def save(filename, contents):                       #（文件名，保存数据）</span><br><span class="line">    fh &#x3D; open(filename, &#39;a&#39;, encoding&#x3D;&#39;utf-8&#39;)      #在文本末尾写入</span><br><span class="line">    fh.write(contents)</span><br><span class="line">    fh.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def askURL(url):</span><br><span class="line">    head &#x3D;&#123;                     #模拟浏览器头部信息，向豆瓣服务器发送消息</span><br><span class="line">        &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;84.0.4147.89 Safari&#x2F;537.36&quot;</span><br><span class="line">    &#125;</span><br><span class="line">                            #用户代理表示告诉豆瓣服务器，我们是什么类型的机器&#x2F;浏览器（本质上是告诉浏览器，我们可以接受什么水平的文件）</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        r &#x3D; requests.get(url,headers&#x3D;head,timeout&#x3D;10)</span><br><span class="line">        # 如果状态不是200，引发HTTPError异常</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding &#x3D; r.apparent_encoding</span><br><span class="line">        # print(r.text)</span><br><span class="line">    except urllib.error.URLError as e:</span><br><span class="line">        if hasattr(e,&quot;code&quot;):</span><br><span class="line">            print(e.code)</span><br><span class="line">        if hasattr(e,&quot;reason&quot;):</span><br><span class="line">            print(e.reason)</span><br><span class="line">        print(&quot;产生异常&quot;)</span><br><span class="line">    # print(r.text)</span><br><span class="line">    return r.text</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    print(&quot;开始爬取......&quot;)</span><br><span class="line">    main()</span><br><span class="line">    print(&quot;爬取成功！&quot;)</span><br></pre></td></tr></table></figure>

<p><img src="/images/2020/08/03/39d371b6-7225-4d04-ad64-fda07c0d6728.png" alt="image.png"><br><img src="/images/2020/08/03/83e91688-7cba-4c19-bb07-938f4498346f.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>拉勾网325个城市任意职位爬取</title>
    <url>/%E6%8B%89%E5%8B%BE%E7%BD%91325%E4%B8%AA%E5%9F%8E%E5%B8%82%E4%BB%BB%E6%84%8F%E8%81%8C%E4%BD%8D%E7%88%AC%E5%8F%96.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"># @Time : 2020&#x2F;8&#x2F;3 12:55</span><br><span class="line"># @Author : zc</span><br><span class="line"># @File : config.py</span><br><span class="line"># @software : PyCharm</span><br><span class="line">from urllib.parse import urlencode</span><br><span class="line">import requests</span><br><span class="line">from pyquery import PyQuery as pq</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">包含信息：</span><br><span class="line">1、代理池获取网址</span><br><span class="line">2、需要爬取的城市以及此城市招聘的网页链接</span><br><span class="line">3、请求网页时的五个信息，request_url,referer_url,headers,params,data</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">PROXY_POOL_URL &#x3D; &#39;http:&#x2F;&#x2F;127.0.0.1:5555&#x2F;random&#39; # 获取代理池的网址</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BaseInfo(object):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    获取所有城市，以及城市的链接</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.url &#x3D; &#39;https:&#x2F;&#x2F;www.lagou.com&#x2F;jobs&#x2F;allCity.html?&#39;</span><br><span class="line">        self.params &#x3D; &#123;</span><br><span class="line">            &#39;keyword&#39;: &#39;java&#39;,</span><br><span class="line">            &#39;px&#39;: &#39;default&#39;,</span><br><span class="line">            &#39;positionNum&#39;: 500,</span><br><span class="line">            &#39;companyNum&#39;: 0,</span><br><span class="line">            &#39;isCompanySelected&#39;: &#39;false&#39;,</span><br><span class="line">            &#39;labelWords&#39;:&#39;&#39;</span><br><span class="line">        &#125;</span><br><span class="line">        self.headers &#x3D; &#123;</span><br><span class="line">            &#39;user-agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;76.0.3809.87 Safari&#x2F;537.36&#39;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    def get_cities(self):</span><br><span class="line">        response &#x3D; requests.get(url&#x3D;self.url,headers&#x3D;self.headers,params&#x3D;self.params).text</span><br><span class="line">        doc &#x3D; pq(response)</span><br><span class="line">        infos &#x3D; doc(&#39;.city_list li&#39;)</span><br><span class="line">        datalist &#x3D; []</span><br><span class="line">        data &#x3D; &#123;&#125;</span><br><span class="line">        for info in infos.items():</span><br><span class="line">            city &#x3D; info(&#39;a&#39;).text()</span><br><span class="line">            referer_url &#x3D; info(&#39;.dn&#39;).attr(&#39;value&#39;)</span><br><span class="line">            a &#x3D; urlencode(&#123;city:city&#125;).split(&#39;&#x3D;&#39;)[1]</span><br><span class="line">            referer_url &#x3D; referer_url.replace(city,a)</span><br><span class="line">            data[city] &#x3D; referer_url</span><br><span class="line">            datalist.append(data)</span><br><span class="line">            data &#x3D; &#123;&#125;</span><br><span class="line">        print(&#39;将要爬取的城市数量:&#123;&#125;&#39;.format(len(datalist)))</span><br><span class="line">        return datalist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r &#x3D; BaseInfo()</span><br><span class="line">DATALIST &#x3D; r.get_cities() # 以列表形式得到所有 城市及链接 每个元素都是一个字典</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R_URL &#x3D; &#39;https:&#x2F;&#x2F;www.lagou.com&#x2F;jobs&#x2F;positionAjax.json?&#39;  # request_url 前半部分</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ChangeItem(object):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    请求内容中的可变项</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self,city,referer_url,job):</span><br><span class="line">        self.referer_url &#x3D; referer_url  # 跳转源</span><br><span class="line">        self.params &#x3D; &#123;</span><br><span class="line">            &#39;px&#39;: &#39;default&#39;,</span><br><span class="line">            &#39;city&#39;: city,</span><br><span class="line">            &#39;needAddtionalResult&#39;: &#39;false&#39;</span><br><span class="line">        &#125;</span><br><span class="line">        self.headers &#x3D; &#123;</span><br><span class="line">            &#39;accept&#39;: &#39;application&#x2F;json, text&#x2F;javascript, *&#x2F;*; q&#x3D;0.01&#39;,</span><br><span class="line">            &#39;origin&#39;: &#39;https:&#x2F;&#x2F;www.lagou.com&#39;,</span><br><span class="line">            &#39;content-type&#39;: &#39;application&#x2F;x-www-form-urlencoded; charset&#x3D;UTF-8&#39;,</span><br><span class="line">            &#39;referer&#39;: referer_url,</span><br><span class="line">            &#39;user-agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;76.0.3809.87 Safari&#x2F;537.36&#39;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        self.page &#x3D; 1</span><br><span class="line">        self.job &#x3D; job</span><br><span class="line"></span><br><span class="line">    def get_referer_url(self):</span><br><span class="line">        return self.referer_url</span><br><span class="line"></span><br><span class="line">    def get_params(self):</span><br><span class="line">        return self.params</span><br><span class="line"></span><br><span class="line">    def get_headers(self):</span><br><span class="line">        return self.headers</span><br><span class="line"></span><br><span class="line">    def get_data(self):</span><br><span class="line">        return &#123;&#39;first&#39;: &#39;true&#39;,&#39;pn&#39;: self.page,&#39;kd&#39;: self.job&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/08/03/0bf35dca-ca74-45ad-8b7c-4167c3cdd80f.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"># @Time : 2020&#x2F;8&#x2F;3 12:26</span><br><span class="line"># @Author : zc</span><br><span class="line"># @File : GainProxy</span><br><span class="line"># @software : PyCharm</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class GainProxy(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self,proxy_pool_url):</span><br><span class="line">        self.proxy_pool_url &#x3D; proxy_pool_url</span><br><span class="line"></span><br><span class="line">    def gain_proxy(self):</span><br><span class="line">        try:</span><br><span class="line">            response &#x3D; requests.get(self.proxy_pool_url)</span><br><span class="line">            if response.status_code &#x3D;&#x3D; 200:</span><br><span class="line">                return &#39;http:&#x2F;&#x2F;&#39; + response.text</span><br><span class="line">            return None</span><br><span class="line">        except ConnectionError:</span><br><span class="line">            return None</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/08/03/5cb6bac9-93c1-4927-aef0-50bf797f4952.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"># @Time : 2020&#x2F;8&#x2F;3 12:30</span><br><span class="line"># @Author : zc</span><br><span class="line"># @File : GetOnePage</span><br><span class="line"># @software : PyCharm</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line">from post_lagou.GainProxy import GainProxy</span><br><span class="line">from post_lagou.config import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class GetOnePage(object):</span><br><span class="line">    a &#x3D; GainProxy(PROXY_POOL_URL)</span><br><span class="line"></span><br><span class="line">    def __init__(self, r_url, referer_url, headers, params, data):</span><br><span class="line">        self.proxy &#x3D; None</span><br><span class="line">        self.r_url &#x3D; r_url</span><br><span class="line">        self.referer_url &#x3D; referer_url</span><br><span class="line">        self.headers &#x3D; headers</span><br><span class="line">        self.params &#x3D; params</span><br><span class="line">        self.data &#x3D; data</span><br><span class="line">        self.max_count &#x3D; 5</span><br><span class="line">        self.count &#x3D; 1</span><br><span class="line"></span><br><span class="line">    def get_page(self):</span><br><span class="line">        s &#x3D; requests.Session()</span><br><span class="line"></span><br><span class="line">        if self.count &gt; self.max_count:</span><br><span class="line">            print(&#39;尝试获取页面超过&#123;&#125;次，尝试结束！&#39;.format(self.max_count))</span><br><span class="line">            return None</span><br><span class="line"></span><br><span class="line">        try:</span><br><span class="line">            if self.proxy:</span><br><span class="line">                print(&#39;正在使用代理：&#123;&#125;&#39;.format(self.proxy))</span><br><span class="line">                proxies &#x3D; &#123;&#39;http&#39;: self.proxy&#125;</span><br><span class="line">                s.get(url&#x3D;self.referer_url, headers&#x3D;self.headers, proxies&#x3D;proxies)</span><br><span class="line">                response &#x3D; s.post(url&#x3D;self.r_url, headers&#x3D;self.headers, data&#x3D;self.data, params&#x3D;self.params,</span><br><span class="line">                                  proxies&#x3D;proxies)</span><br><span class="line">            else:</span><br><span class="line"></span><br><span class="line">                s.get(url&#x3D;self.referer_url, headers&#x3D;self.headers)</span><br><span class="line">                response &#x3D; s.post(url&#x3D;self.r_url, headers&#x3D;self.headers, data&#x3D;self.data, params&#x3D;self.params)</span><br><span class="line"></span><br><span class="line">            if response.status_code &#x3D;&#x3D; 200:</span><br><span class="line">                return response</span><br><span class="line">            else:</span><br><span class="line">                self.proxy &#x3D; self.a.gain_proxy()</span><br><span class="line">                if self.proxy:</span><br><span class="line">                    return self.get_page()</span><br><span class="line">                else:</span><br><span class="line">                    print(&#39;获取代理失败！&#39;)</span><br><span class="line">                    return None</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&#39;获取页面信息失败，失败原因:&#123;&#125;&#39;.format(e.args))</span><br><span class="line">            self.proxy &#x3D; self.a.gain_proxy()</span><br><span class="line">            self.count +&#x3D; 1</span><br><span class="line">            return self.get_page()</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/08/03/864899f6-0550-437c-8673-47f553b89582.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"># @Time : 2020&#x2F;8&#x2F;3 12:54</span><br><span class="line"># @Author : zc</span><br><span class="line"># @File : run.py</span><br><span class="line"># @software : PyCharm</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">from post_lagou.config import *</span><br><span class="line">from post_lagou.GetOnePage import GetOnePage</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class PostLaGou(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self,referer_url,headers,params,req_data):</span><br><span class="line">        self.r_url &#x3D; R_URL</span><br><span class="line">        self.referer_url &#x3D; referer_url</span><br><span class="line">        self.headers &#x3D; headers</span><br><span class="line">        self.params &#x3D; params</span><br><span class="line">        self.data &#x3D; req_data</span><br><span class="line"></span><br><span class="line">    def get_page(self):</span><br><span class="line">        resp &#x3D; GetOnePage(r_url&#x3D;self.r_url,referer_url&#x3D;self.referer_url,headers&#x3D;self.headers,params&#x3D;self.params,data&#x3D;self.data)</span><br><span class="line">        response &#x3D; resp.get_page()</span><br><span class="line">        if response:</span><br><span class="line">            return response.json()</span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line">    def parse_page(self,r,j_city):</span><br><span class="line">        infos &#x3D; r[&#39;content&#39;][&#39;positionResult&#39;][&#39;result&#39;]</span><br><span class="line">        datalist &#x3D; []</span><br><span class="line">        data &#x3D; &#123;&#125;</span><br><span class="line">        for info in infos:</span><br><span class="line">            data[&#39;positionName&#39;] &#x3D; info[&#39;positionName&#39;]</span><br><span class="line">            data[&#39;companyFullName&#39;] &#x3D; info[&#39;companyFullName&#39;]</span><br><span class="line">            data[&#39;companyShortName&#39;] &#x3D; info[&#39;companyShortName&#39;]</span><br><span class="line">            data[&#39;companySize&#39;] &#x3D; info[&#39;companySize&#39;]</span><br><span class="line">            data[&#39;city&#39;] &#x3D; info[&#39;city&#39;]</span><br><span class="line">            data[&#39;district&#39;] &#x3D; info[&#39;district&#39;]</span><br><span class="line">            data[&#39;salary&#39;] &#x3D; info[&#39;salary&#39;]</span><br><span class="line">            data[&#39;workYear&#39;] &#x3D; info[&#39;workYear&#39;]</span><br><span class="line">            data[&#39;education&#39;] &#x3D; info[&#39;education&#39;]</span><br><span class="line">            if j_city not in &#39;北京上海广州深圳&#39;:</span><br><span class="line">                if info[&#39;city&#39;] in &#39;北京上海广州深圳&#39;:</span><br><span class="line">                    return datalist</span><br><span class="line">            print(data)</span><br><span class="line">            datalist.append(data)</span><br><span class="line">        return datalist</span><br><span class="line"></span><br><span class="line">    def save_data(self,datalist):</span><br><span class="line">        with open(&#39;lagou.txt&#39;,&#39;w&#39;) as f:</span><br><span class="line">            f.write(json.dumps(datalist))</span><br><span class="line"></span><br><span class="line">    def mian(self, j_city):</span><br><span class="line">        r &#x3D; self.get_page()</span><br><span class="line">        datalist &#x3D; self.parse_page(r,j_city)</span><br><span class="line">        if datalist:</span><br><span class="line">            self.save_data(datalist)</span><br><span class="line">            return datalist</span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    job &#x3D; input(&#39;请输入想要爬取的职位：&#39;)</span><br><span class="line">    for data in DATALIST:</span><br><span class="line">        for k in data.keys():</span><br><span class="line">            v &#x3D; data[k]</span><br><span class="line">            print(&#39;正在获取&#123;&#125;的信息！&#39;.format(k))</span><br><span class="line">            print(&#39;链接：&#123;&#125;&#39;.format(v))</span><br><span class="line">            r &#x3D; ChangeItem(k,v,job)</span><br><span class="line">            print(k,v,sep&#x3D;&#39;|&#39;)</span><br><span class="line"></span><br><span class="line">            while True:</span><br><span class="line">                print(&#39;正在打印第&#123;&#125;页！&#39;.format(r.page))</span><br><span class="line">                run &#x3D; PostLaGou(r.get_referer_url(),r.get_headers(),r.get_params(),r.get_data())</span><br><span class="line">                result &#x3D; run.mian(k)</span><br><span class="line">                r.page +&#x3D; 1</span><br><span class="line">                if not result:</span><br><span class="line">                    print(&#39;超出最大页码，此城市爬取完毕！&#39;)</span><br><span class="line">                    break</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/08/03/894bfcff-4bb8-4174-915e-a25983107ba6.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"># @Time : 2020&#x2F;8&#x2F;2 20:05</span><br><span class="line"># @Author : zc</span><br><span class="line"># @File : text</span><br><span class="line"># @software : PyCharm</span><br><span class="line">import time</span><br><span class="line">from urllib.parse import urlencode</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_requests(url,data):</span><br><span class="line">    headers &#x3D; &#123;</span><br><span class="line">        &#39;accept&#39;: &#39;application&#x2F;json, text&#x2F;javascript, *&#x2F;*; q&#x3D;0.01&#39;,</span><br><span class="line">        &#39;origin&#39;: &#39;https:&#x2F;&#x2F;www.lagou.com&#39;,</span><br><span class="line">        &#39;content-type&#39;: &#39;application&#x2F;x-www-form-urlencoded; charset&#x3D;UTF-8&#39;,</span><br><span class="line">        &#39;referer&#39;: &#39;https:&#x2F;&#x2F;www.lagou.com&#x2F;jobs&#x2F;list_java&#x2F;p-city_3?px&#x3D;default&#39;,</span><br><span class="line">        &#39;user-agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;76.0.3809.87 Safari&#x2F;537.36&#39;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s &#x3D; requests.Session()</span><br><span class="line">    referer_url &#x3D; &#39;https:&#x2F;&#x2F;www.lagou.com&#x2F;jobs&#x2F;list_java&#x2F;p-city_3?px&#x3D;default&#39;</span><br><span class="line">    s.get(url&#x3D;referer_url,headers&#x3D;headers)</span><br><span class="line">    params &#x3D; &#123;</span><br><span class="line">        &#39;px&#39;: &#39;default&#39;,</span><br><span class="line">        &#39;city&#39;: &#39;上海&#39;,</span><br><span class="line">        &#39;needAddtionalResult&#39;: &#39;false&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    r &#x3D; s.post(url&#x3D;url,headers&#x3D;headers,data&#x3D;data,params&#x3D;params).json()</span><br><span class="line"></span><br><span class="line">    job_list &#x3D; r[&#39;content&#39;][&#39;positionResult&#39;][&#39;result&#39;]</span><br><span class="line">    item &#x3D; []</span><br><span class="line">    for i in job_list:</span><br><span class="line">        item.append(i[&#39;positionName&#39;])</span><br><span class="line">        item.append(i[&#39;companyFullName&#39;])</span><br><span class="line">    print(item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for page in range(1,2):</span><br><span class="line">    url &#x3D; &#39;https:&#x2F;&#x2F;www.lagou.com&#x2F;jobs&#x2F;positionAjax.json?&#39;</span><br><span class="line"></span><br><span class="line">    data &#x3D; &#123;</span><br><span class="line">        &#39;first&#39;: &#39;true&#39;,</span><br><span class="line">        &#39;pn&#39;: page,</span><br><span class="line">        &#39;kd&#39;: &#39;java&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    print(&#39;正在爬取低&#123;&#125;页！&#39;.format(page))</span><br><span class="line">    get_requests(url,data)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/08/03/5c94c803-b95d-4dc1-a4af-caf5aec7b262.png" alt="image.png"></p>
<p>直接运行run.py即可实现爬取<br><img src="/images/2020/08/03/0578d2f2-9e74-4613-a5c8-7d19ab3047db.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>wordcloud</title>
    <url>/wordcloud.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="1-英文词云"><a href="#1-英文词云" class="headerlink" title="1. 英文词云"></a>1. 英文词云</h1><p>我们先绘制英文文本的词云图，因为它相对简单一些。</p>
<p>首先，准备好文本文件（用sublime打开如下）：<br><img src="/images/2020/08/05/cec84c7a-d89b-48e0-99ad-317d8f568eaa.png" alt="image.png"><br>接下来，我们绘制一个最简单的矩形词云图，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># coding&#x3D;utf-8</span><br><span class="line"> </span><br><span class="line">from wordcloud import WordCloud</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"> </span><br><span class="line"># 打开文件</span><br><span class="line">text &#x3D; open(&#39;constitution.txt&#39;).read()</span><br><span class="line"> </span><br><span class="line"># 生成对象</span><br><span class="line">wc &#x3D; WordCloud().generate(text&#x3D;text)</span><br><span class="line"> </span><br><span class="line"># 显示词云</span><br><span class="line">plt.imshow(wc, interpolation&#x3D;&#39;bilinear&#39;)</span><br><span class="line">plt.axis(&#39;off&#39;)</span><br><span class="line">plt.show()</span><br><span class="line"> </span><br><span class="line"># 保存文件</span><br><span class="line">wc.to_file(&#39;wordcloud.png&#39;)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/08/05/6a9a19c4-fa5c-4c66-8645-e3f4616d4ac0.png" alt="image.png"></p>
<p>效果是不是看起来还不错，下面介绍wordcloud.WordCloud()的参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">font_path : string &#x2F;&#x2F;字体路径，需要展现什么字体就把该字体路径+后缀名写上，如：font_path &#x3D; &#39;黑体.ttf&#39;</span><br><span class="line"> </span><br><span class="line">width : int (default&#x3D;400) &#x2F;&#x2F;输出的画布宽度，默认为400像素</span><br><span class="line"> </span><br><span class="line">height : int (default&#x3D;200) &#x2F;&#x2F;输出的画布高度，默认为200像素</span><br><span class="line"> </span><br><span class="line">prefer_horizontal : float (default&#x3D;0.90) &#x2F;&#x2F;词语水平方向排版出现的频率，默认 0.9 （所以词语垂直方向排版出现频率为 0.1 ）</span><br><span class="line"> </span><br><span class="line">mask : nd-array or None (default&#x3D;None) &#x2F;&#x2F;如果参数为空，则使用二维遮罩绘制词云。如果 mask 非空，设置的宽高值将被忽略，遮罩形状被 mask 取代。除全白（#FFFFFF）的部分将不会绘制，其余部分会用于绘制词云。如：bg_pic &#x3D; imread(&#39;读取一张图片.png&#39;)，背景图片的画布一定要设置为白色（#FFFFFF），然后显示的形状为不是白色的其他颜色。可以用ps工具将自己要显示的形状复制到一个纯白色的画布上再保存，就ok了。</span><br><span class="line"> </span><br><span class="line">scale : float (default&#x3D;1) &#x2F;&#x2F;按照比例进行放大画布，如设置为1.5，则长和宽都是原来画布的1.5倍。</span><br><span class="line"> </span><br><span class="line">min_font_size : int (default&#x3D;4) &#x2F;&#x2F;显示的最小的字体大小</span><br><span class="line"> </span><br><span class="line">font_step : int (default&#x3D;1) &#x2F;&#x2F;字体步长，如果步长大于1，会加快运算但是可能导致结果出现较大的误差。</span><br><span class="line"> </span><br><span class="line">max_words : number (default&#x3D;200) &#x2F;&#x2F;要显示的词的最大个数</span><br><span class="line"> </span><br><span class="line">stopwords : set of strings or None &#x2F;&#x2F;设置需要屏蔽的词，如果为空，则使用内置的STOPWORDS</span><br><span class="line"> </span><br><span class="line">background_color : color value (default&#x3D;”black”) &#x2F;&#x2F;背景颜色，如background_color&#x3D;&#39;white&#39;,背景颜色为白色。</span><br><span class="line"> </span><br><span class="line">max_font_size : int or None (default&#x3D;None) &#x2F;&#x2F;显示的最大的字体大小</span><br><span class="line"> </span><br><span class="line">mode : string (default&#x3D;”RGB”) &#x2F;&#x2F;当参数为“RGBA”并且background_color不为空时，背景为透明。</span><br><span class="line"> </span><br><span class="line">relative_scaling : float (default&#x3D;.5) &#x2F;&#x2F;词频和字体大小的关联性</span><br><span class="line"> </span><br><span class="line">color_func : callable, default&#x3D;None &#x2F;&#x2F;生成新颜色的函数，如果为空，则使用 self.color_func</span><br><span class="line"> </span><br><span class="line">regexp : string or None (optional) &#x2F;&#x2F;使用正则表达式分隔输入的文本</span><br><span class="line"> </span><br><span class="line">collocations : bool, default&#x3D;True &#x2F;&#x2F;是否包括两个词的搭配</span><br><span class="line"> </span><br><span class="line">colormap : string or matplotlib colormap, default&#x3D;”viridis” &#x2F;&#x2F;给每个单词随机分配颜色，若指定color_func，则忽略该方法。</span><br><span class="line"> </span><br><span class="line">fit_words(frequencies)  &#x2F;&#x2F;根据词频生成词云</span><br><span class="line">generate(text)  &#x2F;&#x2F;根据文本生成词云</span><br><span class="line">generate_from_frequencies(frequencies[, ...])   &#x2F;&#x2F;根据词频生成词云</span><br><span class="line">generate_from_text(text)    &#x2F;&#x2F;根据文本生成词云</span><br><span class="line">process_text(text)  &#x2F;&#x2F;将长文本分词并去除屏蔽词（此处指英语，中文分词还是需要自己用别的库先行实现，使用上面的 fit_words(frequencies) ）</span><br><span class="line">recolor([random_state, color_func, colormap])   &#x2F;&#x2F;对现有输出重新着色。重新上色会比重新生成整个词云快很多。</span><br><span class="line">to_array()  &#x2F;&#x2F;转化为 numpy array</span><br><span class="line">to_file(filename)   &#x2F;&#x2F;输出到文件</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from wordcloud import WordCloud</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"> </span><br><span class="line"># 打开文本</span><br><span class="line">text &#x3D; open(&#39;xyj.txt&#39;).read()</span><br><span class="line"># 生成对象</span><br><span class="line">wc &#x3D; WordCloud(font_path&#x3D;&#39;Hiragino.ttf&#39;, width&#x3D;800, height&#x3D;600, mode&#x3D;&#39;RGBA&#39;, background_color&#x3D;None).generate(text)</span><br><span class="line"> </span><br><span class="line"># 显示词云</span><br><span class="line">plt.imshow(wc, interpolation&#x3D;&#39;bilinear&#39;)</span><br><span class="line">plt.axis(&#39;off&#39;)</span><br><span class="line">plt.show()</span><br><span class="line"> </span><br><span class="line"># 保存到文件</span><br><span class="line">wc.to_file(&#39;wordcloud.png&#39;) # 生成图像是透明的</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/08/05/877a6877-16dc-476d-a0b6-a38c167a8931.png" alt="image.png"><br>我们发现生成的词云有的不是词语，故我们增加jieba分词</p>
<p>jieba分词器链接    <a href="https://blog.csdn.net/kun1280437633/article/details/80718954" target="_blank" rel="noopener">https://blog.csdn.net/kun1280437633/article/details/80718954</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from wordcloud import WordCloud</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import jieba</span><br><span class="line"> </span><br><span class="line"># 打开文本</span><br><span class="line">text &#x3D; open(&#39;xyj.txt&#39;).read()</span><br><span class="line"> </span><br><span class="line"># 中文分词</span><br><span class="line">text &#x3D; &#39; &#39;.join(jieba.cut(text))</span><br><span class="line">print(text[:100])</span><br><span class="line"> </span><br><span class="line"># 生成对象</span><br><span class="line">wc &#x3D; WordCloud(font_path&#x3D;&#39;Hiragino.ttf&#39;, width&#x3D;800, height&#x3D;600, mode&#x3D;&#39;RGBA&#39;, background_color&#x3D;None).generate(text)</span><br><span class="line"> </span><br><span class="line"># 显示词云</span><br><span class="line">plt.imshow(wc, interpolation&#x3D;&#39;bilinear&#39;)</span><br><span class="line">plt.axis(&#39;off&#39;)</span><br><span class="line">plt.show()</span><br><span class="line"> </span><br><span class="line"># 保存到文件</span><br><span class="line">wc.to_file(&#39;wordcloud3.png&#39;)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/08/05/8819b0f6-261d-4150-b987-c4333e1d11e6.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from wordcloud import WordCloud</span><br><span class="line">from PIL import Image</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import jieba</span><br><span class="line"> </span><br><span class="line"># 打开文本</span><br><span class="line">text &#x3D; open(&#39;xyj.txt&#39;).read()</span><br><span class="line"> </span><br><span class="line"># 中文分词</span><br><span class="line">text &#x3D; &#39; &#39;.join(jieba.cut(text))</span><br><span class="line">print(text[:100])</span><br><span class="line"> </span><br><span class="line"># 生成对象</span><br><span class="line">mask &#x3D; np.array(Image.open(&quot;black_mask.png&quot;))</span><br><span class="line">wc &#x3D; WordCloud(mask&#x3D;mask, font_path&#x3D;&#39;Hiragino.ttf&#39;, mode&#x3D;&#39;RGBA&#39;, background_color&#x3D;None).generate(text)</span><br><span class="line"> </span><br><span class="line"># 显示词云</span><br><span class="line">plt.imshow(wc, interpolation&#x3D;&#39;bilinear&#39;)</span><br><span class="line">plt.axis(&quot;off&quot;)</span><br><span class="line">plt.show()</span><br><span class="line"> </span><br><span class="line"># 保存到文件</span><br><span class="line">wc.to_file(&#39;wordcloud4.png&#39;)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/08/05/1bac7e24-6008-4556-86ce-7f47c6eab89e.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from wordcloud import WordCloud, ImageColorGenerator</span><br><span class="line">from PIL import Image</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import jieba</span><br><span class="line"> </span><br><span class="line"># 打开文本</span><br><span class="line">text &#x3D; open(&#39;xyj.txt&#39;).read()</span><br><span class="line"> </span><br><span class="line"># 中文分词</span><br><span class="line">text &#x3D; &#39; &#39;.join(jieba.cut(text))</span><br><span class="line">print(text[:100])</span><br><span class="line"> </span><br><span class="line"># 生成对象</span><br><span class="line">mask &#x3D; np.array(Image.open(&quot;color_mask.png&quot;))</span><br><span class="line">wc &#x3D; WordCloud(mask&#x3D;mask, font_path&#x3D;&#39;Hiragino.ttf&#39;, mode&#x3D;&#39;RGBA&#39;, background_color&#x3D;None).generate(text)</span><br><span class="line"> </span><br><span class="line"># 从图片中生成颜色</span><br><span class="line">image_colors &#x3D; ImageColorGenerator(mask)</span><br><span class="line">wc.recolor(color_func&#x3D;image_colors)</span><br><span class="line"> </span><br><span class="line"># 显示词云</span><br><span class="line">plt.imshow(wc, interpolation&#x3D;&#39;bilinear&#39;)</span><br><span class="line">plt.axis(&quot;off&quot;)</span><br><span class="line">plt.show()</span><br><span class="line"> </span><br><span class="line"># 保存到文件</span><br><span class="line">wc.to_file(&#39;wordcloud5.png&#39;)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/08/05/60d0f044-7a74-425d-a296-123474623635.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from wordcloud import WordCloud</span><br><span class="line">from PIL import Image</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import random</span><br><span class="line">import jieba</span><br><span class="line"> </span><br><span class="line"># 打开文本</span><br><span class="line">text &#x3D; open(&#39;xyj.txt&#39;).read()</span><br><span class="line"> </span><br><span class="line"># 中文分词</span><br><span class="line">text &#x3D; &#39; &#39;.join(jieba.cut(text))</span><br><span class="line">print(text[:100])</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># 颜色函数</span><br><span class="line">def random_color(word, font_size, position, orientation, font_path, random_state):</span><br><span class="line">    s &#x3D; &#39;hsl(0, %d%%, %d%%)&#39; % (random.randint(60, 80), random.randint(60, 80))</span><br><span class="line">    print(s)</span><br><span class="line">    return s</span><br><span class="line"> </span><br><span class="line"># 生成对象</span><br><span class="line">mask &#x3D; np.array(Image.open(&quot;color_mask.png&quot;))</span><br><span class="line">wc &#x3D; WordCloud(color_func&#x3D;random_color, mask&#x3D;mask, font_path&#x3D;&#39;Hiragino.ttf&#39;, mode&#x3D;&#39;RGBA&#39;, background_color&#x3D;None).generate(text)</span><br><span class="line"> </span><br><span class="line"># 显示词云</span><br><span class="line">plt.imshow(wc, interpolation&#x3D;&#39;bilinear&#39;)</span><br><span class="line">plt.axis(&quot;off&quot;)</span><br><span class="line">plt.show()</span><br><span class="line"> </span><br><span class="line"># 保存到文件</span><br><span class="line">wc.to_file(&#39;wordcloud6.png&#39;)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/08/05/0124be0f-5379-4a58-b554-5bddcc99cbb9.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from wordcloud import WordCloud, ImageColorGenerator</span><br><span class="line">from PIL import Image</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import jieba.analyse</span><br><span class="line"> </span><br><span class="line"># 打开文本</span><br><span class="line">text &#x3D; open(&#39;xyj.txt&#39;).read()</span><br><span class="line"> </span><br><span class="line"># 提取关键词和权重</span><br><span class="line">freq &#x3D; jieba.analyse.extract_tags(text, topK&#x3D;200, withWeight&#x3D;True)</span><br><span class="line">print(freq[:20])</span><br><span class="line">freq &#x3D; &#123;i[0]: i[1] for i in freq&#125;</span><br><span class="line"> </span><br><span class="line"># 生成对象</span><br><span class="line">mask &#x3D; np.array(Image.open(&quot;color_mask.png&quot;))</span><br><span class="line">wc &#x3D; WordCloud(mask&#x3D;mask, font_path&#x3D;&#39;Hiragino.ttf&#39;, mode&#x3D;&#39;RGBA&#39;, background_color&#x3D;None).generate_from_frequencies(freq)</span><br><span class="line"> </span><br><span class="line"># 从图片中生成颜色</span><br><span class="line">image_colors &#x3D; ImageColorGenerator(mask)</span><br><span class="line">wc.recolor(color_func&#x3D;image_colors)</span><br><span class="line"> </span><br><span class="line"># 显示词云</span><br><span class="line">plt.imshow(wc, interpolation&#x3D;&#39;bilinear&#39;)</span><br><span class="line">plt.axis(&quot;off&quot;)</span><br><span class="line">plt.show()</span><br><span class="line"> </span><br><span class="line"># 保存到文件</span><br><span class="line">wc.to_file(&#39;wordcloud7.png&#39;)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/08/05/f04823dc-61dd-4dd0-a1e5-9a706f83fe52.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>爬取百度翻译</title>
    <url>/%E7%88%AC%E5%8F%96%E7%99%BE%E5%BA%A6%E7%BF%BB%E8%AF%91.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"># @Time : 2020&#x2F;8&#x2F;7 20:52</span><br><span class="line"># @Author : zc</span><br><span class="line"># @File : baidui-translate.py</span><br><span class="line"># @Software: PyCharm</span><br><span class="line">import requests</span><br><span class="line">import json</span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    post_url&#x3D;&quot;https:&#x2F;&#x2F;fanyi.baidu.com&#x2F;sug&quot;</span><br><span class="line">    headers&#x3D;&#123;</span><br><span class="line">        &quot;user - agent&quot;: &quot;Mozilla &#x2F; 5.0(Windows NT 10.0;Win64;x64) AppleWebKit &#x2F; 537.36(KHTML, like Gecko) Chrome &#x2F; 83.0.4103.116 Safari &#x2F; 537.36&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    word&#x3D;input(&quot;请输入关键字：&quot;)</span><br><span class="line">    data&#x3D;&#123;</span><br><span class="line">        &#39;kw&#39;:word</span><br><span class="line">    &#125;</span><br><span class="line">    response&#x3D;requests.post(url&#x3D;post_url,data&#x3D;data,headers&#x3D;headers)</span><br><span class="line">    dic&#x3D;response.json()</span><br><span class="line"></span><br><span class="line">    filename&#x3D;word+&#39;.json&#39;</span><br><span class="line">    fp&#x3D;open(filename,&#39;w&#39;,encoding&#x3D;&#39;utf_8&#39;)</span><br><span class="line">    json.dump(dic,fp&#x3D;fp,ensure_ascii&#x3D;False)</span><br><span class="line">    print(&#39;over!!!&#39;)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/images/2020/08/07/336854ae-4dde-4daf-9f03-af3d06738f1d.png" alt="image.png"><br><img src="/images/2020/08/07/e9872602-5aee-4f81-be92-c3a9b10f4475.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>豆瓣电影requests库请求</title>
    <url>/%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1requests%E5%BA%93%E8%AF%B7%E6%B1%82.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"># @Time : 2020&#x2F;8&#x2F;8 21:19</span><br><span class="line"># @Author : zc</span><br><span class="line"># @File : 豆瓣电影.py</span><br><span class="line"># @Software: PyCharm</span><br><span class="line">import  requests</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    url&#x3D;&quot;https:&#x2F;&#x2F;movie.douban.com&#x2F;j&#x2F;chart&#x2F;top_list&quot;</span><br><span class="line">    head &#x3D; &#123;</span><br><span class="line">        &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;76.0.3809.87 Safari&#x2F;537.36 SLBrowser&#x2F;6.0.1.6181&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    param&#x3D;&#123;</span><br><span class="line">    &#39;type&#39;:  &#39;5&#39;,</span><br><span class="line">    &#39;interval_id&#39;: &#39;100:90&#39;,</span><br><span class="line">    &#39;action&#39;: &#39;&#39;,</span><br><span class="line">    &#39;start&#39;: &#39;0&#39;,</span><br><span class="line">    &#39;limit&#39;: &#39;20&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    response&#x3D;requests.get(url&#x3D;url,params&#x3D;param,headers&#x3D;head)</span><br><span class="line">    list_data&#x3D;response.json()</span><br><span class="line">    fp&#x3D;open(&#39;.&#x2F;douban.json&#39;,&#39;w&#39;,encoding&#x3D;&#39;utf_8&#39;)</span><br><span class="line">    json.dump(list_data,fp&#x3D;fp,ensure_ascii&#x3D;False)</span><br><span class="line">    print(&quot;爬取完成！&quot;)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/08/08/cb24210e-9f9c-4a94-9e9d-66e12d72f752.png" alt="image.png"><br><img src="/images/2020/08/08/2437c52d-84cd-4ca2-a90e-4f265ec0b2c0.png" alt="image.png"><br><img src="/images/2020/08/08/6ece7807-8295-4ca2-8a6d-43366c799333.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Python实现数据可视化</title>
    <url>/Python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="一、数据可视化介绍"><a href="#一、数据可视化介绍" class="headerlink" title="一、数据可视化介绍"></a>一、数据可视化介绍</h1><p>数据可视化是指将数据放在可视环境中、进一步理解数据的技术，可以通过它更加详细地了解隐藏在数据表面之下的模式、趋势和相关性。</p>
<p>Python提供了很多数据可视化的库：</p>
<ul>
<li>matplotlib<br>是Python基础的画图库，官网为<a href="https://matplotlib.org/，在案例地址https://matplotlib.org/gallery/index.html中介绍了很多种类的图和代码示例。" target="_blank" rel="noopener">https://matplotlib.org/，在案例地址https://matplotlib.org/gallery/index.html中介绍了很多种类的图和代码示例。</a></li>
<li>pandas<br>是在matplotlib的基础上实现画图的，官网为<a href="https://pandas.pydata.org/。" target="_blank" rel="noopener">https://pandas.pydata.org/。</a></li>
<li>matlpotlib和pandas结合<br>利用pandas进行数据读取、数据清洗和数据选取等操作，再使用matlpotlib显示数据。<h1 id="二、matplotlib和pandas画图"><a href="#二、matplotlib和pandas画图" class="headerlink" title="二、matplotlib和pandas画图"></a>二、matplotlib和pandas画图</h1><h2 id="1-matplotlib简介和简单使用"><a href="#1-matplotlib简介和简单使用" class="headerlink" title="1.matplotlib简介和简单使用"></a>1.matplotlib简介和简单使用</h2>matplotlib是Python最著名的绘图库，它提供了一整套和Matlab相似的命令API，十分适合<br>交互式地进行制图；也可以方便地将它作为绘图控件，嵌入GUI应用程序中。<br>文档相当完备，并且Gallery页面中有上百幅缩略图，打开之后都有源代码。如果需要绘制某种类型的图，只需要在这个页面中进行简单的浏览、复制、粘贴，就能实现画图。<br><a href="https://matplotlib.org/gallery.html中有大量的缩略图案例可以使用。" target="_blank" rel="noopener">https://matplotlib.org/gallery.html中有大量的缩略图案例可以使用。</a></li>
</ul>
<p>matplotlib画图的子库：</p>
<ul>
<li>pyplot子库<br>提供了和matlab类似的绘图API，方便用户快速绘制2D图表。</li>
<li>pylab模块<br>其中包括了许多numpy和pyplot中常用的函数，方便用户快速进行计算和绘图，可以用于IPython中的快速交互式使用。<br>使用matplotlib快速绘图导入库和创建绘图对象如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">plt.figure(figsize&#x3D;(8,4))</span><br></pre></td></tr></table></figure>
创建绘图对象时，同时使它成为当前的绘图对象。<br>通过figsize参数可以指定绘图对象的宽度和高度，单位为英寸；<br>dpi参数指定绘图对象的分辨率，即每英寸多少个像素，缺省值为80。<br>因此本例中所创建的图表窗口的宽度为8 * 80 = 640像素。</li>
</ul>
<p>也可以不创建绘图对象直接调用plot方法绘图，matplotlib会自动创建一个绘图对象。<br>如果需要同时绘制多幅图表的话，可以给figure传递一个整数参数指定图标的序号，如果所指定序号的绘图对象已经存在的话，将不创建新的对象，而只是让它成为当前绘图对象。<br>pyplot画图简单使用如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt # 首先载入matplotlib的绘图模块pyplot，并且重命名为plt</span><br><span class="line"></span><br><span class="line">x &#x3D; np.linspace(0, 10, 1000)  </span><br><span class="line"></span><br><span class="line">y &#x3D; np.sin(x)</span><br><span class="line">z &#x3D; np.cos(x**2)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize&#x3D;(8,4))   #2 创建绘图对象</span><br><span class="line"></span><br><span class="line">plt.plot(x,y,label&#x3D;&quot;$sin(x)$&quot;,color&#x3D;&quot;red&quot;,linewidth&#x3D;2)</span><br><span class="line">plt.plot(x,z,&quot;b--&quot;,label&#x3D;&quot;$cos(x^2)$&quot;) </span><br><span class="line"></span><br><span class="line">plt.xlabel(&quot;Time(s)&quot;) </span><br><span class="line">plt.ylabel(&quot;Volt&quot;)</span><br><span class="line">plt.title(&quot;PyPlot First Example&quot;)</span><br><span class="line">plt.ylim(-1.2,1.2)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>显示：<br><img src="/images/2020/08/31/51d3094f-b776-42d7-ba40-a636054743bc.png" alt="image.png"><br>其中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plt.plot(x,y,label&#x3D;&quot;$sin(x)$&quot;,color&#x3D;&quot;red&quot;,linewidth&#x3D;2)</span><br><span class="line">plt.plot(x,z,&quot;b--&quot;,label&#x3D;&quot;$cos(x^2)$&quot;)</span><br></pre></td></tr></table></figure>
<p>第一行将x、y数组传递给plot之后，用关键字参数指定各种属性：</p>
<ul>
<li>label<br>给所绘制的曲线取一个名字，用于在图示（legend）中显示；<br>在字符串前后添加$符号，就会使用内置的latex引擎绘制数学公式。</li>
<li>color<br>指定曲线的颜色：颜色可以用英文单词，或者以#字符开头的三个16进制数，例如#ff0000表示红色，或者用值在0到1范围之内的三个元素的元组表示，例如(1.0, 0.0, 0.0)也表示红色。<br>linewidth<br>指定曲线的宽度，可以不是整数，也可以使用缩写形式的参数名lw。<br>曲线样式<br>第三个参数b–指定曲线的颜色和线型，它通过一些易记的符号指定曲线的样式，其中b表示蓝色，–表示线型为虚线。<br>在IPython中输入plt.plot?可以查看格式化字符串以及各个参数的详细说明。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plt.xlabel(&quot;Time(s)&quot;) </span><br><span class="line">plt.ylabel(&quot;Volt&quot;)</span><br><span class="line">plt.title(&quot;PyPlot First Example&quot;)</span><br><span class="line">plt.ylim(-1.2,1.2)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></table></figure>
通过一系列函数设置当前Axes对象的各个属性：</li>
</ul>
<p>xlabel、ylabel<br>分别设置X、Y轴的标题文字。<br>title<br>设置子图的标题。<br>xlim、ylim<br>分别设置X、Y轴的显示范围。<br>legend<br>显示图示，即图中表示每条曲线的标签(label)和样式的矩形区域。<br>最后调用plt.show()显示出绘图窗口。</p>
<p>一个绘图对象(figure)可以包含多个轴(axis)，在Matplotlib中用轴表示一个绘图区域，可以将其理解为子图。上面的第一个例子中，绘图对象只包括一个轴，因此只显示了一个轴（子图Axes）。可以使用subplot函数快速绘制有多个轴的图表。<br>subplot函数的调用形式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subplot(numRows, numCols, plotNum)</span><br></pre></td></tr></table></figure>
<p>subplot将整个绘图区域等分为numRows行和numCols列个子区域，然后按照从左到右、从上到下的顺序对每个子区域进行编号，左上的子区域的编号为1。<br>如果numRows、numCols和plotNum这三个数都小于10的话，可以把它们缩写为一个整数，例如subplot(323)和subplot(3,2,3)是相同的。<br>subplot在plotNum指定的区域中创建一个轴对象，如果新创建的轴和之前创建的轴重叠，之前的轴将被删除。</p>
<p>如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for idx, color in enumerate(&quot;rgbyck&quot;):</span><br><span class="line">    plt.subplot(320+idx+1, facecolor&#x3D;color)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>显示：<br><img src="/images/2020/08/31/eb75c121-06b4-4bb5-887e-7010b481d9a7.png" alt="image.png"><br>可以看到：<br>创建3行2列共6个轴，通过facecolor参数给每个轴设置不同的背景颜色。</p>
<p>如果希望某个轴占据整个行或者列的话，可以如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plt.subplot(221) # 第一行的左图</span><br><span class="line">plt.subplot(222) # 第一行的右图</span><br><span class="line">plt.subplot(212) # 第二整行</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>显示：<br><img src="/images/2020/08/31/694e276b-1366-495f-93df-e50400e4e0fc.png" alt="image.png"></p>
<p>再举一个创建子图的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plt.figure(1) # 创建图表1</span><br><span class="line">plt.figure(2) # 创建图表2</span><br><span class="line">ax1 &#x3D; plt.subplot(211) # 在图表2中创建子图1</span><br><span class="line">ax2 &#x3D; plt.subplot(212) # 在图表2中创建子图2</span><br><span class="line"> </span><br><span class="line">x &#x3D; np.linspace(0, 3, 100)</span><br><span class="line">for i in range(5):</span><br><span class="line">    plt.figure(1) # 选择图表1</span><br><span class="line">    plt.plot(x, np.exp(i*x&#x2F;3))</span><br><span class="line">    plt.sca(ax1) # 选择图表2的子图1   Set the current Axes instance to ax.</span><br><span class="line">    plt.plot(x, np.sin(i*x))</span><br><span class="line">    plt.sca(ax2) # 选择图表2的子图2</span><br><span class="line">    plt.plot(x, np.cos(i*x))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>显示：<br><img src="/images/2020/08/31/e258b33a-ae23-4481-8248-2bf736945d5a.png" alt="image.png"><br>首先通过figure()创建了两个图表，它们的序号分别为1和2；<br>然后在图表2中创建了上下并排的两个子图，并用变量ax1和ax2保存。<br>在循环中：<br>先调用figure(1)让图表1成为当前图表，并在其中绘图。<br>然后调用sca(ax1)和sca(ax2)分别让子图ax1和ax2成为当前子图，并在其中绘图。<br>当它们成为当前子图时，包含它们的图表2也自动成为当前图表，因此不需要调用figure(2)依次在图表1和图表2的两个子图之间切换，逐步在其中添加新的曲线即可。</p>
<p>其中，twinx()可以为图增加纵坐标轴，使用如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; np.arange(1, 21, 0.1)</span><br><span class="line"> </span><br><span class="line">y1 &#x3D; x * x</span><br><span class="line">y2 &#x3D; np.log(x)</span><br><span class="line"> </span><br><span class="line">plt.plot(x, y1)</span><br><span class="line"> </span><br><span class="line"># 添加一条y轴的坐标轴</span><br><span class="line">plt.twinx()</span><br><span class="line">plt.plot(x, y2)</span><br><span class="line"> </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>显示：<br><img src="/images/2020/08/31/5dc989b6-220f-4301-a082-1277ec1d4acc.png" alt="image.png"></p>
<p>进一步使用如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"> </span><br><span class="line">x &#x3D; np.arange(1, 20, 1)</span><br><span class="line">y1 &#x3D; x * x</span><br><span class="line">y2 &#x3D; np.log(x)</span><br><span class="line"> </span><br><span class="line">fig &#x3D; plt.figure()</span><br><span class="line">ax1 &#x3D; fig.add_subplot(111)</span><br><span class="line"></span><br><span class="line">ax1.plot(x, y1, label &#x3D; &quot;$y1 &#x3D; x * x$&quot;, color &#x3D; &quot;r&quot;)</span><br><span class="line">ax1.legend(loc &#x3D; 0)</span><br><span class="line"># 设置对应坐标轴的名称</span><br><span class="line">ax1.set_ylabel(&quot;y1&quot;)</span><br><span class="line">ax1.set_xlabel(&quot;Compare y1 and y2&quot;)</span><br><span class="line"> </span><br><span class="line"># 设置x轴刻度的数量</span><br><span class="line">ax &#x3D; plt.gca()</span><br><span class="line">ax.locator_params(&quot;x&quot;, nbins &#x3D; 20)</span><br><span class="line"> </span><br><span class="line"># 添加坐标轴,并在新添加的坐标轴中画y2 &#x3D; log(x)图像</span><br><span class="line">ax2 &#x3D; plt.twinx()</span><br><span class="line">ax2.set_ylabel(&quot;y2&quot;)</span><br><span class="line">ax2.plot(x, y2, label &#x3D; &quot;$y2 &#x3D; log(x)$&quot;)</span><br><span class="line">ax2.legend(loc &#x3D; 0)</span><br><span class="line"> </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>显示：<br><img src="/images/2020/08/31/0906435b-ad74-4f36-a4c7-8078e99d56a4.png" alt="image.png"></p>
<p>2.matplotlib常见作图类型<br>画图在工作中在所难免，尤其在进行数据探索时显得尤其重要，matplotlib常见的一些作图种类如下：</p>
<p>散点图<br>条形图<br>饼图<br>三维图<br>先导入库和基础配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from __future__ import division</span><br><span class="line">from numpy.random import randn</span><br><span class="line">import numpy as np</span><br><span class="line">import os</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">np.random.seed(12345)</span><br><span class="line">plt.rc(&#39;figure&#39;, figsize&#x3D;(10, 6))</span><br><span class="line">from pandas import Series, DataFrame</span><br><span class="line">import pandas as pd</span><br><span class="line">np.set_printoptions(precision&#x3D;4)</span><br><span class="line"></span><br><span class="line">get_ipython().magic(u&#39;matplotlib inline&#39;)</span><br><span class="line">get_ipython().magic(u&#39;pwd&#39;)</span><br></pre></td></tr></table></figure>
<p>打印：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;XXX\\3_Visualization_Of_Data_Analysis\\basicuse&#39;</span><br></pre></td></tr></table></figure>
<p>基础画图如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># matplotlib创建图表</span><br><span class="line">plt.plot([1,2,3,2,3,2,2,1])</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">plt.plot([4,3,2,1],[1,2,3,4])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>显示：<br><img src="/images/2020/08/31/dfad9baa-5179-4d80-9ea8-95a4ab052e86.png" alt="image.png"></p>
<p>画三角函数曲线如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 画简单的图形</span><br><span class="line">from pylab import *</span><br><span class="line">x&#x3D;np.linspace(-np.pi,np.pi,256,endpoint&#x3D;True)</span><br><span class="line">c,s&#x3D;np.cos(x),np.sin(x)</span><br><span class="line">plot(x,c, color&#x3D;&quot;blue&quot;, linewidth&#x3D;2.5, linestyle&#x3D;&quot;-&quot;, label&#x3D;&quot;cosine&quot;)</span><br><span class="line">plot(x,s,color&#x3D;&quot;red&quot;, linewidth&#x3D;2.5, linestyle&#x3D;&quot;-&quot;, label&#x3D;&quot;sine&quot;)</span><br><span class="line">show()</span><br></pre></td></tr></table></figure>
<p>显示：<br><img src="/images/2020/08/31/2879e73e-f08c-4cb0-bb4c-6210ab1d4d21.png" alt="image.png"><br>画散点图如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 散点图</span><br><span class="line">from pylab import *</span><br><span class="line">n &#x3D; 1024</span><br><span class="line">X &#x3D; np.random.normal(0,1,n)</span><br><span class="line">Y &#x3D; np.random.normal(0,1,n)</span><br><span class="line">scatter(X,Y)</span><br><span class="line">show()</span><br></pre></td></tr></table></figure>
<p>显示：<br><img src="/images/2020/08/31/4388e6be-d730-4e11-8dd8-0193510800f4.png" alt="image.png"><br>画条形图如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#条形图</span><br><span class="line">from pylab import *</span><br><span class="line">n &#x3D; 12</span><br><span class="line">X &#x3D; np.arange(n)</span><br><span class="line">Y1 &#x3D; (1-X&#x2F;float(n)) * np.random.uniform(0.5,1.0,n)</span><br><span class="line">Y2 &#x3D; (1-X&#x2F;float(n)) * np.random.uniform(0.5,1.0,n)</span><br><span class="line">bar(X, +Y1, facecolor&#x3D;&#39;#9999ff&#39;, edgecolor&#x3D;&#39;white&#39;)</span><br><span class="line">bar(X, -Y2, facecolor&#x3D;&#39;#ff9999&#39;, edgecolor&#x3D;&#39;white&#39;)</span><br><span class="line">for x,y in zip(X,Y1):</span><br><span class="line"> text(x+0.4, y+0.05, &#39;%.2f&#39; % y, ha&#x3D;&#39;center&#39;, va&#x3D; &#39;bottom&#39;)</span><br><span class="line">ylim(-1.25,+1.25)</span><br><span class="line">show()</span><br></pre></td></tr></table></figure>
<p>显示：<br><img src="/images/2020/08/31/01df7f08-1556-48c2-8012-f09c8ec6fe5b.png" alt="image.png"><br>饼图如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#饼图</span><br><span class="line">from pylab import *</span><br><span class="line">n &#x3D; 20</span><br><span class="line">Z &#x3D; np.random.uniform(0,1,n)</span><br><span class="line">pie(Z)</span><br><span class="line">show()</span><br></pre></td></tr></table></figure>
<p>显示：<br><img src="/images/2020/08/31/3ceb614a-169b-4629-ba0f-6deb1eb69280.png" alt="image.png"><br>画立体图如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#画三维图</span><br><span class="line">import numpy as np</span><br><span class="line">from mpl_toolkits.mplot3d import Axes3D</span><br><span class="line">from pylab import *</span><br><span class="line">fig&#x3D;figure()</span><br><span class="line">ax&#x3D;Axes3D(fig)</span><br><span class="line">x&#x3D;np.arange(-4,4,0.1)</span><br><span class="line">y&#x3D;np.arange(-4,4,0.1)</span><br><span class="line">x,y&#x3D;np.meshgrid(x,y)</span><br><span class="line">R&#x3D;np.sqrt(x**2+y**2)</span><br><span class="line">z&#x3D;np.sin(R)</span><br><span class="line">ax.plot_surface(x,y,z,rstride&#x3D;1,cstride&#x3D;1,cmap&#x3D;&#39;hot&#39;)</span><br><span class="line">show()</span><br></pre></td></tr></table></figure>
<p>显示：<br><img src="/images/2020/08/31/58f522e4-e607-4124-abc2-fae51450c991.png" alt="image.png"><br>画其他简单图形如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#更多简单的图形</span><br><span class="line">x &#x3D; [1,2,3,4]</span><br><span class="line">y &#x3D; [5,4,3,2]</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.subplot(2,3,1)</span><br><span class="line">plt.plot(x, y)</span><br><span class="line"></span><br><span class="line">plt.subplot(232)</span><br><span class="line">plt.bar(x, y)</span><br><span class="line"></span><br><span class="line">plt.subplot(233)</span><br><span class="line">plt.barh(x, y)</span><br><span class="line"></span><br><span class="line">plt.subplot(234)</span><br><span class="line">plt.bar(x, y)</span><br><span class="line">y1 &#x3D; [7,8,5,3]</span><br><span class="line">plt.bar(x, y1, bottom&#x3D;y, color &#x3D; &#39;r&#39;)</span><br><span class="line"></span><br><span class="line">plt.subplot(235)</span><br><span class="line">plt.boxplot(x)</span><br><span class="line"></span><br><span class="line">plt.subplot(236)</span><br><span class="line">plt.scatter(x,y)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>显示：<br><img src="/images/2020/08/31/2c4941bf-2640-438a-b2ab-ed8d5a7c13db.png" alt="image.png"></p>
<h1 id="3-使用pandas画图"><a href="#3-使用pandas画图" class="headerlink" title="3.使用pandas画图"></a>3.使用pandas画图</h1><p>pandas中画图的主要类型包括：</p>
<p>累和图<br>柱状图<br>散点图<br>饼图<br>矩阵散点图<br>先导入所需要的库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from __future__ import division</span><br><span class="line">from numpy.random import randn</span><br><span class="line">import numpy as np</span><br><span class="line">import os</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">np.random.seed(12345)</span><br><span class="line">from pandas import Series, DataFrame</span><br><span class="line">import pandas as pd</span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure>
<p>在pandas中，有行标签、列标签和分组信息等，如果使用matplotlib画图，可能需要一大堆的代码，现在调用Pandas的plot()方法即可简单实现。</p>
<p>画简单线图如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#线图 </span><br><span class="line">s &#x3D; Series(np.random.randn(10).cumsum(), index&#x3D;np.arange(0, 100, 10))</span><br><span class="line">s.plot()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>显示：<br><img src="/images/2020/08/31/65652617-6391-4837-8932-51197e082422.png" alt="image.png"><br>pandas.Series.plot()的常见参数及说明如下：</p>
<p><img src="/images/2020/08/31/c934d298-7f69-41d5-af53-f82bba3a646d.png" alt="image.png"><br>Pandas的大部分绘图方法都有一个可选的ax参数，它可以是一个matplotlib的subplot对象，从而能够在网络布局中更为灵活地处理subplot的位置。DataFrame的plot方法会在一个subplot中为各列绘制一条线，并自动创建图例。</p>
<p>画多列线图如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df &#x3D; DataFrame(np.random.randn(10, 4).cumsum(0),</span><br><span class="line">               columns&#x3D;[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;],</span><br><span class="line">               index&#x3D;np.arange(0, 100, 10))</span><br><span class="line">df.plot()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>显示：<br><img src="/images/2020/08/31/b3dcbd65-e607-4ed4-a114-929ce319a073.png" alt="image.png"><br>相对于Series，DataFrame还有一些用于对列进行灵活处理的选项，例如要将所有列都绘制到一个subplot中还是创建各自的subplot等，具体如下：<br><img src="/images/2020/08/31/0a8e6444-0749-43e0-a9c1-aba3a92ba8ce.png" alt="image.png"><br>画简单累和图如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#线图 CUM</span><br><span class="line">plt.close(&#39;all&#39;)</span><br><span class="line"></span><br><span class="line">s &#x3D; Series(np.random.randn(10).cumsum(), index&#x3D;np.arange(0, 100, 10))</span><br><span class="line">s.plot()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>显示：<br><img src="/images/2020/08/31/3c7bd5f5-2d87-4d88-96ce-1b11846cd22e.png" alt="image.png"></p>
<p>画多列的类和图如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df &#x3D; DataFrame(np.random.randn(10, 4).cumsum(0),</span><br><span class="line">               columns&#x3D;[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;],</span><br><span class="line">               index&#x3D;np.arange(0, 100, 10))</span><br><span class="line">df.plot()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>显示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![image.png](&#x2F;images&#x2F;2020&#x2F;08&#x2F;31&#x2F;d28a482e-5e8a-4784-a14c-be2ef24092fb.png)</span><br><span class="line">当提升了数据规模之后，累和图如下：</span><br><span class="line">s &#x3D; pd.Series([2, np.nan, 5, -1, 0])</span><br><span class="line">print(s)</span><br><span class="line"></span><br><span class="line">print(s.cumsum())</span><br><span class="line"></span><br><span class="line">#画累和图</span><br><span class="line">ts&#x3D;pd.Series(np.random.randn(1000),index&#x3D;pd.date_range(&#39;1&#x2F;1&#x2F;2000&#39;,periods&#x3D;1000))</span><br><span class="line">ts&#x3D;ts.cumsum()</span><br><span class="line">ts.plot()</span><br><span class="line">plt.show()</span><br><span class="line">df&#x3D;pd.DataFrame(np.random.randn(1000,4),index&#x3D;ts.index,columns&#x3D;list(&#39;ABCD&#39;))</span><br><span class="line"></span><br><span class="line"># cumulative意为累计、累积，这个函数可以返回一个累计值，经常会遇到月累计、年累计这种指标，会用这个函数</span><br><span class="line">df&#x3D;df.cumsum()</span><br><span class="line">df.plot()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>打印：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0    2.0</span><br><span class="line">1    NaN</span><br><span class="line">2    5.0</span><br><span class="line">3   -1.0</span><br><span class="line">4    0.0</span><br><span class="line">dtype: float64</span><br><span class="line">0    2.0</span><br><span class="line">1    NaN</span><br><span class="line">2    7.0</span><br><span class="line">3    6.0</span><br><span class="line">4    6.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>显示：<br><img src="/images/2020/08/31/c7dd0a54-754e-44db-a923-9e91ba8c6dfe.png" alt="image.png"><br>画Series柱状图如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#柱形图</span><br><span class="line">fig, axes &#x3D; plt.subplots(2, 1)</span><br><span class="line">data &#x3D; Series(np.random.rand(16), index&#x3D;list(&#39;abcdefghijklmnop&#39;))</span><br><span class="line">data.plot(kind&#x3D;&#39;bar&#39;, ax&#x3D;axes[0], color&#x3D;&#39;r&#39;, alpha&#x3D;0.7)</span><br><span class="line">data.plot(kind&#x3D;&#39;barh&#39;, ax&#x3D;axes[1], color&#x3D;&#39;g&#39;, alpha&#x3D;0.7)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>显示：<br><img src="/images/2020/08/31/2d98966f-63ca-4d3f-966f-c5630bbdfb72.png" alt="image.png"><br>DataFrame画柱状图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df &#x3D; DataFrame(np.random.rand(6, 4),</span><br><span class="line">               index&#x3D;[&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;four&#39;, &#39;five&#39;, &#39;six&#39;],</span><br><span class="line">               columns&#x3D;pd.Index([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;], name&#x3D;&#39;Genus&#39;))</span><br><span class="line"></span><br><span class="line">df.plot(kind&#x3D;&#39;bar&#39;) #图例</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line"></span><br><span class="line">df.plot(kind&#x3D;&#39;barh&#39;, stacked&#x3D;True, alpha&#x3D;0.5)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>显示：<br><img src="/images/2020/08/31/8981b2ba-6a2e-45f3-9e46-2a06fadca8f9.png" alt="image.png"><br>可以看到：<br>对于DataFrame，柱形图会将每一行的值分为一组；<br>DataFrame的各列名称都被用作了图例的标题；<br>设置stacked=True即可为DataFrame生成堆积柱形图，这样每行的值就会被堆积在一起。</p>
<p>餐馆小费数据如下：<br><img src="/images/2020/08/31/c72ca676-d30d-400e-a2cc-f0b1e69ede2d.png" alt="image.png"><br>进行数据可视化如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ips &#x3D; pd.read_csv(&#39;tips.csv&#39;) # 各数据点的百分比</span><br><span class="line">party_counts &#x3D; pd.crosstab(tips.day, tips[&#39;size&#39;])  #size聚会人数</span><br><span class="line">print(party_counts)</span><br><span class="line"></span><br><span class="line">party_counts &#x3D; party_counts.iloc[:, 2:5] # 选取一部分数据</span><br><span class="line">print(party_counts)</span><br><span class="line"></span><br><span class="line">party_pcts &#x3D; party_counts.div(party_counts.sum(1).astype(float), axis&#x3D;0) # 转换成百分比, 1 代表维度 行的方向</span><br><span class="line">print(party_pcts)</span><br><span class="line">party_pcts.plot(kind&#x3D;&#39;bar&#39;, stacked&#x3D;True)   #每天的高度都是1</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>打印：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size  1   2   3   4  5  6</span><br><span class="line">day                      </span><br><span class="line">Fri   1  16   1   1  0  0</span><br><span class="line">Sat   2  53  18  13  1  0</span><br><span class="line">Sun   0  39  15  18  3  1</span><br><span class="line">Thur  1  48   4   5  1  3</span><br><span class="line">size   3   4  5</span><br><span class="line">day            </span><br><span class="line">Fri    1   1  0</span><br><span class="line">Sat   18  13  1</span><br><span class="line">Sun   15  18  3</span><br><span class="line">Thur   4   5  1</span><br><span class="line">size         3        4         5</span><br><span class="line">day                              </span><br><span class="line">Fri   0.500000  0.50000  0.000000</span><br><span class="line">Sat   0.562500  0.40625  0.031250</span><br><span class="line">Sun   0.416667  0.50000  0.083333</span><br><span class="line">Thur  0.400000  0.50000  0.100000</span><br></pre></td></tr></table></figure>
<p>显示：<br><img src="/images/2020/08/31/a1fd3ccf-4e87-421a-a07a-8c3a22d43fd4.png" alt="image.png"><br>画较复杂的柱状图如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#画柱状图</span><br><span class="line">df2 &#x3D; pd.DataFrame(np.random.rand(10, 4), columns&#x3D;[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])</span><br><span class="line">df2.plot(kind&#x3D;&#39;bar&#39;) #分开并列线束</span><br><span class="line">df2.plot(kind&#x3D;&#39;bar&#39;, stacked&#x3D;True) #四个在同一个里面显示 百分比的形式</span><br><span class="line">df2.plot(kind&#x3D;&#39;barh&#39;, stacked&#x3D;True)#纵向显示</span><br><span class="line">plt.show()</span><br><span class="line">df4&#x3D;pd.DataFrame(&#123;&#39;a&#39;:np.random.randn(1000)+1,&#39;b&#39;:np.random.randn(1000),&#39;c&#39;:np.random.randn(1000)-1&#125;,columns&#x3D;list(&#39;abc&#39;))</span><br><span class="line">df4.plot(kind&#x3D;&#39;hist&#39;, alpha&#x3D;0.5)</span><br><span class="line">df4.plot(kind&#x3D;&#39;hist&#39;, stacked&#x3D;True, bins&#x3D;20)</span><br><span class="line">df4[&#39;a&#39;].plot(kind&#x3D;&#39;hist&#39;, orientation&#x3D;&#39;horizontal&#39;,cumulative&#x3D;True) #cumulative是按顺序排序</span><br><span class="line">plt.show()</span><br><span class="line">#Area Plot</span><br><span class="line">df &#x3D; pd.DataFrame(np.random.rand(10, 4), columns&#x3D;[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])</span><br><span class="line">df.plot(kind&#x3D;&#39;area&#39;)</span><br><span class="line">df.plot(kind&#x3D;&#39;area&#39;,stacked&#x3D;False)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>显示：<br><img src="/images/2020/08/31/4f27e42a-927a-4dc5-b20f-90a57e580b44.png" alt="image.png"><br>直方图histogram：<br>是一种可以对值频率进行离散化显示的柱状图。数据点被拆分到离散的、间隔均匀的面元中，绘制的是各面元中数据点的数量。<br>调用Series.hist()即可实现，在之后调用plot时加上参数kind=’kde’即可生成一张密度图。</p>
<p>根据小费数据画直方图如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 直方图--给小费占总费用的比例的分布图</span><br><span class="line">plt.figure()</span><br><span class="line"></span><br><span class="line">tips[&#39;tip_pct&#39;] &#x3D; tips[&#39;tip&#39;] &#x2F; tips[&#39;total_bill&#39;]  # 增加一个新的列</span><br><span class="line">tips[&#39;tip_pct&#39;].hist(bins&#x3D;50) # 分为50个区间 </span><br><span class="line"></span><br><span class="line">plt.figure()</span><br></pre></td></tr></table></figure>
<p>显示：<br><img src="/images/2020/08/31/ec219ac0-a362-42b3-ab26-26fd1643137c.png" alt="image.png"><br>在统计学中，核密度估计（KDE）是一种估计随机变量概率密度函数（PDF）的非参数方法，利用高斯核生成核密度估计图如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">comp1 &#x3D; np.random.normal(0, 1, size&#x3D;200)  # N(0, 1)  模拟出 0，1 的正态分布数据 0，期望值， 1 方差值</span><br><span class="line">comp2 &#x3D; np.random.normal(10, 2, size&#x3D;200)  # 10，期望值， 2 方差值  方差值大，跨度就大些</span><br><span class="line">values &#x3D; Series(np.concatenate([comp1, comp2]))</span><br><span class="line">values.hist(bins&#x3D;100, alpha&#x3D;0.3, color&#x3D;&#39;k&#39;, density&#x3D;True)</span><br><span class="line">values.plot(kind&#x3D;&#39;kde&#39;, style&#x3D;&#39;k--&#39;)</span><br></pre></td></tr></table></figure>
<p>显示：<br><img src="/images/2020/08/31/d01f7ef0-a369-4c35-9fe4-8ec0ca33162c.png" alt="image.png"><br>根据小费数据画密度图如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tips[&#39;tip_pct&#39;].plot(kind&#x3D;&#39;kde&#39;)  # 利用高斯核生成核密度估计图</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br></pre></td></tr></table></figure>
<p>显示：<br><img src="/images/2020/08/31/80cd1041-8525-4e5d-9b98-26539d3c33e9.png" alt="image.png"><br>散点图scatter plot：<br>是观察两个一维数据序列之间的关系的有效手段，研究两个变量的关系，特别是是否有线性或曲线相关性。matplotlib的scatter方法是绘制散布图的主要方法。利用plt.scatter()即可轻松绘制一张简单的散布图。pandas也提供了能从DataFrame创建散步图矩阵的scatter_matrix()方法，还支持在对角线上放置变量的直方图或密度图。</p>
<p>画简单散点图如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df &#x3D; pd.DataFrame(np.random.rand(50, 4), columns&#x3D;[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])</span><br><span class="line">df.plot(kind&#x3D;&#39;scatter&#39;, x&#x3D;&#39;a&#39;, y&#x3D;&#39;b&#39;)</span><br><span class="line">df.plot(kind&#x3D;&#39;scatter&#39;, x&#x3D;&#39;a&#39;, y&#x3D;&#39;b&#39;,color&#x3D;&#39;DarkBlue&#39;, label&#x3D;&#39;Group 1&#39;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>显示：<br><img src="/images/2020/08/31/30cfe49b-05d1-48c2-9657-f14e596bae82.png" alt="image.png"><br>画散点矩阵图和直方图如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df &#x3D; pd.DataFrame(np.random.randn(1000, 4), columns&#x3D;[&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;])</span><br><span class="line">pd.plotting.scatter_matrix(df, alpha&#x3D;0.2)</span><br></pre></td></tr></table></figure>
<p>显示：<br><img src="/images/2020/08/31/46b41329-f7e8-4176-b181-e9b857ec2273.png" alt="image.png"><br>宏观经济数据macrodata.csv如下：<img src="/images/2020/08/31/4cecd949-5d70-460a-a7ad-35062a2b1dd4.png" alt="image.png"><br>读取和选取数据如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">macro &#x3D; pd.read_csv(&quot;macrodata.csv&quot;)</span><br><span class="line">data &#x3D; macro[[&#39;cpi&#39;, &#39;m1&#39;, &#39;tbilrate&#39;, &#39;unemp&#39;]]</span><br><span class="line">trans_data &#x3D; np.log(data).diff().dropna()</span><br><span class="line">trans_data[-5:]</span><br><span class="line">print(trans_data[-5:])</span><br><span class="line">plt.figure()</span><br></pre></td></tr></table></figure>
<p>打印：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">          cpi        m1  tbilrate     unemp</span><br><span class="line">198 -0.007904  0.045361 -0.396881  0.105361</span><br><span class="line">199 -0.021979  0.066753 -2.277267  0.139762</span><br><span class="line">200  0.002340  0.010286  0.606136  0.160343</span><br><span class="line">201  0.008419  0.037461 -0.200671  0.127339</span><br><span class="line">202  0.008894  0.012202 -0.405465  0.042560</span><br><span class="line"></span><br><span class="line">&lt;Figure size 432x288 with 0 Axes&gt;</span><br><span class="line"></span><br><span class="line">&lt;Figure size 432x288 with 0 Axes&gt;</span><br></pre></td></tr></table></figure>
<p>画散点图和散点矩阵图如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plt.scatter(trans_data[&#39;m1&#39;], trans_data[&#39;unemp&#39;])</span><br><span class="line">plt.title(&#39;Changes in log %s vs. log %s&#39; % (&#39;m1&#39;, &#39;unemp&#39;))</span><br><span class="line"></span><br><span class="line">pd.plotting.scatter_matrix(trans_data, diagonal&#x3D;&#39;kde&#39;, color&#x3D;&#39;k&#39;, alpha&#x3D;0.3)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>显示：<br><img src="/images/2020/08/31/47c3165b-9000-4630-a0ff-985577ddf1bf.png" alt="image.png"><br>可以简单看出各经济变量之间是否存在关系。</p>
<p>画饼图示意如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#饼图</span><br><span class="line">df &#x3D; pd.DataFrame(3 * np.random.rand(4, 2), index&#x3D;[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], columns&#x3D;[&#39;x&#39;, &#39;y&#39;])</span><br><span class="line">df.plot(kind&#x3D;&#39;pie&#39;, subplots&#x3D;True, figsize&#x3D;(8, 4))</span><br><span class="line">df.plot(kind&#x3D;&#39;pie&#39;, subplots&#x3D;True,autopct&#x3D;&#39;%.2f&#39;,figsize&#x3D;(8, 4)) # 显示百分比</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>显示：</p>
<p><img src="/images/2020/08/31/4c5306aa-8449-4498-9d66-dce7e58b0cdb.png" alt="image.png"></p>
<h1 id="4-pandas中绘图与matplotlib结合使用"><a href="#4-pandas中绘图与matplotlib结合使用" class="headerlink" title="4.pandas中绘图与matplotlib结合使用"></a>4.pandas中绘图与matplotlib结合使用</h1><p>有时候想方便地集成的绘图方式，比如df.plot()，但是又想加上matplotlib的很多操<br>作来增强图片的表现力，这时可以将两者结合。</p>
<p>构造数据如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df&#x3D;pd.DataFrame(np.random.randn(3,4),index&#x3D;list(&#39;123&#39;),columns&#x3D;list(&#39;ABCD&#39;))</span><br><span class="line">df2&#x3D;pd.DataFrame(np.random.randn(4,4),index&#x3D;list(&#39;1234&#39;),columns&#x3D;list(&#39;ABCD&#39;))</span><br><span class="line">display(df, df2)</span><br></pre></td></tr></table></figure>
<p>显示：<br><img src="/images/2020/08/31/86aac100-b34b-4aca-9ecd-5e469874fca2.png" alt="image.png"><br>可视化如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fig, axes &#x3D; plt.subplots(2, 1)</span><br><span class="line">df.plot(ax&#x3D;axes[0])</span><br><span class="line">df2.plot(ax&#x3D;axes[1])</span><br><span class="line">axes[0].set_title(&#39;3points&#39;)</span><br><span class="line">axes[1].set_title(&#39;4points&#39;)</span><br></pre></td></tr></table></figure>
<p>显示：<br><img src="/images/2020/08/31/7b962438-8a1c-456a-abdf-1d316a9672cd.png" alt="image.png"></p>
<h1 id="三、订单数据分析展示"><a href="#三、订单数据分析展示" class="headerlink" title="三、订单数据分析展示"></a>三、订单数据分析展示</h1><p>主要作图包括订单与GMV趋势、商家趋势、订单来源分布、类目占比，涉及折线图、饼图、堆积柱形图、组合图等类型，目标是综合使用pandas和matplotlib。</p>
<p>订单数据.csv如下：<br><img src="/images/2020/08/31/4dd386a4-1cab-40b8-bac0-71a6acc388c0.png" alt="image.png"><br>导库和读取数据如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#导入库</span><br><span class="line">import pandas as pd</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line"># plt.rcParams[&#39;font.sans-serif&#39;] &#x3D; [&#39;SimHei&#39;]  #显示中文标签</span><br><span class="line"># plt.rcParams[&#39;axes.unicode_minus&#39;] &#x3D; False  #显示符号</span><br><span class="line"></span><br><span class="line">#读取数据</span><br><span class="line">orders &#x3D; pd.read_excel(&quot;订单数据.xlsx&quot;)</span><br><span class="line">orders[&#39;付款时间&#39;] &#x3D; orders[&#39;付款时间&#39;].astype(&#39;str&#39;)  #方便作图，将日期改为字符串格式</span><br></pre></td></tr></table></figure>
<p>不同日期订单金额折线图如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#折线图</span><br><span class="line">data1 &#x3D; orders.groupby(&#39;付款时间&#39;)[&#39;支付金额&#39;].sum()  #处理数据</span><br><span class="line">x &#x3D; data1.index   #x值</span><br><span class="line">y &#x3D; data1.values  #y值</span><br><span class="line"></span><br><span class="line">plt.title(&#39;GMV走势&#39;)  #图表标题</span><br><span class="line">plt.plot(x,y,label&#x3D;&#39;GMV&#39;,color&#x3D;&#39;red&#39;)    #label是图例，color是线条颜色</span><br><span class="line">plt.legend(loc&#x3D;1)  #显示图例,loc设置图例展示位置，默认为0（最优位置）、1右上角、2左上角</span><br><span class="line">plt.show()   #显示图</span><br></pre></td></tr></table></figure>
<p>显示：<br><img src="/images/2020/08/31/13dbed0b-f541-45ea-84f9-3502476fb18f.png" alt="image.png"><br>可以看出不同时间订单金额的变化趋势，找出哪些天订单金额较高、哪些天较低。</p>
<p>还可以用柱状图显示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#柱形图</span><br><span class="line">data1 &#x3D; orders.groupby(&#39;付款时间&#39;)[&#39;支付金额&#39;].sum()  #处理数据</span><br><span class="line">x &#x3D; data1.index   #x值</span><br><span class="line">y &#x3D; data1.values  #y值</span><br><span class="line"></span><br><span class="line">plt.title(&#39;GMV走势&#39;)  #图表标题</span><br><span class="line">plt.bar(x,y,label&#x3D;&#39;GMV&#39;,color&#x3D;&#39;green&#39;)    #其实很简单，只要把plot换成bar</span><br><span class="line">plt.legend(loc&#x3D;1)  #显示图例,loc设置图例展示位置，默认为0（最优位置）、1右上角、2左上角</span><br><span class="line">plt.show()   #显示图</span><br></pre></td></tr></table></figure>
<p>显示：<br><img src="/images/2020/08/31/d5822558-d2ae-48e4-8a25-bc91e4ff27f7.png" alt="image.png"><br>还可以用饼图直观看出各天所占的比例：<br>#饼图<br>data1 = orders.groupby(‘付款时间’)[‘支付金额’].sum()  #处理数据<br>x = data1.index   #x值<br>y = data1.values  #y值</p>
<p>plt.title(‘GMV饼图’)  #图表标题<br>plt.axis(‘equal’)   #正圆，饼图会默认是椭圆<br>plt.pie(y,labels=x,autopct=’%1.1f%%’,<br>        colors=[‘green’,’red’,’skyblue’,’blue’])    #labels是标签，autopct是占比保留1位小数<br>plt.show()   #显示图<br>显示：<br><img src="/images/2020/08/31/3fb4884b-7f19-458a-b953-d37cc251f37d.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>01.Docker基础知识</title>
    <url>/01-Docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="1-什么是Docker"><a href="#1-什么是Docker" class="headerlink" title="1. 什么是Docker"></a>1. 什么是Docker</h1><p><strong>Docker</strong>是一个<a href="https://zh.wikipedia.org/wiki/開放原始碼" target="_blank" rel="noopener">开放源代码</a>软件项目，让应用程序部署在<a href="https://zh.wikipedia.org/wiki/作業系統層虛擬化" target="_blank" rel="noopener">软件货柜</a>下的工作可以自动化进行，借此在<a href="https://zh.wikipedia.org/wiki/Linux" target="_blank" rel="noopener">Linux</a>操作系统上，提供一个额外的软件<a href="https://zh.wikipedia.org/wiki/抽象層" target="_blank" rel="noopener">抽象层</a>，以及<a href="https://zh.wikipedia.org/wiki/作業系統層虛擬化" target="_blank" rel="noopener">操作系统层虚拟化</a>的自动管理机制</p>
<p>依据行业分析公司“451研究”：“Dockers是有能力打包应用程序及其虚拟容器，可以在任何Linux服务器上运行的依赖性工具，这有助于实现灵活性和便携性，应用程序在任何地方都可以运行，无论是公有云、私有云、单机等。”</p>
<p><strong>简单来说,Docker 通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“一次封装，到处运行”。</strong></p>
<h1 id="2-为什么-Docker-如此流行"><a href="#2-为什么-Docker-如此流行" class="headerlink" title="2. 为什么 Docker 如此流行?"></a>2. 为什么 Docker 如此流行?</h1><p>一款产品从开发到上线，从操作系统，到运行环境，再到应用配置。作为开发+运维之间的协作我们需要关心很多东西，这也是很多互联网公司都不得不面对的问题，特别是各种版本的迭代之后，不同版本环境的兼容，对运维人员都是考验</p>
<p>Docker之所以发展如此迅速，也是因为它对此给出了一个标准化的解决方案。</p>
<p>环境配置如此麻烦，换一台机器，就要重来一次，费力费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作”的问题。</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200525135454.png" alt=""></p>
<p>之前在服务器配置一个应用的运行环境，要安装各种软件，随便拿一个 Java 项目来说，Java/Tomcat/MySQL/JDBC驱动包基本是必不可少的。安装和配置这些东西有多麻烦就不说了，它还不能跨平台。假如我们是在 Windows 上安装的这些环境，到了 Linux 又得重新装。况且就算不跨操作系统，换另一台同样操作系统的服务器，要移植应用也是非常麻烦的。</p>
<p>传统上认为，软件编码开发/测试结束后，所产出的成果即是程序或是能够编译执行的二进制字节码等(java为例)。而为了让这些程序可以顺利执行，开发团队也得准备完整的部署文件，让维运团队得以部署应用程式，开发需要清楚的告诉运维部署团队，用的全部配置文件+所有软件环境。不过，即便如此，仍然常常发生部署失败的状况。</p>
<p><strong>Docker镜像的设计，使得Docker得以打破过去「程序即应用」的观念。透过镜像(images)将作业系统核心除外，运作应用程式所需要的系统环境，由下而上打包，达到应用程式跨平台间的无缝接轨运作。</strong></p>
<h1 id="3-Docker-的理念"><a href="#3-Docker-的理念" class="headerlink" title="3. Docker 的理念"></a>3. Docker 的理念</h1><p>Docker是基于Go语言实现的云开源项目。</p>
<p>Docker的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“一次封装，到处运行”。</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200525135659.png" alt=""></p>
<p>Linux 容器技术的出现就解决了这样一个问题，而 Docker 就是在它的基础上发展过来的。将应用运行在 Docker 容器上面，而 Docker 容器在任何操作系统上都是一致的，这就实现了<code>跨平台、跨服务器</code>。只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作(可以参考一下 Java 的一次编译,处处运行特性)</p>
<blockquote>
<p>简单来说,Docker 的出现解决了运行环境和配置问题软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术</p>
</blockquote>
<h1 id="4-Docker-虚拟化"><a href="#4-Docker-虚拟化" class="headerlink" title="4. Docker 虚拟化"></a>4. Docker 虚拟化</h1><ul>
<li><p>虚拟机技术</p>
<p>虚拟机（virtual machine）就是带环境安装的一种解决方案。 它可以在一种操作系统里面运行另一种操作系统，比如在Windows 系统里面运行Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美的运行了另一套系统，能够使应用程序，操作系统和硬件三者之间的逻辑不变。</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200525140019.png" alt=""></p>
<p>虚拟机的缺点：</p>
<ol>
<li>资源占用多</li>
<li>冗余步骤多</li>
<li>启动慢</li>
</ol>
</li>
</ul>
<ul>
<li><p>容器虚拟化技术</p>
<p>由于前面虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。 Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。</p>
</li>
</ul>
<p>  <img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200525140222.png" alt=""></p>
<p>比较 Docker 和传统虚拟化方式的不同之处：</p>
<ul>
<li><p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；</p>
</li>
<li><p>而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p>
</li>
<li><p>每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。</p>
</li>
</ul>
<h1 id="5-Docker的优势"><a href="#5-Docker的优势" class="headerlink" title="5. Docker的优势"></a>5. Docker的优势</h1><ol>
<li><p>更快速的应用交付和部署</p>
<p>传统的应用开发完成后，需要提供一堆安装程序和配置说明文档，安装部署后需根据配置文档进行繁杂的配置才能正常运行。Docker化之后只需要交付少量容器镜像文件，在正式生产环境加载镜像并运行即可，应用安装配置在镜像里已经内置好，大大节省部署配置和测试验证时间。</p>
</li>
<li><p>更便捷的升级和扩缩容</p>
<p>随着微服务架构和Docker的发展，大量的应用会通过微服务方式架构，应用的开发构建将变成搭乐高积木一样，每个Docker容器将变成一块“积木”，应用的升级将变得非常容易。当现有的容器不足以支撑业务处理时，可通过镜像运行新的容器进行快速扩容，使应用系统的扩容从原先的天级变成分钟级甚至秒级。</p>
</li>
<li><p>更简单的系统运维</p>
<p>应用容器化运行后，生产环境运行的应用可与开发、测试环境的应用高度一致，容器会将应用程序相关的环境和状态完全封装起来，不会因为底层基础架构和操作系统的不一致性给应用带来影响，产生新的BUG。当出现程序异常时，也可以通过测试环境的相同容器进行快速定位和修复。</p>
</li>
<li><p>更高效的计算资源利用</p>
<p>Docker是内核级虚拟化，其不像传统的虚拟化技术一样需要额外的Hypervisor支持，所以在一台物理机上可以运行很多个容器实例，可大大提升物理服务器的CPU和内存的利用率。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>03.Docker 常用命令</title>
    <url>/03-Docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="1-帮助命令"><a href="#1-帮助命令" class="headerlink" title="1. 帮助命令"></a>1. 帮助命令</h1><ul>
<li><p>docker version</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200525150924.png" alt=""></p>
</li>
<li><p>docker info</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200525151007.png" alt=""></p>
</li>
<li><p>docker –help(-h)</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200525151103.png" alt=""></p>
</li>
</ul>
<h1 id="2-镜像命令"><a href="#2-镜像命令" class="headerlink" title="2. 镜像命令"></a>2. 镜像命令</h1><ol>
<li><p>docker images         列出本地主机上的镜像</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200525152014.png" alt=""></p>
<ul>
<li><p>REPOSITORY：表示镜像的仓库源</p>
</li>
<li><p>TAG：镜像的标签</p>
</li>
<li><p>IMAGE ID：镜像ID</p>
</li>
<li><p>CREATED：镜像创建时间</p>
</li>
<li><p>SIZE：镜像大小</p>
</li>
</ul>
</li>
</ol>
<pre><code>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。 如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像</code></pre><ul>
<li><p>images 命令 的 option 参数</p>
<ul>
<li><p>-a:列出本地所有的镜像（含中间映像层）</p>
</li>
<li><p>-q :只显示镜像ID</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200525152339.png" alt=""></p>
</li>
<li><p>–digests :显示镜像的摘要信息</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200525152552.png" alt=""></p>
</li>
<li><p>–no-trunc :显示完整的镜像信息</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200525152638.png" alt=""></p>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li><p>docker search 镜像名           从 Docker hub 官网搜索镜像</p>
<p>以 tomcat 为例</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200525152813.png" alt=""></p>
<p>和在官网搜索的结果一模一样</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200525152954.png" alt=""></p>
</li>
</ol>
<ul>
<li><p>参数说明</p>
<ul>
<li><p>-s : 列出收藏数不小于指定值的镜像</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200525153109.png" alt=""></p>
<p>只搜索点赞数大于30的镜像</p>
</li>
<li><p>–no-trunc : 显示完整的镜像描述</p>
</li>
<li><p>–automated : 只列出 automated build类型的镜像</p>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li><p>docker pull 镜像名:tag     拉取镜像(从前面我们已经设置的阿里云的镜像加速地址)</p>
<p>如果 <code>docker pull 镜像名</code> 后面不加参数,默认下载最新版本</p>
<p>即 docker pull tomcat 等价于 docker pull tomcat:latest</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull tomcat</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200525153705.png" alt=""></p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200525153806.png" alt=""></p>
</li>
<li><p>docker rmi 镜像名/镜像id          删除 Docker 镜像</p>
<p>ps: <code>docker rmi 镜像名</code> 默认会删除标签为 :latest 的镜像,如果要删除指定标签的镜像,在镜像名后面指定 tag 即可</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200525153922.png" alt=""></p>
<p>如果无法删除,出现如上提示,表示我们的镜像正在使用中,可以使用 -f 强制删除</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200525153954.png" alt=""></p>
<p>如果想要删除多个镜像</p>
<p>docker rmi -f 镜像名1:tag 镜像名2:tag</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker rmi -f hello-world tomcat</span><br></pre></td></tr></table></figure>

<p>删除全部镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker rmi -f $(docker images -qa)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="3-容器命令"><a href="#3-容器命令" class="headerlink" title="3. 容器命令"></a>3. 容器命令</h1><ol>
<li><p>以 CentOS 为例,从阿里云下载一个 CentOS 的镜像</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526090859.png" alt=""></p>
</li>
<li><p>新建并启动容器(以 Docker 里面的 CentOS 镜像为例)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run [options] image [command] [arg...]</span><br></pre></td></tr></table></figure>

<p>options 这里常用的有:</p>
<p>–name=”容器新名字”: 为容器指定一个名称； -d: 后台运行容器，并返回容器ID，也即启动守护式容器； -i：以交互模式运行容器，通常与 -t 同时使用； -t：为容器重新分配一个伪输入终端，通常与 -i 同时使用； -P: 随机端口映射； -p: 指定端口映射，有以下四种格式 </p>
<p><code>1.ip:hostPort:containerPort  2.ip::containerPort  3.hostPort:containerPort 4.containerPort</code></p>
<p>我们使用 -it 参数来启动 CentOS 容器</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526092354.png" alt=""></p>
<p>root@ 后面跟着的就是该容器的 id</p>
</li>
</ol>
<ol start="3">
<li><p>查看所有运行的容器命令</p>
<p>docker ps [options]</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526092457.png" alt=""></p>
<p>参数说明:</p>
<p>-a :列出当前所有正在运行的容器+历史上运行过的容器 -l :显示最近运行的容器。 -n number：显示最近 number 个创建的容器。 -q :静默模式，只显示容器编号。 –no-trunc :不截断输出。</p>
</li>
</ol>
<ol start="4">
<li><p>退出容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exit: 容器停止并退出</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>ctrl+p+q: 容器不停止退出<br>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">5. 启动已经创建的容器</span><br></pre></td></tr></table></figure><br>docker start 容器id/容器名<br>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">6. 重启容器</span><br></pre></td></tr></table></figure><br>docker restart 容器id/容器名<br>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">7. 停止容器</span><br></pre></td></tr></table></figure><br>docker stop 容器id/容器名<br>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">8. 强制关闭容器</span><br></pre></td></tr></table></figure><br>docker kill 容器id/容器名<br>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">9. 删除已停止的容器</span><br></pre></td></tr></table></figure><br>   docker rm 容器id/容器名<br>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">一次性删除多个已经停止的容器</span><br></pre></td></tr></table></figure><br>   docker rm -f $(docker ps -qa) 或者 docker ps -a -q | xargs docker rm<br>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">10. 交互式容器和守护式容器</span><br><span class="line"></span><br><span class="line">    前面启动 CentOS 容器使用的 -it 参数就是表示交互式命令,通过终端来保持和容器的交互</span><br><span class="line"></span><br><span class="line">    如果要启动守护式容器,那么需要加上 -d 参数</span><br><span class="line"></span><br><span class="line">    ![](https:&#x2F;&#x2F;gitee.com&#x2F;krislin_zhao&#x2F;IMGcloud&#x2F;raw&#x2F;master&#x2F;img&#x2F;20200526093221.png)</span><br><span class="line"></span><br><span class="line">    但是此时查询正在运行的容器，没有发现以后台模式运行的 Docker 容器</span><br><span class="line"></span><br><span class="line">    ![](https:&#x2F;&#x2F;gitee.com&#x2F;krislin_zhao&#x2F;IMGcloud&#x2F;raw&#x2F;master&#x2F;img&#x2F;20200526093331.png)</span><br><span class="line"></span><br><span class="line">    发现该容器已经自动退出了</span><br><span class="line"></span><br><span class="line">    &gt; 问题：docker ps -a 进行查看, 会发现容器已经退出 很重要的一点: Docker容器后台运行,就必须有一个前台进程. 容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），是会自动退出的。</span><br><span class="line">    &gt;</span><br><span class="line">    &gt; 这个是docker的机制问题,比如你的web容器,我们以nginx为例，正常情况下,我们配置启动服务只需要启动响应的service即可。例如 service nginx start 但是,这样做,nginx为后台进程模式运行,就导致docker前台没有运行的应用, 这样的容器后台启动后,会立即自杀因为他觉得他没事可做了. 所以，最佳的解决方案是,将你要运行的程序以前台进程的形式运行</span><br><span class="line"></span><br><span class="line">11. 容器日志</span><br><span class="line"></span><br><span class="line">    对于后台运行的容器,可以以下面的方式来启动</span><br><span class="line"></span><br><span class="line">    &#96;&#96;&#96;shell</span><br><span class="line">    docker run -d --name centos02 centos &#x2F;bin&#x2F;sh -c &quot;while true;do echo hello world;sleep 2;done&quot;</span><br></pre></td></tr></table></figure></p>
<pre><code>![](https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526093745.png)

即便是后台启动,但是因为前台一直打印日志,Docker 容器也不会自动关闭

如果此时我们想去查看 Docker 容器的日志,可以通过以下命令

docker logs -f -t --tail 容器ID/容器名

- -t 是加入时间戳

- -f 跟随最新的日志打印

- --tail 数字 显示最后多少条

  ![](https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526094051.png)</code></pre><ol start="12">
<li><p>查看容器内运行的进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker top 容器ID&#x2F;容器名</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526094217.png" alt=""></p>
</li>
<li><p>查看容器内部细节</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker inspect 容器ID&#x2F;容器名</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526094333.png" alt=""></p>
</li>
<li><p>进入正在运行的容器并以命令行交互</p>
<p>重新进入正在运行的容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker attach 容器ID/容器名</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526094831.png" alt=""></p>
<p>还有一种方式是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器ID&#x2F;容器名 bash(功能更加强大,可以直接返回结果到客户端)</span><br></pre></td></tr></table></figure>

<p>区别在于:</p>
<p>attach 命令直接进入容器启动命令的终端，不会启动新的进程</p>
<p>exec 命令是在容器中打开新的终端，并且可以启动新的进程</p>
</li>
<li><p>从容器内拷贝文件到主机上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker cp 容器ID(或容器名):容器内路径 目的主机路径</span><br></pre></td></tr></table></figure>

<p>示例如下</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526095315.png" alt=""></p>
</li>
</ol>
<h1 id="4-常用命令总结"><a href="#4-常用命令总结" class="headerlink" title="4. 常用命令总结"></a>4. 常用命令总结</h1><p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526095411.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">attach    Attach to a running container                 # 当前 shell 下 attach 连接指定运行镜像</span><br><span class="line"></span><br><span class="line">build     Build an image from a Dockerfile              # 通过 Dockerfile 定制镜像</span><br><span class="line"></span><br><span class="line">commit    Create a new image from a container changes   # 提交当前容器为新的镜像</span><br><span class="line"></span><br><span class="line">cp        Copy files&#x2F;folders from the containers filesystem to the host path   #从容器中拷贝指定文件或者目录到宿主机中</span><br><span class="line"></span><br><span class="line">create    Create a new container                        # 创建一个新的容器，同 run，但不启动容器</span><br><span class="line"></span><br><span class="line">diff      Inspect changes on a container&#39;s filesystem   # 查看 docker 容器变化</span><br><span class="line"></span><br><span class="line">events    Get real time events from the server          # 从 docker 服务获取容器实时事件</span><br><span class="line"></span><br><span class="line">exec      Run a command in an existing container        # 在已存在的容器上运行命令</span><br><span class="line"></span><br><span class="line">export    Stream the contents of a container as a tar archive   # 导出容器的内容流作为一个 tar 归档文件[对应 import ]</span><br><span class="line"></span><br><span class="line">history   Show the history of an image                  # 展示一个镜像形成历史</span><br><span class="line"></span><br><span class="line">images    List images                                   # 列出系统当前镜像</span><br><span class="line"></span><br><span class="line">import    Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]</span><br><span class="line"></span><br><span class="line">info      Display system-wide information               # 显示系统相关信息</span><br><span class="line"></span><br><span class="line">inspect   Return low-level information on a container   # 查看容器详细信息</span><br><span class="line"></span><br><span class="line">kill      Kill a running container                      # kill 指定 docker 容器</span><br><span class="line"></span><br><span class="line">load      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]</span><br><span class="line"></span><br><span class="line">login     Register or Login to the docker registry server    # 注册或者登陆一个 docker 源服务器</span><br><span class="line"></span><br><span class="line">logout    Log out from a Docker registry server          # 从当前 Docker registry 退出</span><br><span class="line"></span><br><span class="line">logs      Fetch the logs of a container                 # 输出当前容器日志信息</span><br><span class="line"></span><br><span class="line">port      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT    # 查看映射端口对应的容器内部源端口</span><br><span class="line"></span><br><span class="line">pause     Pause all processes within a container        # 暂停容器</span><br><span class="line"></span><br><span class="line">ps        List containers                               # 列出容器列表</span><br><span class="line"></span><br><span class="line">pull      Pull an image or a repository from the docker registry server   # 从docker镜像源服务器拉取指定镜像或者库镜像</span><br><span class="line"></span><br><span class="line">push      Push an image or a repository to the docker registry server    # 推送指定镜像或者库镜像至docker源服务器</span><br><span class="line"></span><br><span class="line">restart   Restart a running container                   # 重启运行的容器</span><br><span class="line"></span><br><span class="line">rm        Remove one or more containers                 # 移除一个或者多个容器</span><br><span class="line"></span><br><span class="line">rmi       Remove one or more images             # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</span><br><span class="line"></span><br><span class="line">run       Run a command in a new container              # 创建一个新的容器并运行一个命令</span><br><span class="line"></span><br><span class="line">save      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 </span><br><span class="line"></span><br><span class="line">load]</span><br><span class="line"></span><br><span class="line">search    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像</span><br><span class="line"></span><br><span class="line">start     Start a stopped containers                    # 启动容器</span><br><span class="line"></span><br><span class="line">stop      Stop a running containers                     # 停止容器</span><br><span class="line"></span><br><span class="line">tag       Tag an image into a repository                # 给源中镜像打标签</span><br><span class="line"></span><br><span class="line">top       Lookup the running processes of a container   # 查看容器中运行的进程信息</span><br><span class="line"></span><br><span class="line">unpause   Unpause a paused container                    # 取消暂停容器</span><br><span class="line"></span><br><span class="line">version   Show the docker version information           # 查看 docker 版本号</span><br><span class="line"></span><br><span class="line">wait      Block until a container stops, then print its exit code   # 截取容器停止时的退出状态值</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>02.Docker 安装</title>
    <url>/02-Docker-%E5%AE%89%E8%A3%85.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="1-前提"><a href="#1-前提" class="headerlink" title="1. 前提"></a>1. 前提</h1><p>当前 Docker 基本都装在 Linux 环境下,以 CentOS 为例,建议 CentOS6.5 以上版本,目前主流 CentOS6.8 和 CentOS7.x 都支持</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200525141301.png" alt=""></p>
<h1 id="2-Docker三要素"><a href="#2-Docker三要素" class="headerlink" title="2. Docker三要素"></a>2. Docker三要素</h1><ul>
<li><p>镜像(Image)</p>
<p>Docker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200525141456.png" alt=""></p>
</li>
<li><p>容器(Container)</p>
<p>Docker 利用容器（Container）独立运行一个或一组应用。容器是用镜像创建的运行实例。</p>
<p>它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。</p>
<p>可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</p>
<p>容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。</p>
</li>
<li><p>仓库（Repository）</p>
<p>仓库（Repository）是集中存放镜像文件的场所。</p>
<p><em>仓库(Repository)和仓库注册服务器（Registry）是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。</em></p>
<p>仓库分为公开仓库（Public）和私有仓库（Private）两种形式。 最大的公开仓库是 Docker Hub(<a href="https://hub.docker.com/" target="_blank" rel="noopener">hub.docker.com/</a>)， 存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云 、网易云等</p>
</li>
</ul>
<blockquote>
<p>需要正确的理解仓库/镜像/容器这几个概念:</p>
<p>Docker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就是 image镜像文件。只有通过这个镜像文件才能生成容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p>
<ul>
<li>image 文件生成容器实例，称为镜像文件。</li>
<li>一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器</li>
<li>至于仓库，就是放了一堆镜像的地方，我们可以把镜像发布到仓储中，需要的时候从仓储中拉下来就可以了。</li>
</ul>
</blockquote>
<p>Docker 简易流程图</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200525141906.png" alt=""></p>
<h1 id="3-安装Docker"><a href="#3-安装Docker" class="headerlink" title="3. 安装Docker"></a>3. 安装Docker</h1><p>可以参考<a href="https://docs.docker.com/engine/install/centos/" target="_blank" rel="noopener">官方文档</a></p>
<h2 id="1-删除旧版本"><a href="#1-删除旧版本" class="headerlink" title="1. 删除旧版本"></a>1. 删除旧版本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>

<h2 id="2-三种方法"><a href="#2-三种方法" class="headerlink" title="2. 三种方法"></a>2. 三种方法</h2><p>可以参考<a href="https://docs.docker.com/engine/install/centos/" target="_blank" rel="noopener">官方文档</a>中的三种方法任选一种进行下载。</p>
<p>我用的是第三种方式：脚本下载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh</span><br></pre></td></tr></table></figure>

<h2 id="3-Docker版本"><a href="#3-Docker版本" class="headerlink" title="3. Docker版本"></a>3. Docker版本</h2><p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200525144151.png" alt=""></p>
<h2 id="4-启动-Docker"><a href="#4-启动-Docker" class="headerlink" title="4. 启动 Docker"></a>4. 启动 Docker</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200525144532.png" alt=""></p>
<h1 id="4-Docker-镜像加速"><a href="#4-Docker-镜像加速" class="headerlink" title="4. Docker 镜像加速"></a>4. Docker 镜像加速</h1><p>以阿里云为例,首先注册一个阿里云账号,然后进入镜像加速页面</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200525145414.png" alt=""></p>
<p>配置本机的 Docker 文件</p>
<p>如果没有<code>/etc/docker/daemon.json</code>就自己创建</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim `/etc/docker/daemon.json`</span><br></pre></td></tr></table></figure>

<p>重启 Docker 服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<h1 id="5-hello-world"><a href="#5-hello-world" class="headerlink" title="5. hello world"></a>5. hello world</h1><p>直接通过 <code>docker run hello-world</code> 命令,我们可以直接从阿里云拉取 hello-world 镜像并创建容器自动运行(在本地没有找到 hello-world 的镜像时)</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200525145905.png" alt=""></p>
<p>docker run 命令运行流程图</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200525145919.png" alt=""></p>
<h1 id="6-Docker-和-VM-比较"><a href="#6-Docker-和-VM-比较" class="headerlink" title="6. Docker 和 VM 比较"></a>6. Docker 和 VM 比较</h1><ul>
<li><p>Docker 工作原理</p>
<p>Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上，然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。容器，是一个运行时环境，就是我们前面说到的集装箱。</p>
<p>例如下面 Docker 图标(一只鲸鱼背上拖着很多个集装箱, 鲸鱼类似于 Docker,一个个的集装箱就是软件开发环境中的各种软件)</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200525150049.png" alt=""></p>
<p>以下为 Docker 运行架构图</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200525150122.png" alt=""></p>
</li>
<li><p>为什么 Docker 运行速度远大于 VM?</p>
<ol>
<li><p>Docker有着比虚拟机更少的抽象层。由于docker不需要Hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。</p>
</li>
<li><p>Docker利用的是宿主机的内核,而不需要CentOS。因此,当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。从而避免加载操作系统内核这个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载CentOS,整个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,因此新建一个docker容器只需要几秒钟。</p>
</li>
</ol>
</li>
<li><p>Docker 和 VM 对比图</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200525150538.png" alt=""></p>
</li>
<li><p>Docker 和 VM 特点对比图</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200525150633.png" alt=""></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>04.Docker镜像</title>
    <url>/04-Docker%E9%95%9C%E5%83%8F.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p>
<p>而 Docker 镜像的底层实现原理是 UnionFS 联合文件系统</p>
<h1 id="1-UnionFS-联合文件系统"><a href="#1-UnionFS-联合文件系统" class="headerlink" title="1. UnionFS 联合文件系统"></a>1. UnionFS 联合文件系统</h1><p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<p>类似于花卷这种常见的早餐,文件系统可以通过一层一层的嵌套,对外暴露统一的”表面层”来供使用者操作</p>
<blockquote>
<p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p>
</blockquote>
<h1 id="2-Docker-镜像加载原理"><a href="#2-Docker-镜像加载原理" class="headerlink" title="2. Docker 镜像加载原理"></a>2. Docker 镜像加载原理</h1><p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</p>
<p>bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p>
<p>rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526100200.png" alt=""></p>
<p><strong>平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M？？</strong></p>
<p>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。</p>
<p>通过 docker pull 命令再来感受一下镜像分层</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526100811.png" alt=""></p>
<p>所以在下载的过程中我们可以看到docker的镜像好像是在一层一层的在下载</p>
<p><strong>为什么 Docker 镜像要采用这种分层结构呢?</strong></p>
<p>最大的一个好处就是 - <code>共享资源</code></p>
<p>比如：有多个镜像都从相同的 base 镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像， 同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p>
<p>所以,Docker镜像都是只读的,当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p>
<h1 id="3-Docker-镜像-commit-操作"><a href="#3-Docker-镜像-commit-操作" class="headerlink" title="3. Docker 镜像 commit 操作"></a>3. Docker 镜像 commit 操作</h1><p>基础命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker commit 用于提交容器副本使之成为一个新的镜像</span><br></pre></td></tr></table></figure>

<p>完整格式如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker commit -m&#x3D;“提交的描述信息” -a&#x3D;“作者” 容器ID 要创建的目标镜像名:[标签名]</span><br></pre></td></tr></table></figure>

<p>以 Tomcat 为例</p>
<p>可以看我的这篇文章<a href="./Docker方式启动tomcat,访问首页出现404错误.md">Docker方式启动tomcat,访问首页出现404错误</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>05.Docker容器数据卷</title>
    <url>/05-Docker%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="1-什么是-Docker-容器数据卷"><a href="#1-什么是-Docker-容器数据卷" class="headerlink" title="1. 什么是 Docker 容器数据卷"></a>1. 什么是 Docker 容器数据卷</h1><p>需求:</p>
<ul>
<li>Docker 可以将运行的环境打包形成容器运行，但是我们对 Docker 容器的数据的要求希望是持久化的</li>
<li>容器之间希望共享数据</li>
</ul>
<p>Docker容器产生的数据，如果不通过docker commit生成新的镜像，使得数据做为镜像的一部分保存下来， 那么当容器删除后，数据自然也就没有了。</p>
<p>为了能保存数据在docker中我们使用数据卷。</p>
<p>类似 Redis里面的rdb和aof文件或者我们平时使用的移动硬盘</p>
<h1 id="2-数据卷的用处"><a href="#2-数据卷的用处" class="headerlink" title="2. 数据卷的用处"></a>2. 数据卷的用处</h1><p>数据卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：</p>
<p>数据卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷</p>
<p>特点：</p>
<ol>
<li>数据卷可在容器之间共享或重用数据</li>
<li>卷中的更改可以直接生效</li>
<li>数据卷中的更改不会包含在镜像的更新中</li>
<li>数据卷的生命周期一直持续到没有容器使用它为止</li>
</ol>
<h1 id="3-数据卷使用"><a href="#3-数据卷使用" class="headerlink" title="3. 数据卷使用"></a>3. 数据卷使用</h1><h2 id="一-直接通过命令添加数据卷"><a href="#一-直接通过命令添加数据卷" class="headerlink" title="一. 直接通过命令添加数据卷"></a>一. 直接通过命令添加数据卷</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it -v &#x2F;宿主机绝对路径目录:&#x2F;容器内目录 镜像名</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526102438.png" alt=""></p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526102631.png" alt=""></p>
<p>验证数据卷是否挂载成功</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526102934.png" alt=""></p>
<p>宿主机和容器之间的数据交互</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200713083636.png" alt=""></p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526103254.png" alt=""></p>
<p>同理, 容器可以对数据进行修改并同步到宿主机</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526103411.png" alt=""></p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526103517.png" alt=""></p>
<p>容器停止退出后，主机修改后数据是否同步</p>
<p>通过 exit 命令停止容器并退出终端</p>
<p>然后在宿主机对数据进行修改</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526103801.png" alt=""></p>
<p>重新开启容器</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526103919.png" alt=""></p>
<p>可以发现,即便是容器关闭,宿主机依然可以对数据卷进行数据操作,当容器重新开启时,数据卷会自动进行同步</p>
<p>如果想要设置权限,例如容器只能对数据卷进行读和同步,宿主机可以操作数据卷,那么只需要添加一个参数即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it -v &#x2F;宿主机绝对路径目录:&#x2F;容器内目录:ro 镜像名</span><br></pre></td></tr></table></figure>

<p><code>ro</code> 就表示 read-only 权限(针对容器)</p>
<h2 id="二-DockerFile添加数据卷"><a href="#二-DockerFile添加数据卷" class="headerlink" title="二. DockerFile添加数据卷"></a>二. DockerFile添加数据卷</h2><p>DockerFile 简单来说,就是描述 Docker 镜像的描述文件</p>
<p>流程简单梳理如下</p>
<ol>
<li><p>宿主机新建一个 DockerFile</p>
<p>可在Dockerfile中使用VOLUME指令来给镜像添加一个或多个数据卷</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526104550.png" alt=""></p>
<p>ps: 出于可移植和分享的考虑，用-v 主机目录:容器目录这种方法不能够直接在Dockerfile中实现。 <strong>由于宿主机目录是依赖于特定宿主机的，并不能够保证在所有的宿主机上都存在这样的特定目录</strong>。</p>
</li>
<li><p>build 构建镜像</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526104923.png" alt=""></p>
</li>
<li><p>根据镜像运行容器</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526105208.png" alt=""></p>
</li>
<li><p>测试数据卷</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526105424.png" alt=""></p>
<p>根据 inspect 命令查看对应的宿主机数据卷目录</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526105821.png" alt=""></p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526105932.png" alt=""></p>
<p>默认宿主机挂载地址需要通过 inspect 命令查看</p>
</li>
</ol>
<h2 id="三-数据卷容器"><a href="#三-数据卷容器" class="headerlink" title="三. 数据卷容器"></a>三. 数据卷容器</h2><p>主要用于容器和容器之间的数据共享</p>
<p>命令: –volumes-from</p>
<p>示例如下:</p>
<ol>
<li><p>启动一个父容器</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526110256.png" alt=""></p>
<p>启动后我们在指定目录下创建一个文件</p>
</li>
<li><p>新建两个子容器,继承自父容器</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526110556.png" alt=""></p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526110648.png" alt=""></p>
<p>可以发现成功同步了父容器的数据</p>
<p>同时修改任意一个子容器的数据卷数据,都会同步到其他容器</p>
<p>即便是删除任意一个容器,数据卷的数据同步不会停止</p>
</li>
</ol>
<ol start="3">
<li><p>结论</p>
<p>容器之间共享数据的传递，数据卷的生命周期一直持续到没有容器使用它为止</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>06.DockerFile解析</title>
    <url>/06-DockerFile%E8%A7%A3%E6%9E%90.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="1-什么是-DockerFile"><a href="#1-什么是-DockerFile" class="headerlink" title="1. 什么是 DockerFile"></a>1. 什么是 DockerFile</h1><p>Dockerfile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。</p>
<p>通常使用 DockerFile 的三个步骤都是:</p>
<ol>
<li>编写 DockerFile 文件</li>
<li>执行 docker build 编译命令</li>
<li>执行docker run 启动容器命令</li>
</ol>
<p>以 CentOS 为例, Docker Hub 上的 CentOS 的 DockerFile 文件如下</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526132103.png" alt=""></p>
<h1 id="2-DockerFile-构建过程解析"><a href="#2-DockerFile-构建过程解析" class="headerlink" title="2. DockerFile 构建过程解析"></a>2. DockerFile 构建过程解析</h1><h2 id="DockerFile-基础知识"><a href="#DockerFile-基础知识" class="headerlink" title="DockerFile 基础知识"></a>DockerFile 基础知识</h2><p>以上面的 CentOS DockerFile 文件为例</p>
<ol>
<li>每条保留字指令(红色字体)都必须为大写字母且后面要跟随至少一个参数</li>
<li>指令按照从上到下，顺序执行</li>
<li>#表示注释</li>
<li>每条指令都会创建一个新的镜像层，并对镜像进行提交</li>
</ol>
<h2 id="Docker执行Dockerfile的大致流程"><a href="#Docker执行Dockerfile的大致流程" class="headerlink" title="Docker执行Dockerfile的大致流程"></a>Docker执行Dockerfile的大致流程</h2><ol>
<li>docker从基础镜像运行一个容器</li>
<li>执行一条指令并对容器作出修改</li>
<li>执行类似docker commit的操作提交一个新的镜像层</li>
<li>docker再基于刚提交的镜像运行一个新容器</li>
<li>执行dockerfile中的下一条指令直到所有指令都执行完成</li>
</ol>
<p>总结:</p>
<p>从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段，</p>
<ul>
<li>Dockerfile是软件的原材料</li>
<li>Docker镜像是软件的交付品</li>
<li>Docker容器则可以认为是软件的运行态。 Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。</li>
</ul>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526132228.png" alt=""></p>
<p>Dockerfile：需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等;</p>
<p>Docker镜像：在用Dockerfile定义一个文件之后，docker build时会产生一个Docker镜像，当运行 Docker镜像时，会真正开始提供服务;</p>
<p>Docker容器：直接提供服务.</p>
<h1 id="3-DockerFile-体系结构-保留字"><a href="#3-DockerFile-体系结构-保留字" class="headerlink" title="3. DockerFile 体系结构(保留字)"></a>3. DockerFile 体系结构(保留字)</h1><ul>
<li><p>FROM : 基础镜像，当前新镜像是基于哪个镜像的</p>
</li>
<li><p>MAINTAINER : 镜像维护者的姓名和邮箱地址</p>
</li>
<li><p>RUN : 容器构建时需要运行的命令</p>
</li>
<li><p>EXPOSE : 当前容器对外暴露出的端口</p>
</li>
<li><p>WORKDIR : 指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点</p>
</li>
<li><p>ENV : 用来在构建镜像过程中设置环境变量</p>
<p>ENV MY_PATH /usr/mytest 这个环境变量可以在后续的任何RUN指令中使用，这就如同在命令前面指定了环境变量前缀一样； 也可以在其它指令中直接使用这些环境变量，</p>
<p>比如：WORKDIR $MY_PATH</p>
</li>
<li><p>ADD : 将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包</p>
</li>
<li><p>COPY : 类似ADD，拷贝文件和目录到镜像中。 将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置</p>
</li>
<li><p>VOLUME : 容器数据卷，用于数据保存和持久化工作</p>
</li>
<li><p>CMD : 指定一个容器启动时要运行的命令</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526132533.png" alt=""></p>
</li>
</ul>
<p>  注意: Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换</p>
<ul>
<li><p>ENTRYPOINT : 指定一个容器启动时要运行的命令;ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数,但是不会被 docker run 后面的参数替换,而是追加</p>
</li>
<li><p>ONBUILD : 当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild被触发</p>
</li>
</ul>
<p>总结:</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526132641.png" alt=""></p>
<h1 id="4-DockerFile-实战案例"><a href="#4-DockerFile-实战案例" class="headerlink" title="4. DockerFile 实战案例"></a>4. DockerFile 实战案例</h1><h2 id="一-自定义-CentOS-镜像案例"><a href="#一-自定义-CentOS-镜像案例" class="headerlink" title="一. 自定义 CentOS 镜像案例"></a>一. 自定义 CentOS 镜像案例</h2><p>首先,我们需要知道Docker Hub 中 99% 的镜像都是通过在 base 镜像中安装和配置需要的软件构建出来的</p>
<p>而这个 base 镜像就是scratch 镜像。</p>
<p>首先停止所有正在运行的 Docker 容器</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526135142.png" alt=""></p>
<p>然后看看从阿里云下载的基础版 CentOS 缺失了哪些功能</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526140938.png" alt=""></p>
<p>现在我们的目标就是通过编写 DockerFile 为基础版本的 CentOS 镜像加上这些缺失的功能</p>
<p>DockerFile如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">MAINTAINER krislin_zhao</span><br><span class="line"> </span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"> </span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"> </span><br><span class="line">EXPOSE 80</span><br><span class="line"> </span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo "success--------------ok"</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure>

<p>开始构建</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -f centosDockerFile -t krislin/centos:1.1 .</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526141551.png" alt=""></p>
<p>构建成功,开始运行容器</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526142157.png" alt=""></p>
<p>除此之外,还可以查看 Docker 镜像的修改历史</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526142337.png" alt=""></p>
<h2 id="二-CMD-ENTRYPOINT-镜像案例"><a href="#二-CMD-ENTRYPOINT-镜像案例" class="headerlink" title="二. CMD/ENTRYPOINT 镜像案例"></a>二. CMD/ENTRYPOINT 镜像案例</h2><p>CMD 示例:</p>
<p>Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换</p>
<p>以 Tomcat 为例</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526142809.png" alt=""></p>
<p>原因就在于我们的 ls -l 参数替换掉了原来的启动参数,如下</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526142848.png" alt=""></p>
<p>相当于在这行参数后面又添加了 <code>CMD ls -l</code></p>
<p>那么容器启动时就会执行最后的 ls -l 命令</p>
<p>如果是 ENTRYPOINT</p>
<p>docker run 之后的参数会被当做参数传递给 ENTRYPOINT，之后形成新的命令组合</p>
<p>示例如下</p>
<p>编写 DockerFile</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">RUN yum install -y curl</span><br><span class="line">ENTRYPOINT [ "curl", "-s", "http://ip.cn" ]</span><br></pre></td></tr></table></figure>

<p>然后构建</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -f centosDockerFile2 -t krislin/ipcentos .</span><br></pre></td></tr></table></figure>

<p>以添加参数的形式启动容器</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526143614.png" alt=""></p>
<p><strong>ONBUILD 示例</strong></p>
<p>类似于触发器,在镜像编译以及子镜像编译的时候触发</p>
<p>新建一个 DockerFile , centosDockerFileFather</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum install -y curl</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [ <span class="string">"curl"</span>, <span class="string">"-s"</span>, <span class="string">"http://ip.cn"</span> ]</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"father is building --------------&gt;"</span></span></span><br></pre></td></tr></table></figure>

<p>进行编译后,又新建一个子 DockerFile, centosDockerFileSon</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> cris/ipcentos_father</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum install -y curl</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [ <span class="string">"curl"</span>, <span class="string">"-s"</span>, <span class="string">"http://ip.cn"</span> ]</span></span><br></pre></td></tr></table></figure>

<p>cris/ipcentos_father 就是上面编译完成的父镜像</p>
<p>当我们开始编译子镜像时,就会触发 ONBUILD 操作</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526143938.png" alt=""></p>
<h2 id="三-自定义-Tomcat9-镜像-重要"><a href="#三-自定义-Tomcat9-镜像-重要" class="headerlink" title="三. 自定义 Tomcat9 镜像(重要)"></a>三. 自定义 Tomcat9 镜像(重要)</h2><p>在新建目录,并且添加以下文件</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526153354.png" alt=""></p>
<p>Dockerfile 内容如下</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span>         centos</span><br><span class="line"><span class="keyword">MAINTAINER</span>    krislin_zhao</span><br><span class="line"><span class="comment">#把宿主机当前上下文的c.txt拷贝到容器/usr/local/路径下</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> copy.txt /usr/<span class="built_in">local</span>/cincontainer.txt</span></span><br><span class="line"><span class="comment">#把java与tomcat添加到容器中</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> jdk-8u171-linux-x64.tar.gz /usr/<span class="built_in">local</span>/</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> apache-tomcat-9.0.35.tar.gz /usr/<span class="built_in">local</span>/</span></span><br><span class="line"><span class="comment">#安装vim编辑器</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum -y install vim</span></span><br><span class="line"><span class="comment">#设置工作访问时候的WORKDIR路径，登录落脚点</span></span><br><span class="line"><span class="keyword">ENV</span> MYPATH /usr/local</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$MYPATH</span></span></span><br><span class="line"><span class="comment">#配置java与tomcat环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME /usr/local/jdk1.<span class="number">8.0</span>_171</span><br><span class="line"><span class="keyword">ENV</span> CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line"><span class="keyword">ENV</span> CATALINA_HOME /usr/local/apache-tomcat-<span class="number">9.0</span>.<span class="number">35</span></span><br><span class="line"><span class="keyword">ENV</span> CATALINA_BASE /usr/local/apache-tomcat-<span class="number">9.0</span>.<span class="number">35</span></span><br><span class="line"><span class="keyword">ENV</span> PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin</span><br><span class="line"><span class="comment">#容器运行时监听的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span>  <span class="number">8080</span></span><br><span class="line"><span class="comment">#启动时运行tomcat</span></span><br><span class="line"><span class="comment"># ENTRYPOINT ["/usr/local/apache-tomcat-9.0.35/bin/startup.sh" ]</span></span><br><span class="line"><span class="comment"># CMD ["/usr/local/apache-tomcat-9.0.35/bin/catalina.sh","run"]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /usr/<span class="built_in">local</span>/apache-tomcat-9.0.35/bin/startup.sh &amp;&amp; tail -F /usr/<span class="built_in">local</span>/apache-tomcat-9.0.35/bin/logs/catalina.out</span></span><br></pre></td></tr></table></figure>

<p>然后开始编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t krislin_tomcat9 .</span><br></pre></td></tr></table></figure>

<p>如果不加 -f 参数,默认从当前目录下的 Dockerfile 文件开始编译</p>
<p>编译成功后,直接运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 9090:8080 --name krisslintomcat9 </span><br><span class="line">-v /root/mytomcat/test:/usr/local/apache-tomcat-9.0.35/webapps/test </span><br><span class="line">-v /root/mytomcat/logs:/usr/local/apache-tomcat-9.0.35/logs  </span><br><span class="line">--privileged=true </span><br><span class="line">krislin_tomcat9</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526154158.png" alt=""></p>
<p>查看数据卷对应的目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect krislintomcat9</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526154333.png" alt=""></p>
<p>验证 Tomcat 是否启动</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526154532.png" alt=""></p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526155722.png" alt=""></p>
<p><strong>测试web 工程发布</strong></p>
<p>我们在宿主机的目录上新建一个简单的 web 工程</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526160229.png" alt=""></p>
<p>test.jsp</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=UTF-8"</span> pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    -----------welcome------------</span><br><span class="line">    &lt;%=<span class="string">"i am in docker tomcat self "</span>%&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;% System.out.println(<span class="string">"=============docker tomcat self"</span>);%&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>然后是 WEB-INF 目录下的 web.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">"WebApp_ID"</span> <span class="attr">version</span>=<span class="string">"2.5"</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>test<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后重启容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker restart krislintomcat9</span><br></pre></td></tr></table></figure>

<p>测试</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526160538.png" alt=""></p>
<p>我们在宿主机修改 jsp</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=UTF-8"</span> pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    -----------welcome------------</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;%=<span class="string">"i am in docker tomcat self krislin "</span>%&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;% System.out.println(<span class="string">"=============docker tomcat self"</span>);%&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526160800.png" alt=""></p>
<h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四. 总结"></a>四. 总结</h2><p><img src="https://user-gold-cdn.xitu.io/2019/4/19/16a34edc0a8c65e1?imageslim" alt="img"></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker方式启动tomcat,访问首页出现404错误</title>
    <url>/Docker%E6%96%B9%E5%BC%8F%E5%90%AF%E5%8A%A8tomcat-%E8%AE%BF%E9%97%AE%E9%A6%96%E9%A1%B5%E5%87%BA%E7%8E%B0404%E9%94%99%E8%AF%AF.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>docker启动tomcat(版本是从阿里云上拉下的:9.0.35)时,访问tomcat首页时出现404错误</p>
<h1 id="初步解决"><a href="#初步解决" class="headerlink" title="初步解决"></a>初步解决</h1><h2 id="1-进入容器的tomcat目录"><a href="#1-进入容器的tomcat目录" class="headerlink" title="1. 进入容器的tomcat目录"></a>1. 进入容器的tomcat目录</h2><p>使用命令: <code>docker exec -it 运行的tomcat容器ID /bin/bash</code>进入到tomcat的目录</p>
<p><img src="https://cdn.jsdelivr.net/gh/krislinzhao/IMGcloud/img/20200514180618.png" alt=""></p>
<h2 id="2-进入webapps文件夹"><a href="#2-进入webapps文件夹" class="headerlink" title="2. 进入webapps文件夹"></a>2. 进入webapps文件夹</h2><p>发现里面是空的(tomcat默认的欢迎页面实际上放在的路径应该是:webapps/ROOT/index.jsp或者index.html)</p>
<h2 id="3-把webapps-dist中的内容复制到webapps中"><a href="#3-把webapps-dist中的内容复制到webapps中" class="headerlink" title="3.把webapps.dist中的内容复制到webapps中"></a>3.把webapps.dist中的内容复制到webapps中</h2><p><img src="https://cdn.jsdelivr.net/gh/krislinzhao/IMGcloud/img//20200514180909.png" alt=""></p>
<h1 id="彻底解决"><a href="#彻底解决" class="headerlink" title="彻底解决"></a>彻底解决</h1><p>虽然这样解决了问题但是不够彻底，因为再另启动一个Tomcat容器时又会回到之前的情况。</p>
<h2 id="1-ctrl-p-q不退出容器的方式返回到宿主机目录下"><a href="#1-ctrl-p-q不退出容器的方式返回到宿主机目录下" class="headerlink" title="1. ctrl+p+q不退出容器的方式返回到宿主机目录下"></a>1. ctrl+p+q不退出容器的方式返回到宿主机目录下</h2><h2 id="2-使用docker-commit命令将修改后的容器生成新的镜像"><a href="#2-使用docker-commit命令将修改后的容器生成新的镜像" class="headerlink" title="2. 使用docker commit命令将修改后的容器生成新的镜像"></a>2. 使用docker commit命令将修改后的容器生成新的镜像</h2><p> docker commit命令详解: </p>
<ul>
<li><p>1.作用：将运行着的容器映射成新的镜像</p>
</li>
<li><p>2.格式: docker commit -a=’作者’ -m=’‘修改内容–随意写’ 容器名称或者ID 新生成镜像的名称</p>
</li>
<li><p>3.例子:  docker commit -a=’krislin’ -m=’将修改后的容器映射成新的镜像’ tomcat krislin/tomcat </p>
</li>
</ul>
<h2 id="3-运行新的镜像"><a href="#3-运行新的镜像" class="headerlink" title="3.运行新的镜像"></a>3.运行新的镜像</h2><p>访问tomcat首页，发现不会再出现404错误，以后每次创建tomcat容器时，使用我们自己生成的镜像即可(它跟阿里云拉下来的进行并没什么差别，只是保存了我们之前对容器做的修改)</p>
<p><img src="https://cdn.jsdelivr.net/gh/krislinzhao/IMGcloud/img/20200514182733.png" alt=""></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>测试本地和阿里云仓库的镜像发布和拉取</title>
    <url>/%E6%B5%8B%E8%AF%95%E6%9C%AC%E5%9C%B0%E5%92%8C%E9%98%BF%E9%87%8C%E4%BA%91%E4%BB%93%E5%BA%93%E7%9A%84%E9%95%9C%E5%83%8F%E5%8F%91%E5%B8%83%E5%92%8C%E6%8B%89%E5%8F%96.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="1-登陆阿里云的容器镜像服务"><a href="#1-登陆阿里云的容器镜像服务" class="headerlink" title="1. 登陆阿里云的容器镜像服务"></a>1. 登陆阿里云的容器镜像服务</h1><h2 id="创建镜像仓库"><a href="#创建镜像仓库" class="headerlink" title="创建镜像仓库"></a>创建镜像仓库</h2><p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526161730.png" alt=""></p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526161823.png" alt=""></p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526162018.png" alt=""></p>
<h1 id="2-在本地生成容器镜像"><a href="#2-在本地生成容器镜像" class="headerlink" title="2. 在本地生成容器镜像"></a>2. 在本地生成容器镜像</h1><p>首先,我们知道了 image 的生成方式有两种,一种是根据 DockerFile 构建;一种是根据容器 commit 新的 image</p>
<p>示例</p>
<p>首先运行一个 Docker 容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it krislin/centos:1.1</span><br></pre></td></tr></table></figure>

<p>然后提交一个新的 image</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526162247.png" alt=""></p>
<h1 id="3-然后根据指示推送本地-image-到阿里云的-repository"><a href="#3-然后根据指示推送本地-image-到阿里云的-repository" class="headerlink" title="3. 然后根据指示推送本地 image 到阿里云的 repository"></a>3. 然后根据指示推送本地 image 到阿里云的 repository</h1><p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526161906.png" alt=""></p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526163110.png" alt=""></p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200526163137.png" alt=""></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬虫实战（一）：抓取糗事百科网的段子</title>
    <url>/Python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%8A%93%E5%8F%96%E7%B3%97%E4%BA%8B%E7%99%BE%E7%A7%91%E7%BD%91%E7%9A%84%E6%AE%B5%E5%AD%90.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="1-网站分析"><a href="#1-网站分析" class="headerlink" title="1. 网站分析"></a>1. 网站分析</h1><p>本篇文章使用 requests 库抓取糗事百科网的段子。读者可以点击 此处 访问糗事百科段子页面。页面如下图所示：<br><img src="/images/2020/09/14/e9bb0d6b-fc9b-4a9c-b495-62ca7696cc6f.png" alt="image.png"><br>在页面的下方是带有数字链接的导航条，可以切换到不同的页面，每一页会显示 25 个段子。所以要实现抓取多页段子的爬虫，不仅要分析当前页面的 HTML 代码，还要可以抓取多页的 HTML 代码。</p>
<p>现在切换到其他页面，看一下 URL 的规律。第 1、2、3 页对应的 URL 如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.qiushibaike.com&#x2F;text&#x2F;page&#x2F;1&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;www.qiushibaike.com&#x2F;text&#x2F;page&#x2F;2&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;www.qiushibaike.com&#x2F;text&#x2F;page&#x2F;3&#x2F;</span><br></pre></td></tr></table></figure>
<p>从 URL 的规律可以看出，页面索引是通过 URL 最后的数字指定的。第 1 页，数字就是 1，第 12 页，数字就是 12 ，很容易根据这个规律得到任意页面的 URL。现在的主要任务是分析每一个页面的 HTML 代码，读者可以按 F12 在开发者工具中跟踪相关部分的 HTML 代码，如下图所示：</p>
<p><img src="/images/2020/09/14/ec07de68-d35a-46b6-9b8c-47c02023d3a4.png" alt="image.png"><br><img src="/images/2020/09/14/41963657-e3b6-4df3-acc8-5c19d2dd2260.png" alt="image.png"><br>本文主要是使用 正则表达式 进行数据解析，如果不懂 正则表达式 的读者 可以看博主此篇文章：Python爬虫数据抽取(三)：正则表达式 可以在 Pycharm 中进行 正则表达式 的验证。</p>
<p><img src="/images/2020/09/14/f6adf8f6-d69d-466c-9158-5535dc106d7f.png" alt="image.png"><br>糗事百科的 HTML 代码相对比较规范，特定 HTML 的位置也比较好找。例如，要想定位鉴别性别的 HTML 代码，可以定位到下面的 HTML 代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;articleGender manIcon&quot;&gt;34&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p>通过 manIcon 可以识别发这条段子的用户是男性，女性是 womenIcon。</p>
<h1 id="2-示例代码"><a href="#2-示例代码" class="headerlink" title="2. 示例代码"></a>2. 示例代码</h1><p>根据前面的描述和实现方式，编写一个用于抓取 13 页糗事百科段子的爬虫，并将抓取结果保存在名为 jokes.txt 的文件中。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">@author:AmoXiang</span><br><span class="line">@file:3.抓取糗事百科网的段子.py</span><br><span class="line">@time:2020&#x2F;09&#x2F;11</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import requests</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;85.0.4183.83 Safari&#x2F;537.36&#39;</span><br><span class="line">&#125;</span><br><span class="line">joke_list &#x3D; []  # 用于存储所有的段子</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 判断性别</span><br><span class="line">def verify_sex(class_name):</span><br><span class="line">    if class_name &#x3D;&#x3D; &quot;womenIcon&quot;:</span><br><span class="line">        return &#39;女&#39;</span><br><span class="line">    else:</span><br><span class="line">        return &#39;男&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_joke(url):</span><br><span class="line">    res &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers)</span><br><span class="line">    text &#x3D; res.text  # 获取页面的html代码</span><br><span class="line">    print(text)</span><br><span class="line">    # 获取用户的ID</span><br><span class="line">    # \s: 匹配任何空白字符，包括空格、制表符、换页符等等</span><br><span class="line">    # id_list &#x3D; re.findall(r&#39;&lt;h2&gt;\s(.*?)\s&lt;&#x2F;h2&gt;&#39;, text)  # 第一种正则表达式的写法</span><br><span class="line">    # re.S: 使用(.)字符匹配所有字符，包括换行符  ?: 非贪婪模式</span><br><span class="line">    id_list &#x3D; re.findall(r&#39;&lt;h2&gt;(.*?)&lt;&#x2F;h2&gt;&#39;, text, re.S)  # 第二种正则表达式的写法</span><br><span class="line">    # 获取用户级别</span><br><span class="line">    level_list &#x3D; re.findall(r&#39;&lt;div class&#x3D;&quot;articleGender .*?&quot;&gt;(\d+)&lt;&#x2F;div&gt;&#39;, text)</span><br><span class="line">    # 获取性别</span><br><span class="line">    sex_list &#x3D; re.findall(r&#39;&lt;div class&#x3D;&quot;articleGender (.*?)&quot;&gt;\d+&lt;&#x2F;div&gt;&#39;, text)</span><br><span class="line">    # 获取段子内容</span><br><span class="line">    content_list &#x3D; re.findall(r&#39;&lt;div class&#x3D;&quot;content&quot;&gt;.*?&lt;span&gt;(.*?)&lt;&#x2F;span&gt;&#39;, text, re.S)</span><br><span class="line">    # 获取好笑数</span><br><span class="line">    laugh_list &#x3D; re.findall(r&#39;&lt;span class&#x3D;&quot;stats-vote&quot;&gt;&lt;i class&#x3D;&quot;number&quot;&gt;(\d+)&lt;&#x2F;i&gt;&#39;, text, re.S)</span><br><span class="line">    # 获取评论数</span><br><span class="line">    comment_list &#x3D; re.findall(r&#39;&lt;i class&#x3D;&quot;number&quot;&gt;(\d+)&lt;&#x2F;i&gt; 评论&#39;, text)</span><br><span class="line">    # 使用zip函数将上述获得的数据的对应索引的元素放到一起</span><br><span class="line">    # 例子: [1,2]、[a, b]  &#x3D;&#x3D;&gt;[(1,a), (2,b)] 形式</span><br><span class="line">    for id, level, sex, content, laugh, comment in zip(id_list, level_list, sex_list, content_list, laugh_list,</span><br><span class="line">                                                       comment_list):</span><br><span class="line">        id &#x3D; id.strip()</span><br><span class="line">        sex &#x3D; verify_sex(sex)</span><br><span class="line">        content &#x3D; content.strip().replace(&#39;&lt;br&#x2F;&gt;&#39;, &#39;&#39;)</span><br><span class="line">        # 获取每个段子相关的数据</span><br><span class="line">        info &#x3D; &#123;</span><br><span class="line">            &#39;id&#39;: id,</span><br><span class="line">            &#39;level&#39;: level,</span><br><span class="line">            &#39;sex&#39;: sex,</span><br><span class="line">            &#39;content&#39;: content,</span><br><span class="line">            &#39;laugh&#39;: laugh,</span><br><span class="line">            &#39;comment&#39;: comment</span><br><span class="line">        &#125;</span><br><span class="line">        joke_list.append(info)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    # 1.产生 1~13 页的URL</span><br><span class="line">    url_list &#x3D; [&quot;https:&#x2F;&#x2F;www.qiushibaike.com&#x2F;text&#x2F;page&#x2F;&#123;&#125;&#x2F;&quot;.format(i) for i in range(1, 14)]</span><br><span class="line">    # 2.使用循环 对13个URL进行请求 获取这13页的段子</span><br><span class="line">    for url in url_list:</span><br><span class="line">        get_joke(url)</span><br><span class="line"></span><br><span class="line">    # 将抓取结果保存在当前目录的 jokes.txt 文件中</span><br><span class="line">    for joke in joke_list:</span><br><span class="line">        f &#x3D; open(&quot;.&#x2F;jokes.txt&quot;, &#39;a&#39;, encoding&#x3D;&quot;utf8&quot;)</span><br><span class="line">        try:</span><br><span class="line">            f.write(joke[&#39;id&#39;] + &quot;\n&quot;)</span><br><span class="line">            f.write(joke[&#39;level&#39;] + &quot;\n&quot;)</span><br><span class="line">            f.write(joke[&#39;sex&#39;] + &quot;\n&quot;)</span><br><span class="line">            f.write(joke[&#39;content&#39;] + &quot;\n&quot;)</span><br><span class="line">            f.write(joke[&#39;laugh&#39;] + &quot;\n&quot;)</span><br><span class="line">            f.write(joke[&#39;comment&#39;] + &quot;\n\n&quot;)</span><br><span class="line">        except Exception:</span><br><span class="line">            pass</span><br><span class="line">        finally:</span><br><span class="line">            f.close()</span><br></pre></td></tr></table></figure>
<p>运行程序，会看到当前目录多了一个 jokes.txt 文件，内容如下图所示：<img src="/images/2020/09/14/ec14ea1c-ce2c-40b9-a0cd-b9c784a278fd.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat安装及配置教程</title>
    <url>/Tomcat%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>步骤一：下载Tomcat<br>      链接如下：<a href="https://tomcat.apache.org/" target="_blank" rel="noopener">https://tomcat.apache.org/</a><br><img src="/images/2020/09/25/f75c9dba-da03-47f5-9f6f-e2c903f8e7e4.png" alt="image.png"><br>注意：要根据自己的JDK版本选择Tomcat的版本。<br><img src="/images/2020/09/25/b4bd44b2-0462-433f-8aa6-cc295b069a31.png" alt="image.png"><br>因本人java版本为10.0.2，故选择Tomcat9.0.31版本（Windows请自行选择64位或32位）<br>步骤二：配置环境变量<br>新建系统环境变量：<br><img src="/images/2020/09/25/5193973f-dd73-484d-b8de-283bd785aa1e.png" alt="image.png"><br>修改系统Path(变量值末尾添加%CATALINA_HOME%\bin;):<br><img src="/images/2020/09/25/314fe953-5609-4a7a-92d0-c4f510b280b5.png" alt="image.png"><br>保存即可。<br>步骤三：查询环境是否配置成功<br><img src="/images/2020/09/25/ad94ddc3-a5ac-4ba2-91fd-ca25979ce87c.png" alt="image.png"><br>ps:若出现上述内容，则环境配置成功<br>步骤四：启动Tomcat：使用命令：startup.bat<br>==(此处可能出现闪退，导致启动不成功，请滑至文章结尾处查看解决办法)==<br><img src="/images/2020/09/25/33740a05-a7d7-4e1a-8483-1537ca33a904.png" alt="image.png">ps:当出现Tomcat的命令框且在浏览器中输入<a href="http://localhost:8080/出现下述界面（注意，此时上述两个命令框不要关闭）：" target="_blank" rel="noopener">http://localhost:8080/出现下述界面（注意，此时上述两个命令框不要关闭）：</a><br><img src="/images/2020/09/25/2cf1e48c-c64f-4765-a665-ed9fdf42e8a4.png" alt="image.png"><br>大功告成，Tomcat搭建成功！！！！<br>&lt;问题&gt;</p>
<p>Q：出现闪退怎么办（即：启动tomcatw.exe出现unable to open the service tomcat怎么办）？</p>
<p><img src="/images/2020/09/25/6ab19449-ec11-469d-a31a-72eac6b366b8.png" alt="image.png"></p>
<p>A：打开命令行，输入命令service.bat install</p>
<p><img src="/images/2020/09/25/bad1f6f5-5b5a-486d-93f9-76a4b74f0913.png" alt="image.png"></p>
<p>再回到步骤四，重新启动Tomcat。</p>
]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>10 个节省时间和改善工作流的 Git 技巧</title>
    <url>/10-%E4%B8%AA%E8%8A%82%E7%9C%81%E6%97%B6%E9%97%B4%E5%92%8C%E6%94%B9%E5%96%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%9A%84-Git-%E6%8A%80%E5%B7%A7.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><ul>
<li><a href="#技巧1优化配置">技巧1:优化配置</a><ul>
<li><a href="#查找顺序">查找顺序</a></li>
<li><a href="#修改配置">修改配置</a></li>
<li><a href="#显示当前设置">显示当前设置</a></li>
<li><a href="#一些有用的配置">一些有用的配置</a></li>
</ul>
</li>
<li><a href="#技巧2别名alias">技巧2:别名(alias)</a><ul>
<li><a href="#一些有用的别名">一些有用的别名</a></li>
</ul>
</li>
<li><a href="#技巧-3查找-commits-和更改">技巧 3：查找 Commits 和更改</a><ul>
<li><a href="#通过commits信息查找">通过commits信息查找</a></li>
<li><a href="#通过更改查找">通过更改查找</a></li>
<li><a href="#通过日期查找">通过日期查找</a></li>
</ul>
</li>
<li><a href="#技巧4添加hunk">技巧4:添加hunk</a></li>
<li><a href="#技巧-5-储藏stash更改而不提交">技巧 5： 储藏（stash）更改而不提交</a><ul>
<li><a href="#创建">创建</a></li>
<li><a href="#罗列">罗列</a></li>
<li><a href="#浏览">浏览</a></li>
<li><a href="#应用">应用</a></li>
<li><a href="#清理">清理</a></li>
</ul>
</li>
<li><a href="#技巧-6空运行dry-run">技巧 6：空运行（Dry Run）</a></li>
<li><a href="#技巧-7安全强制推送">技巧 7：安全强制推送</a></li>
<li><a href="#技巧-8修改-commit-信息">技巧 8：修改 commit 信息</a></li>
<li><a href="#技巧-9修改历史">技巧 9：修改历史</a></li>
<li><a href="#技巧-10存档跟踪文件">技巧 10：存档跟踪文件</a></li>
<li><a href="#额外提醒单破折号">额外提醒：单破折号</a></li>
</ul>
<p><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Git Pro</a></p>
<h1 id="技巧1-优化配置"><a href="#技巧1-优化配置" class="headerlink" title="技巧1:优化配置"></a>技巧1:优化配置</h1><p>Git 在全局、用户和本地级别上都是高度可配置的。</p>
<p><a href="https://git-scm.com/docs/git-config" target="_blank" rel="noopener">git配置文档</a></p>
<h2 id="查找顺序"><a href="#查找顺序" class="headerlink" title="查找顺序"></a>查找顺序</h2><p>每个设置都可以被覆盖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本地级别:</span><br><span class="line">项目文件夹&#x2F;.git&#x2F;config</span><br><span class="line">用户级别:</span><br><span class="line">用户目录&#x2F;.config&#x2F;git</span><br><span class="line">用户目录&#x2F;.gitconfig</span><br><span class="line">全局级别：</span><br><span class="line">git目录&#x2F;etc&#x2F;gitconfig</span><br></pre></td></tr></table></figure>

<h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全局设置</span></span><br><span class="line">git config --global &lt;keypath&gt; &lt;value&gt;</span><br><span class="line"><span class="comment"># 本地设置</span></span><br><span class="line">git config &lt;keypath&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure>

<h2 id="显示当前设置"><a href="#显示当前设置" class="headerlink" title="显示当前设置"></a>显示当前设置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示当前设置及其来源</span></span><br><span class="line">git config --list --show-origin</span><br></pre></td></tr></table></figure>

<h2 id="一些有用的配置"><a href="#一些有用的配置" class="headerlink" title="一些有用的配置"></a>一些有用的配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设定身份</span></span><br><span class="line">git config --global user.name<span class="string">"&lt;your name&gt;"</span></span><br><span class="line">git config --global user.email &lt;your email&gt;</span><br></pre></td></tr></table></figure>

<h1 id="技巧2-别名-alias"><a href="#技巧2-别名-alias" class="headerlink" title="技巧2:别名(alias)"></a>技巧2:别名(alias)</h1><p><a href="[https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-Git-%E5%88%AB%E5%90%8D](https://git-scm.com/book/zh/v2/Git-基础-Git-别名)">Git 别名</a></p>
<p>创建别名来保存常用的git命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建别名</span></span><br><span class="line">git config --global <span class="built_in">alias</span>.&lt;<span class="built_in">alias</span>-name&gt; <span class="string">"&lt;git command&gt;"</span></span><br><span class="line"><span class="comment"># 使用别名</span></span><br><span class="line">git &lt;<span class="built_in">alias</span>-name&gt; &lt;more optional arguments&gt;</span><br></pre></td></tr></table></figure>

<h2 id="一些有用的别名"><a href="#一些有用的别名" class="headerlink" title="一些有用的别名"></a>一些有用的别名</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 撤销上次提交</span></span><br><span class="line">git config --global alias.undo <span class="string">"reset --soft HEAD^"</span></span><br><span class="line"><span class="comment"># 将暂存区更新修订到上次提交 (不改变提交信息)</span></span><br><span class="line">git config --global alias.amend <span class="string">"commit --amend --no-edit"</span></span><br><span class="line"><span class="comment"># 压缩的状态输出</span></span><br><span class="line">git config --global alias.st <span class="string">"status -sb"</span></span><br><span class="line"><span class="comment"># 用 GRAPH 为日志着色</span></span><br><span class="line">git config --global alias.lg <span class="string">"log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset'"</span></span><br><span class="line"><span class="comment"># 删除所有已合并的分支</span></span><br><span class="line">git config --global alias.rmb <span class="string">"!git branch --merged | grep -v '*' | xargs -n 1 git branch -d"</span></span><br><span class="line"><span class="comment"># 贡献排行</span></span><br><span class="line">git config --global alias.rank <span class="string">"shortlog -n -s --no-merges"</span></span><br></pre></td></tr></table></figure>

<h1 id="技巧-3：查找-Commits-和更改"><a href="#技巧-3：查找-Commits-和更改" class="headerlink" title="技巧 3：查找 Commits 和更改"></a>技巧 3：查找 Commits 和更改</h1><h2 id="通过commits信息查找"><a href="#通过commits信息查找" class="headerlink" title="通过commits信息查找"></a>通过commits信息查找</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过 commit 信息查找 (所有分支)</span></span><br><span class="line">git <span class="built_in">log</span> --all --grep=<span class="string">'&lt;search term&gt;'</span></span><br><span class="line"><span class="comment"># 通过 commit 信息查找 (包含 reflog)</span></span><br><span class="line">git <span class="built_in">log</span>-g --grep=<span class="string">'&lt;search term&gt;'</span></span><br></pre></td></tr></table></figure>

<h2 id="通过更改查找"><a href="#通过更改查找" class="headerlink" title="通过更改查找"></a>通过更改查找</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过更新的内容查找</span></span><br><span class="line">git <span class="built_in">log</span> -S <span class="string">'&lt;search term&gt;'</span></span><br></pre></td></tr></table></figure>

<h2 id="通过日期查找"><a href="#通过日期查找" class="headerlink" title="通过日期查找"></a>通过日期查找</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过日期范围查找</span></span><br><span class="line">git <span class="built_in">log</span> --after=<span class="string">'DEC 152019'</span> --until=<span class="string">'JAN 102020'</span></span><br></pre></td></tr></table></figure>

<h1 id="技巧4-添加hunk"><a href="#技巧4-添加hunk" class="headerlink" title="技巧4:添加hunk"></a>技巧4:添加hunk</h1><p>git add <filepath> 不仅能添加文件的所有变更， –path / -p 参数还可以交互式暂存区块。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 补丁命令</span></span><br><span class="line">y = 暂存区块</span><br><span class="line">n = 不暂存这个区块</span><br><span class="line">q = 退出</span><br><span class="line">a = 暂存当前文件的此区块以及所有剩余区块</span><br><span class="line">d = 不暂存当前文件的此区块以及所有剩余区块</span><br><span class="line">/ = 查找区块 (正则表达式)</span><br><span class="line">s = 划分成更小的区块</span><br><span class="line">e = 手动编辑区块</span><br><span class="line">? = 打印帮助说明</span><br><span class="line">g = 选择要前往的区块</span><br><span class="line">j = 将区块设为未定，查看下一个未定区块</span><br><span class="line">J = 将区块设为未定，查看下一个区块</span><br><span class="line">k = 将区块设为未定，查看上一个未定区块</span><br><span class="line">J = 将区块设为未定，查看下一个区块</span><br></pre></td></tr></table></figure>

<h1 id="技巧-5：-储藏（stash）更改而不提交"><a href="#技巧-5：-储藏（stash）更改而不提交" class="headerlink" title="技巧 5： 储藏（stash）更改而不提交"></a>技巧 5： 储藏（stash）更改而不提交</h1><p>stash 将当前的更改临时搁置起来。在它的帮助下，可以返回当前状态的索引，并能在稍后应用已储藏的更改。</p>
<p>默认情况下，仅储藏当前跟踪文件中的更改，新文件将被忽略。</p>
<p>我们可以独立地创建和应用多个 stash。</p>
<p><a href="[https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%82%A8%E8%97%8F%E4%B8%8E%E6%B8%85%E7%90%86](https://git-scm.com/book/zh/v2/Git-工具-储藏与清理)">Git 工具 - 储藏与清理</a></p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建新的 STASH</span></span><br><span class="line">git stash</span><br><span class="line"><span class="comment"># 创建新的 STASH (包含未追踪的更改)</span></span><br><span class="line">git stash -u/--include-untracked</span><br><span class="line"><span class="comment"># 创建新的 STASH 并命名</span></span><br><span class="line">git stash save<span class="string">"&lt;stash name&gt;"</span></span><br><span class="line"><span class="comment"># 交互式储藏</span></span><br><span class="line">git stash -p</span><br></pre></td></tr></table></figure>

<h2 id="罗列"><a href="#罗列" class="headerlink" title="罗列"></a>罗列</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有的 STASH (为其他命令提供 "n")</span></span><br><span class="line">git stash list</span><br></pre></td></tr></table></figure>

<h2 id="浏览"><a href="#浏览" class="headerlink" title="浏览"></a>浏览</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 浏览 STASH 内容</span></span><br><span class="line">git stash show</span><br><span class="line"><span class="comment"># 浏览 STASH 差异</span></span><br><span class="line">git stash show -p</span><br></pre></td></tr></table></figure>

<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 应用上一个 STASH (删除 stash)</span></span><br><span class="line">git stash pop</span><br><span class="line"><span class="comment"># 应用上一个 STASH (保留 stash)</span></span><br><span class="line">git stash apply</span><br><span class="line"><span class="comment"># 应用特定的 STASH (n = stash 列表序号)</span></span><br><span class="line">git stash pop/apply stash@&#123;n&#125;</span><br><span class="line"><span class="comment"># 从 STASH 创建新的分支 (n = stash 列表序号)</span></span><br><span class="line">git stash branch &lt;newbranch name&gt; stash@&#123;n&#125;</span><br><span class="line"><span class="comment"># 从 STASH 应用单个文件 (n = stash 列表序号)</span></span><br><span class="line">git checkout stash@&#123;n&#125; -- &lt;filepath&gt;</span><br></pre></td></tr></table></figure>

<h2 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除特定的 STASH (n = stash 列表序号)</span></span><br><span class="line">git stash drop stash@&#123;n&#125;</span><br><span class="line"><span class="comment"># 删除所有的 STASH</span></span><br><span class="line">git stash clear</span><br></pre></td></tr></table></figure>

<h1 id="技巧-6：空运行（Dry-Run）"><a href="#技巧-6：空运行（Dry-Run）" class="headerlink" title="技巧 6：空运行（Dry Run）"></a>技巧 6：空运行（Dry Run）</h1><p>许多 git 操作可能具有破坏性，例如， git clean -f 将删除所有未跟踪的文件，而且无法恢复。</p>
<p>要避免出现这种灾难性的结果，许多命令都支持 <em>dry-run</em> ，可以在实际产生结果前对其进行检查。不过遗憾的是，使用的选项不完全一致：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git clean -n/--dry-run</span><br><span class="line">git add -n/--dry-run</span><br><span class="line">git rm -n/--dry-run</span><br><span class="line"><span class="comment"># GIT MERGE 模拟 DRY-RUN</span></span><br><span class="line">git merge --no-commit --no-ff &lt;branch&gt;</span><br><span class="line">git diff --cached</span><br><span class="line">git merge --abort</span><br></pre></td></tr></table></figure>

<h1 id="技巧-7：安全强制推送"><a href="#技巧-7：安全强制推送" class="headerlink" title="技巧 7：安全强制推送"></a>技巧 7：安全强制推送</h1><p>在处理旧的 commit、创建新的 head 等情况时时很容易弄乱分支。 git push –force 可以覆盖远程变更，但不应该这样做！</p>
<p>git push –force 是一种具有破坏性且危险的操作，因为它无条件生效，并且会破坏其他提交者已经推送的所有 commit。这对于其他人的代码仓库来说不一定是致命的，但是改变历史记录并影响其他人并不是一个好主意。</p>
<p>更好的选择是使用 git push –force-with-lease 。</p>
<p>git 不会无条件地覆盖上游的远程仓库，而是检查是否有本地不可用的远程更改。如果有，它会失败并显示一条“stale info”消息，并告诉我们需要先运行 git fetch 。</p>
<p><a href="https://git-scm.com/docs/git-push#Documentation/git-push.txt---force-with-leaseltrefnamegt" target="_blank" rel="noopener">git push</a></p>
<h1 id="技巧-8：修改-commit-信息"><a href="#技巧-8：修改-commit-信息" class="headerlink" title="技巧 8：修改 commit 信息"></a>技巧 8：修改 commit 信息</h1><p>Commit 是不可变的，且不能更改。不过可以用一条新的 commit 信息修订现有的 commit，这会覆盖原始 commit，因此请勿在已推送的 commit 中使用它。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit --amend -m <span class="string">"&lt;new commit message&gt;"</span></span><br></pre></td></tr></table></figure>

<h1 id="技巧-9：修改历史"><a href="#技巧-9：修改历史" class="headerlink" title="技巧 9：修改历史"></a>技巧 9：修改历史</h1><p>修改代码仓库的历史不仅限于修改上次提交信息，使用 git rebase 可以修改多个提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提交的范围</span></span><br><span class="line">git rebase -i/--interactive HEAD~&lt;number of commits&gt;</span><br><span class="line"><span class="comment"># 该 hash 之后的所有提交</span></span><br><span class="line">git rebase -i/--interactive &lt;commit <span class="built_in">hash</span>&gt;</span><br></pre></td></tr></table></figure>

<p>在配置的编辑器中倒序列出所有的 commit，像这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&lt;command&gt;&lt;commit hash&gt;&lt;commit message&gt;</span></span><br><span class="line">pick5df8fbc revamped logic</span><br><span class="line">pick ca5154e README typos fixed</span><br><span class="line">pick a104aff added awesome new feature</span><br></pre></td></tr></table></figure>

<p>通过更改编辑器中的实际内容，可以为 git 提供一个方案，来说明如何进行 rebase：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># p, pick = 使用提交而不更改</span></span><br><span class="line"><span class="comment"># r, reword = 修改提交信息</span></span><br><span class="line"><span class="comment"># e, edit = 编辑提交</span></span><br><span class="line"><span class="comment"># s, squash = 汇合提交</span></span><br><span class="line"><span class="comment"># f, fixup = 类似 "squash"，但是会丢弃提交信息</span></span><br><span class="line"><span class="comment"># x, exec = 运行命令 (其余行)</span></span><br><span class="line"><span class="comment"># d, drop = 移除提交</span></span><br></pre></td></tr></table></figure>

<p>保存编辑器后，git 将运行该方案以重写历史记录。</p>
<p>e, edit 会暂停 rebase，就可以编辑代码仓库的当前状态。完成编辑后，运行 git rebase –continue 。</p>
<p>如果过程中出现问题（例如合并冲突），我们需要重新开始，可以使用 git rebase –abort 。</p>
<p><a href="https://git-scm.com/docs/git-rebase" target="_blank" rel="noopener">git-rebase</a></p>
<h1 id="技巧-10：存档跟踪文件"><a href="#技巧-10：存档跟踪文件" class="headerlink" title="技巧 10：存档跟踪文件"></a>技巧 10：存档跟踪文件</h1><p>可以使用不同格式（ zip 或 tar ）来压缩特定引用的跟踪文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">git archive --format&lt;format&gt; --output&lt;filename&gt; &lt;ref&gt;</span><br></pre></td></tr></table></figure>

<p><ref> 可以是一个分支、commit hash 或者一个标签。</p>
<p><a href="https://git-scm.com/docs/git-archive" target="_blank" rel="noopener">git-archive</a></p>
<h1 id="额外提醒：单破折号"><a href="#额外提醒：单破折号" class="headerlink" title="额外提醒：单破折号"></a>额外提醒：单破折号</h1><p>有一个快捷方式可以表示刚用过的分支：一个单破折号 -</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout my-branch</span><br><span class="line"><span class="comment"># 当前分支：my-branch</span></span><br><span class="line">&lt;dosome git operations, e.g. adding/commiting&gt;</span><br><span class="line">git checkout develop</span><br><span class="line"><span class="comment"># 当前分支：develop</span></span><br><span class="line">git merge -</span><br><span class="line"><span class="comment"># 将 my-branch 合并到 develop</span></span><br></pre></td></tr></table></figure>

<p>单破折号等同于 @{-1} 。</p>
<p><a href="https://git-scm.com/docs/git-checkout#Documentation/git-checkout.txt-ltbranchgt" target="_blank" rel="noopener">git-checkout</a></p>
]]></content>
  </entry>
  <entry>
    <title>微信地图导航</title>
    <url>/%E5%BE%AE%E4%BF%A1%E5%9C%B0%E5%9B%BE%E5%AF%BC%E8%88%AA.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>☀️ wxmap是一款整合了高德地图、腾讯地图、和风天气、一言、腾讯同声传译插件（计划）的实用型微信小程序。</p>
</hr>

<h1 id="在线体验"><a href="#在线体验" class="headerlink" title="在线体验"></a>在线体验</h1><p><img src="/images/2020/11/06/7519b4da-ee97-4e24-9a3e-9985d4cbbd54.jpg" alt="小程序码.jpg"></p>
<h1 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h1><p><img src="https://img-blog.csdnimg.cn/20200528112530994.gif" alt="Image text"></p>
<h1 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h1><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><ul>
<li>Node.js</li>
<li>注册微信小程序开发者<h4 id="API工具准备"><a href="#API工具准备" class="headerlink" title="API工具准备"></a>API工具准备</h4></li>
<li><a href="http://lbs.qq.com/miniProgram/jsSdk/jsSdkGuide/jsSdkOverview" target="_blank">注册qqmap开发者</a></li>
<li><a href="https://console.amap.com/dev/key/app" target="_blank">注册高德地图开发者</a></li>
<li><a href="https://dev.heweather.com/" target="_blank">注册和风天气开发者</a></li>
<li><a href="https://developer.hitokoto.cn/sentence/" target="_blank">一言接口使用文档</a></hr>

</li>
</ul>
<h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><ul>
<li><a href="https://blog.csdn.net/tomatocc/article/details/106402276" target="_blank">项目部署步骤</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>JAVA集合</title>
    <url>/JAVA%E9%9B%86%E5%90%88.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="1-Collection集合"><a href="#1-Collection集合" class="headerlink" title="1. Collection集合"></a>1. Collection集合</h1><h2 id="1-1-集合介绍"><a href="#1-1-集合介绍" class="headerlink" title="1.1 集合介绍"></a>1.1 集合介绍</h2><p><strong>Collection的由来：</strong></p>
<ul>
<li>集合可以存储多个元素，但是我们对多个元素也有不同的需求<ul>
<li>多个元素，不能有相同的</li>
<li>多个元素，能够按照某个规则排序</li>
</ul>
</li>
<li>针对不同的需求：Java就提供了很多集合类，多个集合类的数据结构不同。但是，结构不重要，重要的是能够存储东西，能够判断，获取</li>
<li>把集合共性的内容不断往上提取，最终形成集合的继承体系</li>
</ul>
<p>Collection的大致结构体系：</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200808203607.png" alt=""></p>
<p>但是，一般我们掌握一些常用的就可以了，下面我圈出来的那些：</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200808203735.png" alt=""></p>
<p><strong>Collection的基础功能：</strong></p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200808203831.png" alt=""></p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200808204004.png" alt=""></p>
<h2 id="1-2-集合框架"><a href="#1-2-集合框架" class="headerlink" title="1.2  集合框架"></a>1.2  集合框架</h2><p>JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。</p>
<p>集合按照其存储结构可以分为两大类，分别是单列集合<code>java.util.Collection</code>和双列集合<code>java.util.Map</code>，今天我们主要学习<code>Collection</code>集合。</p>
<ul>
<li><strong>Collection</strong>：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<code>java.util.List</code>和<code>java.util.Set</code>。其中，<code>List</code>的特点是元素有序、元素可重复。<code>Set</code>的特点是元素无序，而且不可重复。<code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>，<code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code>。</li>
</ul>
<p>从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。</p>
<p><img src="https://cdn.jsdelivr.net/gh/krislinzhao/IMGcloud/img/20200221154741.png" alt=""></p>
<p>其中，橙色框里填写的都是接口类型，而蓝色框里填写的都是具体的实现类。</p>
<p>集合本身是一个工具，它存放在java.util包中。在<code>Collection</code>接口定义着单列集合框架中最最共性的内容。</p>
<p><img src="https://cdn.jsdelivr.net/gh/krislinzhao/IMGcloud/img/20200221161144.png" alt=""></p>
<h2 id="1-3-Collection-常用功能"><a href="#1-3-Collection-常用功能" class="headerlink" title="1.3 Collection 常用功能"></a>1.3 Collection 常用功能</h2><p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p>
<ul>
<li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li>
<li><code>public void clear()</code> :清空集合中所有的元素。</li>
<li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li>
<li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li>
<li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li>
<li><code>public int size()</code>: 返回集合中元素的个数。</li>
<li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li>
</ul>
<p>方法演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1Collection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建集合对象 </span></span><br><span class="line">    	<span class="comment">// 使用多态形式</span></span><br><span class="line">    	Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    	<span class="comment">// 使用方法</span></span><br><span class="line">    	<span class="comment">// 添加功能  boolean  add(String s)</span></span><br><span class="line">    	coll.add(<span class="string">"小李广"</span>);</span><br><span class="line">    	coll.add(<span class="string">"扫地僧"</span>);</span><br><span class="line">    	coll.add(<span class="string">"石破天"</span>);</span><br><span class="line">    	System.out.println(coll);</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// boolean contains(E e) 判断o是否在集合中存在</span></span><br><span class="line">    	System.out.println(<span class="string">"判断  扫地僧 是否在集合中"</span>+coll.contains(<span class="string">"扫地僧"</span>));</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//boolean remove(E e) 删除在集合中的o元素</span></span><br><span class="line">    	System.out.println(<span class="string">"删除石破天："</span>+coll.remove(<span class="string">"石破天"</span>));</span><br><span class="line">    	System.out.println(<span class="string">"操作之后集合中元素:"</span>+coll);</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// size() 集合中有几个元素</span></span><br><span class="line">		System.out.println(<span class="string">"集合中有"</span>+coll.size()+<span class="string">"个元素"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Object[] toArray()转换成一个Object数组</span></span><br><span class="line">    	Object[] objects = coll.toArray();</span><br><span class="line">    	<span class="comment">// 遍历数组</span></span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">			System.out.println(objects[i]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// void  clear() 清空集合</span></span><br><span class="line">		coll.clear();</span><br><span class="line">		System.out.println(<span class="string">"集合中内容为："</span>+coll);</span><br><span class="line">		<span class="comment">// boolean  isEmpty()  判断是否为空</span></span><br><span class="line">		System.out.println(coll.isEmpty());  	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips: 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。</p>
</blockquote>
<h1 id="2-Iterator迭代器"><a href="#2-Iterator迭代器" class="headerlink" title="2. Iterator迭代器"></a>2. Iterator迭代器</h1><h2 id="2-1-Iterator介绍"><a href="#2-1-Iterator介绍" class="headerlink" title="2.1 Iterator介绍"></a>2.1 Iterator介绍</h2><p>我们可以发现Collection的源码中继承了Iterable，有iterator()这个方法</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200808204316.png" alt=""></p>
<p>点进出一看，Iterable是一个接口:</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200808204554.png" alt=""></p>
<p>它有iterator()这个方法，返回的是Iterator</p>
<p>再来看一下，Iterator也是一个接口，它只有三个方法：</p>
<ul>
<li><code>hasNext()</code></li>
<li><code>next()</code></li>
<li><code>remove()</code></li>
</ul>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200808204830.png" alt=""></p>
<p>可是，我们没能找到对应的实现方法，只能网Collection的子类下找找了，于是我们找到了—&gt;ArrayList。</p>
<p>于是，我们在ArrayList下找到了iterator实现的身影：它是在ArrayList以内部类的方式实现的，并且从源码可知：Iterator实际上就是遍历集合</p>
<p><img src="https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200808210304.png" alt=""></p>
<h2 id="2-1-Iterator接口"><a href="#2-1-Iterator接口" class="headerlink" title="2.1 Iterator接口"></a>2.1 Iterator接口</h2><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code>。<code>Iterator</code>接口也是Java集合中的一员，但它与<code>Collection</code>、<code>Map</code>接口有所不同，<code>Collection</code>接口与<code>Map</code>接口主要用于存储元素，而<code>Iterator</code>主要用于迭代访问（即遍历）<code>Collection</code>中的元素，因此<code>Iterator</code>对象也被称为迭代器。</p>
<p>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法：</p>
<ul>
<li><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</li>
</ul>
<p>下面介绍一下迭代的概念：</p>
<ul>
<li><strong>迭代</strong>：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</li>
</ul>
<p>Iterator接口的常用方法如下：</p>
<ul>
<li><code>public E next()</code>:返回迭代的下一个元素。</li>
<li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li>
</ul>
<p>接下来我们通过案例学习如何使用Iterator迭代集合中元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorDemo</span> </span>&#123;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用多态方式 创建对象</span></span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素到集合</span></span><br><span class="line">        coll.add(<span class="string">"火星人"</span>);</span><br><span class="line">        coll.add(<span class="string">"喵星人"</span>);</span><br><span class="line">        coll.add(<span class="string">"汪星人"</span>);</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="comment">//使用迭代器 遍历   每个集合对象都有自己的迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line">        <span class="comment">//  泛型指的是 迭代出元素的数据类型</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123; <span class="comment">//判断是否有迭代元素</span></span><br><span class="line">            String s = it.next();<span class="comment">//获取迭代出的元素</span></span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。</p>
</blockquote>
<h2 id="2-2-迭代器的实现原理"><a href="#2-2-迭代器的实现原理" class="headerlink" title="2.2 迭代器的实现原理"></a>2.2 迭代器的实现原理</h2><p>我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。</p>
<p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/krislinzhao/IMGcloud/img/20200227154525.png" alt="迭代器原理图"></p>
<p>在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p>
<h2 id="2-3-增强for"><a href="#2-3-增强for" class="headerlink" title="2.3 增强for"></a>2.3 增强for</h2><p>增强for循环(也称for each循环)是<strong>JDK1.5</strong>以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素的数据类型  变量 : Collection集合or数组)&#123; </span><br><span class="line">  	<span class="comment">//写操作代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。</p>
<h4 id="练习1：遍历数组"><a href="#练习1：遍历数组" class="headerlink" title="练习1：遍历数组"></a>练习1：遍历数组</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NBForDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">87</span>&#125;;</span><br><span class="line">       	<span class="comment">//使用增强for遍历数组</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a : arr)&#123;<span class="comment">//a代表数组中的每个元素</span></span><br><span class="line">			System.out.println(a);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="练习2-遍历集合"><a href="#练习2-遍历集合" class="headerlink" title="练习2:遍历集合"></a>练习2:遍历集合</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NBFor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">    	Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    	coll.add(<span class="string">"小河神"</span>);</span><br><span class="line">    	coll.add(<span class="string">"老河神"</span>);</span><br><span class="line">    	coll.add(<span class="string">"神婆"</span>);</span><br><span class="line">    	<span class="comment">//使用增强for遍历</span></span><br><span class="line">    	<span class="keyword">for</span>(String s :coll)&#123;<span class="comment">//接收变量s代表 代表被遍历到的集合元素</span></span><br><span class="line">    		System.out.println(s);</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。</p>
</blockquote>
<h1 id="3-集合综合案例"><a href="#3-集合综合案例" class="headerlink" title="3. 集合综合案例"></a>3. 集合综合案例</h1><h2 id="3-1-案例介绍"><a href="#3-1-案例介绍" class="headerlink" title="3.1 案例介绍"></a>3.1 案例介绍</h2><p>按照斗地主的规则，完成洗牌发牌的动作。<br>具体规则：</p>
<p>使用54张牌打乱顺序,三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。</p>
<h2 id="3-2-案例分析"><a href="#3-2-案例分析" class="headerlink" title="3.2 案例分析"></a>3.2 案例分析</h2><ul>
<li><p>准备牌：</p>
<p>牌可以设计为一个ArrayList<String>,每个字符串为一张牌。<br>每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。<br>牌由Collections类的shuffle方法进行随机排序。</p>
</li>
<li><p>发牌</p>
<p>将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</p>
</li>
</ul>
<ul>
<li><p>看牌</p>
<p>直接打印每个集合。</p>
</li>
</ul>
<h2 id="3-3-代码实现"><a href="#3-3-代码实现" class="headerlink" title="3.3 代码实现"></a>3.3 代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 1: 准备牌操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//1.1 创建牌盒 将来存储牌面的 </span></span><br><span class="line">        ArrayList&lt;String&gt; pokerBox = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//1.2 创建花色集合</span></span><br><span class="line">        ArrayList&lt;String&gt; colors = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.3 创建数字集合</span></span><br><span class="line">        ArrayList&lt;String&gt; numbers = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.4 分别给花色 以及 数字集合添加元素</span></span><br><span class="line">        colors.add(<span class="string">"♥"</span>);</span><br><span class="line">        colors.add(<span class="string">"♦"</span>);</span><br><span class="line">        colors.add(<span class="string">"♠"</span>);</span><br><span class="line">        colors.add(<span class="string">"♣"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">            numbers.add(i+<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        numbers.add(<span class="string">"J"</span>);</span><br><span class="line">        numbers.add(<span class="string">"Q"</span>);</span><br><span class="line">        numbers.add(<span class="string">"K"</span>);</span><br><span class="line">        numbers.add(<span class="string">"A"</span>);</span><br><span class="line">        <span class="comment">//1.5 创造牌  拼接牌操作</span></span><br><span class="line">        <span class="comment">// 拿出每一个花色  然后跟每一个数字 进行结合  存储到牌盒中</span></span><br><span class="line">        <span class="keyword">for</span> (String color : colors) &#123;</span><br><span class="line">            <span class="comment">//color每一个花色 </span></span><br><span class="line">            <span class="comment">//遍历数字集合</span></span><br><span class="line">            <span class="keyword">for</span>(String number : numbers)&#123;</span><br><span class="line">                <span class="comment">//结合</span></span><br><span class="line">                String card = color+number;</span><br><span class="line">                <span class="comment">//存储到牌盒中</span></span><br><span class="line">                pokerBox.add(card);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.6大王小王</span></span><br><span class="line">        pokerBox.add(<span class="string">"小☺"</span>);</span><br><span class="line">        pokerBox.add(<span class="string">"大☠"</span>);	  </span><br><span class="line">        <span class="comment">// System.out.println(pokerBox);</span></span><br><span class="line">        <span class="comment">//洗牌 是不是就是将  牌盒中 牌的索引打乱 </span></span><br><span class="line">        <span class="comment">// Collections类  工具类  都是 静态方法</span></span><br><span class="line">        <span class="comment">// shuffer方法   </span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * static void shuffle(List&lt;?&gt; list) </span></span><br><span class="line"><span class="comment">         *     使用默认随机源对指定列表进行置换。 </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//2:洗牌</span></span><br><span class="line">        Collections.shuffle(pokerBox);</span><br><span class="line">        <span class="comment">//3 发牌</span></span><br><span class="line">        <span class="comment">//3.1 创建 三个 玩家集合  创建一个底牌集合</span></span><br><span class="line">        ArrayList&lt;String&gt; player1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; player2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; player3 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; dipai = <span class="keyword">new</span> ArrayList&lt;String&gt;();	  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历 牌盒  必须知道索引   </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;pokerBox.size();i++)&#123;</span><br><span class="line">            <span class="comment">//获取 牌面</span></span><br><span class="line">            String card = pokerBox.get(i);</span><br><span class="line">            <span class="comment">//留出三张底牌 存到 底牌集合中</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">51</span>)&#123;<span class="comment">//存到底牌集合中</span></span><br><span class="line">                dipai.add(card);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//玩家1   %3  ==0</span></span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                  	player1.add(card);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">1</span>)&#123;<span class="comment">//玩家2</span></span><br><span class="line">                  	player2.add(card);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//玩家3</span></span><br><span class="line">                  	player3.add(card);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//看看</span></span><br><span class="line">        System.out.println(<span class="string">"张三："</span>+player1);</span><br><span class="line">        System.out.println(<span class="string">"李四："</span>+player2);</span><br><span class="line">        System.out.println(<span class="string">"王五："</span>+player3);</span><br><span class="line">        System.out.println(<span class="string">"赵六："</span>+dipai);  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>华为HCIA证书必刷题</title>
    <url>/%E5%8D%8E%E4%B8%BAHCIA%E8%AF%81%E4%B9%A6%E5%BF%85%E5%88%B7%E9%A2%98.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><ol>
<li>在华为 FusionCompute 中，管理员可以查看虚拟机连接的 DVS 端口。A<br>A、TRUE<br>B、FALSE</li>
<li>在华为 FusionCompute 中创建端口组时，以下操作错误的是（）。A<br>A、将 VLAN ID 设为“5000”<br>B、将端口组的名称设为“ceshi”<br>C、将端口类型设为“普通”<br>D、在描述中添加“这是测试端口”</li>
<li>在华为 FusionCompute 中，克隆虚拟机时不支持调整虚拟机的规格。B<br>A、TRUE<br>B、FALSE</li>
<li>在华为 FusionCompute 中虚拟机所使用的内存资源和 CPU 资源只能由同一集群提供。因<br>此，虚拟机实际可使用计算资源的最大限度不能超过该集群内所有主机可提供资源的总和 A<br>A、TRUE<br>B、FALSE</li>
<li>以下选项属于云计算 1.0 时代特征的是（多选）BD<br>A、敏捷应用开发与生命周期管理<br>B、以虚拟化产品为主<br>C、资源服务标准化、自动化<br>D、使用虚拟化技术，提高资源利用率</li>
<li>在华为 FusionCompute 中，上行链路的作用是（）。B<br>A、为虚拟机分配 IP 地址<br>B、连接虚拟网络和物理网络<br>C、管理虚拟机 MAC 地址<br>D、检测虚拟网卡状态</li>
<li>以下关于云计算描述正确的是（）C<br>A、云计算是一种技术，能够实现随时随地、便捷的、随需应变地获取到 IT 资源<br>B、云计算中的各种 IT 资源需要付费才能使用<br>C、在云计算中获取的 IT 资源需要通过网络才能使用<br>D、在获取 IT 资源的过程中，用户需要与云计算服务提供商反复交涉</li>
<li>在互联网的发展过程中，有很多里程碑事件，下列选项中对里程碑事件发生先后顺序排<br>序正确的是（）C<br>A、TCP/IP 协议规范建立——ARPANET 诞生——www 正式向公众开放——DNS 诞生<br>B、www 正式向公众开放——DNS 诞生——TCP/IP 协议规范建立——ARPANET 诞生<br>C、ARPANET 诞生——TCP/IP 协议规范建立——DNS 诞生——www 正式向公众开放<br>D、DNS 诞生——TCP/IP 协议规范建立——ARPANET 诞生——www 正式向公众开放</li>
<li>云计算是互联网和计算技术发展的产物，因此云计算一定离不开网络。A<br>A、TRUE<br>B、FALSE<br>10、关于 Host Machine 和 Guest Machine 关系描述正确的是（多选）CD<br>A、使用了虚拟化技术后，一台 Guest Machine 可以同时使用多台 Host Machine 的资源<br>B、使用了虚拟化技术后，一台 Guest Machine 只能运行在创建它的 Host Machine 上<br>C、使用了虚拟化技术后，一台 Host Machine 只能运行一个 Hypervisor<br>D、使用了虚拟化技术后，一台 Host Machine 上能够运行多台 Guest Machine<br>11、以下属于计算虚拟化的是（多选）ACD<br>A、CPU 虚拟化<br>B、网络虚拟化<br>C、内存虚拟化<br>D、I/O 虚拟化<br>E、磁盘虚拟化<br>12、KVM（Kernel-based Virtual Machine）虚拟机通过格式转换后可以运行在其他虚拟化平台<br>上。 B<br>A、TRUE<br>B、FALSE<br>13、在华为 FusionCompute 架构中，属于 Host Machine 角色的是（）A<br>A、CNA<br>B、UVP<br>C、KVM<br>D、VRM<br>14、以下描述中能体现虚拟化优势的是（多选）ABCD<br>A、使用虚拟化后，一台物理主机上可以同时运行多个虚拟机<br>B、使用虚拟化后，一台物理主机的 CPU 利用率可以稳定在 65%左右<br>C、使用虚拟化后，虚拟机可以在多台主机间进行迁移<br>D、使用虚拟化后，一台物理主机的操作系统上可以同时运行多个应用程序<br>15、以下关于 KVM（Kernel-based Virtual Machine）描述正确的是（多选）BCD<br>A、KVM 属于 II 型虚拟化<br>B、KVM 属于 I 型虚拟化<br>C、KVM 是 Linux 内核中的一个模块<br>D、KVM 是一种开源的虚拟化技术<br>16、在 KVM 类型的虚拟化中，以下描述正确的是（多选）ABD<br>A、Guest OS 可以是 Windows<br>B、Guest OS 可以是 Linux<br>C、Host OS 可以是 Windows<br>D、Host OS 可以是 Linux<br>17、在华为 FusionCompute 中，用户管理虚拟机的方式有（多选）AC<br>A、直接登录虚拟机进行管理<br>B、登录 CNA 后使用图形界面进行管理<br>C、登录 VRM 后使用图形界面进行管理<br>D、登录 CNA 后使用命令行进行管理<br>18、虚拟化技术可以提高硬件资源利用率，降低运营和运维成本，云计算也具备这些优势，<br>因此云计算和虚拟化技术是密不可分的。A<br>A、TRUE<br>B、FALSE<br>19、计算虚拟化通过不同的角度会产生不同的分类，可以分为 I 型和 II 型虚拟化，也可以分<br>为全虚拟化和半虚拟化。A<br>A、TRUE<br>B、FALSE<br>20、在华为 FusionCompute 中，以下只能作为非虚拟化存储的是（）B<br>A、NAS<br>B、FusionStorage<br>C、本地磁盘<br>D、SAN<br>21、下列 RAID 级别数据冗余能力最弱的是（）C<br>A、RAID 1<br>B、RAID 6<br>C、RAID 0<br>D、RAID 5<br>22、NAS 的架构体系中不包括以下哪项？B<br>A、卷管理模块<br>B、状态校验模块<br>C、文件系统<br>D、网络接口<br>23、对于档案室等需要长久存储大量数据信息，又不需要经常读取的场景，建议选择如下哪<br>种类型的磁盘？C<br>A、SAS 盘<br>B、NL-SAS 盘<br>C、SATA 盘<br>D、SSD 盘<br>24、SATA 盘是使用并行接口类型的磁盘，SAS 盘是使用串行接口类型的磁盘。B<br>A、TRUE<br>B、FALSE<br>25、在 RAID 5 和 RAID 6 中，允许出现故障的磁盘数量分别是（）C<br>A、3，2<br>B、2，1<br>C、1，2<br>D、2，3<br>26，以下能够在云计算 1.0 时代实现计算机虚拟化，提高资源利用率的是（ ）B<br>A．KVM<br>B． Xen<br>C． Hyper-v<br>D．OpenStack<br>27，KVM 使用 Virtio 后，对于 I/0 转发流程描述正确的是（ ） 【多选】AC<br>A． I/0 请求直接由前端驱动发送给后端驱动<br>B． I/0 请求不再经过 QUEM 转发<br>C． I/0 请求的转发效率会提高<br>D． I/0 请求需要 KVM 模块转发<br>28， 如果一个企业使用了混合云，不可以作为公有云和私有云分界点的设备是（ ）【多选】<br>AC<br>A． 核心交换机<br>B． 防火墙<br>C． 虚拟交换机<br>D． 流量清洗设备<br>29， 开源虚拟化技术都为Ⅰ型虚拟化，闭源的虚拟化技术都为Ⅱ型虚拟化（）B<br>A. TRUE<br>B. FALSE<br>30， 下列关于Ⅰ型（裸金属）计算虚拟化特点描述正确的是（ ） 【多选】BD<br>A． 应用程序可以直接运行在 VMM 上<br>B． Hypervisor 直接运行于物理硬件之上<br>C． 应用程序和虚拟机都可以直接运行在 Host OS 上<br>D． 应用程序不能直接运行在 Host Machine 上<br>31， 在华为 FusionCompute 中，删除存储资源的正确步骤是（ ）D<br>1， 删除或虚拟机磁盘<br>2， 解关联主机<br>3， 删除存储资源<br>4， 销毁数据存储<br>A. 3—&gt;2—&gt;4—&gt;1<br>B. 2—&gt;4—&gt;1—&gt;3<br>C. 1—&gt;2—&gt;3—&gt;4<br>D. 1—&gt;4—&gt;2—&gt;3<br>32， 为主机配置 IP SAN，通常需要在存储设备上为主机配置 使主机于 IP SAN 进行映<br>射。D<br>A. ISCSI Target<br>B. ISCSI Server<br>C. ISCSI Client<br>D. ISCCSI Initiator<br>33， 物联网的本质是互联网，只要有硬件或产品连上网络，发生数据交互就可以叫做物联<br>网（ ）A<br>A．TRUE<br>B． FALSE<br>34， 在华为 FusionCompute 中，FusionStorage 可以作为虚拟化存储使用（ ）B<br>A．TRUE<br>B． FALSE<br>35， 在华为 FusionCompute 中，当计算节点掉电时，系统可以将该计算机节点上具有 HA<br>属性虚拟化在其他计算机节点拉起，下列选项中不是实现该功能必要条件的是（ ）D<br>A．虚拟机未与主机绑定<br>B． 源目计算节点使用共享数据存储、<br>C． 计算节点所属集群开启 HA<br>D．计算节点上具有 HA 属性的虚拟机均使用同一网段 IP<br>36， 在计算虚拟化中，运行在虚拟机中的操作系统被称为 Host OS。B<br>A．TRUE<br>B． FALSE<br>37， 随着 AI 技术的发展，现在各项技术几乎都涉及到了人工智能，以下哪个是现在 AI 的<br>应用领域？ （ ） 【多选】ABCD<br>A．安抚机器人<br>B． 声音识别<br>C． 图像识别<br>D．NLP（Neuro-Linguistic Programing）<br>38，在华为 Fusioncompute 中，管理员可以通过扫描或者手动刷新来发现存储设备。A<br>A.TURE<br>B.FALSE<br>39， 在华为 FusionCompute 中，当集群中某台主机出现故障后，该主机上的虚拟机就会自<br>动迁移到集群中的其他主机上 （ ）B<br>A. TRUE<br>B. FALSE<br>40， 以下属于 CIFS 描述正确的是（ ）D<br>A. CIFS 支持多用户访问<br>B. CIFS 对网络传输的可靠性要求低，既可以使用 TCP/IP 协议也可以使用 UDP 协议<br>C. CIFS 要求 Client 必须安装专用软件<br>D. CIFS 保留了文件格式特性<br>41， 在华为 FusionCompute 中，如果服务器的物理网卡数较少，可考虑将多个平面合并部<br>署，使用 VLAN 从逻辑上对各平面进行隔离 A<br>A. TRUE<br>B. FALSE<br>42， 下列关于华为 FusionCompute 中的集群，主机和虚拟机描述不正确的是 （ ）C<br>A．判断主机是否属于同一集群取决于是否使用同意共享存储<br>B． 集群是由多个主机及其相关联的存储及网络资源组成的<br>C． 虚拟机可以跨集群迁移<br>D．主机可以在不同集群间移动</li>
<li>在华为 FusionCompute 中，最节省存储空间的虚拟机进盘的配置模式是（ ）C<br>A.普通<br>B.独立-持久<br>C.精简<br>D.独立-非持久</li>
<li>以下关于虚拟化存储和非虚拟化存储描述正确的是（ ）C<br>A.虚拟化存储的安全性比非虚拟化存储高<br>B.虚拟化存储的兼容性比非虚拟化存储好<br>C.非虚拟化存储的读写性能比虚拟化存储好<br>D.非虚拟化存储的扩展性比虚拟化存储好</li>
<li>以下哪种技术或设备不能隔离广播（ ）C<br>A.路由器<br>B.VLAN<br>C.Hub<br>D.防火墙<br>46，内存复用技术是内存资源 QoS 实现的前提。A<br>A.TURE<br>B.FALSE<br>47、以下关于 VIMS 文件系统描述不正确的是？D<br>A VIMS 可以兼容 FC SAN、IP SAN、本地磁盘<br>B VIMS 是精简磁盘、快照、存储迁移等高级特性的技术基础<br>C VIMS 是一种高性能集群文件系统<br>D VIMS 是业界通用的存储虚拟化文件系统<br>48、SAN 提供给主机的是一块未建立文件系统的“裸磁盘”，在上面建立什么文件系统，完<br>全取决于主机的操作系统 A<br>A TRUE<br>B FALSE<br>49、下列关于物理交换机和虚拟交换机区别的描述，不正确的是（）B<br>A 虚拟交换机运行在物理服务器上，物理交换机有单独的硬件<br>B 虚拟交换机无法对 VLAN 标签做操作，物理交换机可以对 VLAN 标签做操作<br>C 虚拟交换机无法配置三层接口，物理交换机可以配置三层接口<br>D 虚拟交换机的正常运行同样需要一定的硬件资源<br>50、在华为 FusionCompute 中，以下关于虚拟机和 DVS 的数量对应关系描述正确的是（多选）<br>ABC<br>A 一台虚拟机有一张网卡时，该网卡只能关联一个 DVS<br>B 一台虚拟机有多张网卡时，每张网卡都可以关联一个 DVS<br>C 一台虚拟机有多张网卡时，多张网卡可以关联同一个 DVS<br>D 一台虚拟机有一张网卡时，该网卡可以关联多个 DVS<br>51、某华为交换机端口配置如下：<br>Interface （GigabitEhernet 0/0/1）<br>Port link-type trunk<br>Port trunk allow-pass vlan 16 17<br>根据以上配置，下列说法正确的是（）D<br>A 包含 vlan 16 标签的数据帧在经过该端口时会被剥离标签并进行转发<br>B 未包含任何标签的数据帧在经过该端口时会被丢弃<br>C 未包含任何标签的数据帧在经过该端口时，会被添加 VLAN 16 或者 VLAN 17 的标签并<br>进行转发<br>D 包含 VLAN 17 标签的数据帧在经过该端口时会被保留标签并进行转发<br>52、在华为 FusionCompute 中，以下关于 CPU QoS 技术描述不正确的是（）Ｃ<br>A “预留”的作用是保证虚拟机计算能力的下限，即最少使用多少资源<br>B “份额”的作用是在计算资源不足的时候，根据多个虚拟机的相对 CPU 份额值进行资<br>源的均衡和调整<br>C “限制”的作用是规定主机是上运行的最大数量<br>D 通过调整“预留”、“份额”、“限制”，实现对虚拟机 CPU 资源使用的控制<br>53、在华为 FusionCompute 中，为方便统一管理，每一个 DVS 都需配置一个管理 IP 地址。<br>Ｂ<br>A TRUE<br>B FALSE<br>54.人工智能是研究、开发用于延伸扩展人工智能的理论、方法、技术及应用系统的一门新<br>技术科学，以下关于人工智能的说法错误的是（）Ｄ<br>A．人工智能没有社会性<br>B.人工智能是无意识的机械的物理的过程<br>C.人工智能没有人类的意识所特有的能动的创造力<br>D.人工智能是物品通过网络连通进行信息交互的技术<br>55、在华为 FusionCompute 中，虚拟机通过挂载本地镜像文件安装操作系统时，管理员可以<br>随时关闭 VNC 窗口，不会影响镜像的读取。Ｂ<br>A TRUE<br>B FALSE<br>56、以下关于内存复用的描述不正确的是（）Ｂ<br>A 内存复用技术可以使虚拟机内存规格总和大于物理服务器规格内存的总和<br>B 内存复用技术可以使虚拟机实际使用内存总和大于物理服务器规格内存的总和<br>C 内存复用功能开启后，内存复用率与每台虚拟机实际内存的使用量成反比<br>D 内存复用单项技术包含内存气泡、内存交换和内存共享<br>57、在华为 FusionCompute 中，以下对虚拟机 HA 描述正确的是（多选）ＡＢＣ<br>A 虚拟机 HA 功能可以在故障发生时，迅速恢复业务<br>B 系统检测到虚拟机蓝屏且配置处理策略为 HA 时，系统会选择其他正常的计算节点重建<br>虚拟机<br>C 在集群中启用 HA 功能后，主机发生故障后，虚拟机可以在其他主机上重建<br>D 集群中只要预留了资源，故障发生时，具有 HA 属性的虚拟机就能在其他计算节点重建<br>成功<br>58、快照不适用以下哪个场景？Ｂ<br>A 业务毁灭性测试<br>B 业务数据长久保存<br>C 业务补丁升级<br>D 业务重大变更<br>59、在交换机上下列哪个技术可以提高链路速率？Ｂ<br>A LDAP<br>B LACP<br>C VLAN<br>D VXLAN<br>60、以下关于虚拟化描述不正确的是（多选）ＡＢ<br>A 网络虚拟化指的是分布式虚拟交换机<br>B 存储虚拟化指的是分布式存储<br>C 在云计算中，IaaS 层虚拟化可以分为计算虚拟化、存储虚拟化和网络虚拟化<br>D 计算虚拟化包含 CPU 虚拟化、内存虚拟化和 IO 虚拟化<br>61、CPU 虚拟化技术可以分为全虚拟化、半虚拟化、软件虚拟化和硬件辅助虚拟化。Ｂ<br>A TRUE<br>B FALSE<br>62、在华为 FusionCompute 中，使用非虚拟化存储的虚拟机不支持快照功能。Ｂ<br>A TRUE<br>B FALSE<br>63、物联网设备可以连接到互联网，并可以通过互联网进行控制。Ａ<br>A TRUE<br>B FALSE<br>64、有些虚拟化技术是开源的，有些是闭源的，云计算管理平台也一样，开源的云计算管理<br>平台需要使用开源的虚拟化技术来实现。Ａ<br>A TRUE<br>B FALSE<br>65、在华为 FusionCompute 中，DVS 除了支持配置静态路由，也支持多种动态路由。Ｂ<br>A TRUE<br>B FALSE<br>66、在华为 FusionCompute 中，默认的告警级别不包括（）Ａ<br>A 普通<br>B 紧急<br>C 提示<br>D 次要<br>E 重要<br>67、在华为 FusionCompute 中采用导入虚拟机的方式创建虚拟机，以下文件格式中不支持的<br>是（）Ｄ<br>A .ova<br>B .qcow2<br>C .ovf<br>D .vmdk<br>68、某华为交换机端口的配置如下：<br>Interface GigabitEhernet 0/0/1<br>Port link-type access<br>Port default vlan 16<br>根据以上配置，下列说法正确的是（）ＡＣ<br>A 该端口会为将经过的数据帧添加添加 vlan 16 的标签<br>B 该端口只允许含有 vlan 16 标签的数据通过<br>C 该端口会将经过的数据帧的 vlan 16 的标签剥离，并进行转发<br>D 该端口不会对经过的数据帧做任何操作<br>69、在华为 FusionCompute 中，为提高 VRM 的可靠性，建议采用以下哪种部署方式？Ａ<br>A 主备部署<br>B 单节点部署<br>C 混合部署<br>D 双活部署</li>
<li>以下哪项不属于大数据 4V 的特点（ ）Ｃ<br>A.Value<br>B.Varitey<br>C.Valid<br>D.Volume<br>71 以下关于云计算和物联网的关系说法不正确的是哪一个？Ａ<br>A. 假如没有云计算的支持，物联网无法进行数据传输<br>B. 云计算是物联网发展的基石，同时物联网又不断促进着云计算的发展<br>C. 云计算可以为物联网的海量数据提供足够大的存储空间<br>D. 假如没有云计算作为基础支撑，物联网的工作效率会大大降低<br>72 存储虚拟化技术可以提高存储的利用率，为多台虚拟机提供存储资源Ａ<br>A. 对<br>B. 错<br>73.在华为 FusionCompute 中，以下哪个操作可以即时生效？Ｄ<br>A. 对新绑定磁盘直接读写<br>B. 安装 Tools<br>C. 磁盘减容<br>D. 删除网卡<br>74.虚拟交换机在虚拟机之间通信时起很重要的作用，是一个不可或缺的组件Ａ<br>A. 对<br>B. 错<br>75.以下关于 FusionCompute 中制作模板的描述，不正确的是（）。Ｂ<br>A. “虚拟机转为模板”是将虚拟机直接转换为模板，所有参数均使用该虚拟机当前配置，<br>转换后该虚拟机将不再存在<br>B. 使用虚拟机制作模板时，虚拟机的状态可以为“运行中”<br>C. “模板克隆为模板”是复制该模板为新模板并支持调整部分参数配置，可以与原模板稍<br>有不同，克隆完成后模板仍然存在<br>D. “虚拟机机克隆为模板”是复制该虚拟机为模板并支持调整部分参数配置，可以与原虚<br>拟机稍有不同，克隆完成后该虚拟机仍然存在<br>76.在华为 FusionCompute 中，如果一台虚拟机和主机做了绑定，会受影响的功能有（多选）。<br>AＣ<br>A. DNS<br>B. 内存热添加<br>C. 热迁移<br>D. 快照<br>77.FusionCompute Installer 部署 VＲＭ虚拟机采用的方式是（）。Ｂ<br>A. ISO 文件自动安装<br>B. 模板文件导入虚拟机<br>C. 自动创建虚拟机，自动挂载 ISO 文件安装<br>D. PXE 自动安装<br>78.在华为 FusionCompute 中，关于“共享”类型磁盘描述正确的是（多选）。AＤ<br>A. 绑定了此类硬盘的虚拟机不支持快照功能<br>B. 此类硬盘只能绑定给一台虚拟机<br>C. 虚拟机不支持对此类硬盘更改数据存储<br>D. 此类硬盘可以绑定给多台虚拟机<br>79.以下关于 NFS 描述正确的是（）。Ｃ<br>A. NFS 客户端不需要安装专门的软件<br>B. NFS 无法设置用户权限<br>C. NFS 支持多用户访问<br>D. NFS 属于有状态协议<br>80.内存复用技术无法实现（）。Ａ<br>A. 开启内存复用技术，复用比越高，虚拟机性能越强<br>B. 开启内存复用技术，可以提升物理主机上虚拟机的部署程度<br>C. 如果用户虚拟机内存使用率比较高，可以通过修改内存复用比进行优化<br>D. 开启内存复用技术，用户创建的所有虚拟机的内存总和可以超过物理内存</li>
<li>物联网的功能只是对各个事物产生的数据进行收集。Ｂ<br>A. 对<br>B. 错</li>
<li>在物理网络中，哪个设备能够进行路由转发？Ｃ<br>A. Hub<br>B. 二层交换机<br>C. 路由器<br>D. 物理服务器网卡</li>
<li>在云计算中，网络可分为虚拟网络和物理网络两部分Ａ<br>A. 对<br>B. 错</li>
<li>在 FusionCompute 中，以下关于删除安全组的描述不正确的是（）。C<br>A. 待删除安全组与其他安全组之间的授权行为不影响删除操作<br>B. 安全组内不存在虚拟机，如果安全组内有虚拟机，需要将虚拟机移除安全组<br>C. 安全组删除后，组内所有安全组规则同时被删除<br>D. 删除虚拟机所属的一个安全组时，其他安全组对该虚拟机作用不受影响</li>
<li>智能内存复用技术（内存气泡、内存交换、内存共享）可以根据客户需求，自定义开启/<br>关闭其中任一功能 B<br>A. 对<br>B. 错</li>
<li>在华为 FusionCompute 中，需要对虚拟机的某块磁盘做修改，下列操作可以实现的是（）。<br>C<br>A. 将磁盘的容量从 80GB 修改为 8GB<br>B. 将磁盘的配置模式从“精简”改为“普通”<br>C. 将磁盘的模式从“从属”改为“独立-持久”<br>D. 将磁盘的状态从“可用”改为“不可用”</li>
<li>在华为 FusionCompute 中，DPM 必须依赖 DRS 才可以使用。A<br>A. 对<br>B. 错</li>
<li>以下关于 iSCSI 和光纤通道描述不正确的是（）。D<br>A. FC 协议与现有的以太网是完全异构的，兼容性比较差<br>B. iSCSI 基于 TCP/IP 协议运行在以太网上，可以与现有的以太网无缝结合<br>C. FC 的传输距离比 TCP/IP 远<br>D. 从传输层看，光纤通道的传输采用 FC 协议，iSCSI 采用 TCP/IP 协议</li>
<li>以下不属于快照管理的是（）。A<br>A. 复制快照<br>B. 修改快照<br>C. 创建快照<br>D. 删除快照</li>
<li>在华为 FusionCompute 中使用模板可以批量部署多台虚拟机 A<br>A.TRUE<br>B.FALSE<br>91.在华为 fusioncompute 中，加入同一个安全组的所有虚拟机网卡都使用该安全组过滤，为<br>了提高安全性，需将同一网卡加入多个安全组中。B<br>A. TURE<br>B. FALSE<br>92.一个虚拟机可以同时有多个虚拟网卡，对应不同的虚拟交换机。A<br>A.TURE<br>B.FALSE<br>93.华为 fusioncompute 不支持以下哪种虚拟机磁盘文件格式？A<br>A.VMDK<br>B.VHD<br>C.RAW<br>D.QCOW2<br>94.在 fusioncompute 中，虚拟交换机通过（）连接到物理网络。D<br>A.INIC<br>B.虚拟网卡<br>C.端口组<br>D.上行链路<br>95.安全组内的规则会随着安全组一并被删除 B<br>A.TRUE<br>B.FALSE<br>96.存储虚拟化可以分为哪几类？（多选）BD<br>A.应用级虚拟化<br>B.块级虚拟化<br>C.页面级虚拟化<br>D.文件级虚拟化<br>97.在磁盘上建立文件系统的过程通常称为（ ）B<br>A.封装<br>B.格式化<br>C.RAID<br>D.分区<br>98.虚拟机可以与其他虚拟机正常通讯的必要条件有（多选）BC<br>A.为该虚拟机配置固定 IP 地址<br>B.为该虚拟机配置正确的 IP 地址<br>C.为该虚拟机配置正确的 MAC 地址<br>D.为该虚拟机配置网关地址<br>99 在华为 FunsionCompute 中，在 VRM 上可以执行的操作有（多选）CD<br>A 为磁盘阵列划分 RAID<br>B 将虚拟化存储转化为非虚拟化存储<br>C 为虚拟机手动添加存储设备<br>D 将 SAN 存储添加为非虚拟化存储<br>100 在华为 FunsionCompute 中为 DVS 配置的 VLAN ID（除 0 外），需要在物理交换机上存<br>在，否则会影响虚拟机的正常通讯。B<br>A TRUE<br>B FALSE<br>101 以下关于 Hypervisor 描述正确的是（）D<br>A Hypervisor 就是虚拟化<br>B Hypervisor 本质是一个操作系统<br>C Hypervisor 中携带大量驱动，所以 Hypervisor 不需要安装驱动以及补丁<br>D Hypervisor 是进行计算机虚拟化的关键<br>102.在华为 FusionCompute 中创建一块新的磁盘，下列操作哪个是不正确的（ ）C<br>A.将磁盘类型设置为“普通”，并将磁盘模式设置为“独立-非持久”<br>B.将磁盘的配置模式设置为“精简”，并将磁盘模式设置为“独立-持久”<br>C.将磁盘模式设置为“独立-非持久”，并将裸设备映射改为“支持”<br>D.将磁盘的配置模式设置为“精简”，并将磁盘模式设置为“独立-非持久”<br>103.如果虚拟机要和其他虚拟机通讯，下列哪个选项的操作是必须的？D<br>A.需要在物理服务器上配置端口绑定<br>B.需要在物理交换机上配置端口绑定<br>C.需要将虚拟机所在的物理服务器联网<br>D.需要为虚拟机添加至少一块网卡<br>104.该图片描述的服务模式是（）A<br>A. IaaS<br>B. DaaS<br>C. PaaS<br>D. SaaS<br>105.物理交换机一般支持以下哪些方式进行远程管理（多选）ACD<br>A. Telnet<br>B. SSL<br>应用程序<br>存储资源<br>计算资源<br>虚拟化<br>操作系统<br>中间件<br>运行环境<br>数据<br>自<br>营<br>云<br>服<br>务<br>商<br>提<br>供<br>C. Web<br>D. SSH<br>106 关于 VNC 说法正确的是（多选）BC<br>A VNC 需要支持 Linux 操作系统<br>B 被控制的计算机需要安装相应的软件成为 VNC server<br>C VNC 是一款轻量型远程控制软件<br>D 发起控制请求的主机需要安装相应的软件成为 VNC server<br>107 以下 Hypervisor 描述不正确的是（）D<br>A 在虚拟化中，Hypervisor 和 VMM 是一个概念<br>B 在虚拟化中，Hypervisor 可以直接运行在 Host Machine 上<br>C 在虚拟化中，Hypervisor 能够监控 Guest Machine 的状态<br>D 在虚拟化中，只有 Hypervisor 能够直接访问物理资源<br>108.以下哪个场景不建议开启内存复用功能？C<br>A.普通办公云主机<br>B.电信营业厅<br>C.图形工作站<br>D.银行窗口办公<br>109.NUMA 是一种为多处理器的计算机设计的内存架构，内存访问时间取决于内存相对于处<br>理器的位置，在 NUMA 下，处理器访问它自己的本地内存的速度比非本地内存（内存位于<br>另外一个处理器，或者是处理器之间共享的内存）快一些。A<br>A. TRUE<br>B. FALSE</li>
<li>以下属于南北向流量的是（多选 ）BC<br> A.虚拟机热迁移产生的流量<br> B.虚拟机间跨数据中心相互访问的流量<br> C.客户通过互联网访问数据中心的业务产生的流量<br> D.数据中心内部虚拟机之间互相访问的流量<br> 111.在华为 FusionCompute 中可以做的操作（多选）BCD<br> A.将其他虚拟化平台的虚拟机转换成 FusionCompute 可用的虚拟机<br> B.克隆虚拟机<br> C 创建虚拟机<br> D 删除虚拟机<br> 112.云计算虚拟网络中的数据包需要通过物理网络中的路由器进行路由转发。B<br> A.TURE<br> B.FALSE<br> 113.ISCSI 是建立在<strong>___协议和 SCSI 指令集基础上的标准话协议，广泛应用于许多采用<br> __</strong>架构的存储网络中。D<br> A.FC IP SAN<br> B.TCP/IP FC SAN<br> C.FC FC SAN<br> D.TCP/IP IP SAN<br> 114.云计算是并行计算、网格计算和分布式计算发展的产物，关于四者关系描述正确的是（）<br> C<br> A.分布式计算出现后完全取代了网格计算<br> B.云计算是分布式计算的一种<br> C.并行计算、网络计算和分布式计算都属于云计算<br> D.网格计算出现后完全替代了并行计算<br> 115.在华为 FusionCompute 中，DVS 对应的传统网络设备是（）C<br> A.路由器<br> B.集线器<br> C.二层交换机<br> D.三层交换机<br> 116.下列关于云计算资源池化特性描述正确的是（）D<br> A. 云计算资源池化特性是实现广泛网络接入的前提<br> B. 云计算资源池化特性可以将 CPU 和硬盘放入到同一个资源池中<br> C. 云计算资源池化特性可以屏蔽同类资源间的差异<br> D. 云计算资源池化特性必须依赖虚拟化技术才能实现<br> 117.模板可以用来快速部署虚拟机，目前只能通过转换或克隆虚拟机的方式制作模板。A<br> A. TRUE<br> B. FALSE<br> 118.在华为 FusionCompute 中，虚拟机可以有多个虚拟网卡。A<br> A. TURE<br> B. FALSE<br> 119.快照创建过程中，可以对虚拟机进行其他操作。B<br> A.TURE<br> B.FALSE<br> 120.如果虚拟机 A 能够 ping 通虚拟机 B，由此可推断出以下哪个结果？B<br> A. 虚拟机 A 和虚拟机 B 使用了同一网段<br> B. 虚拟机 A 和虚拟机 B 都配置了正确的 IP 地址<br> C. 虚拟机 A 和虚拟机 B 使用了不同网段<br> D. 虚拟机 A 和虚拟机 B 运行在同一个物理主机上<br> 121.在华为 FusionCompute 中，以下关于热迁移的描述不正确的是（）C<br> A. 热迁移包括虚拟机热迁移和磁盘热迁移<br> B. 虚拟机热迁移过程中使用内存数据快速复制及共享存储的技术，确保虚拟机迁移前后数<br> 据不变<br> C. 存储热迁移仅可在存储虚拟化管理下的同一个存储设备内进行迁移<br> D. 虚拟机热迁移类型分为更改主机、更改数据存储以及更改主机和数据存储<br> 122.在华为 FusionCompute 中 DRS 规则对绑定 USB 设备的虚拟机无法生效。A<br> A.TURE<br> B.FALSE<br> 123 在华为 FusionCompute 中，创建虚拟机的方式有（多选）BCD<br> A 其他虚拟平台导入<br> B 使用模板部署<br> C 使用已有的虚拟机克隆<br> D 直接创建一个新虚拟机<br> 124 常见的磁盘阵列包括（多选）BC<br> A MAID （massive arrays of Idle disks）<br> B RAID<br> C JBOD（Just a bunch of Idle disks）<br> D SBOD（Switch of bunches Idle disks）<br> 125.内存复用是一种提升单主机上虚拟机密度、降低成本、牺牲性能换取密度的一种资源分<br> 配方案。B<br> A.TRUE<br> B.FALSE<br> 126、FC SAN，相比以下哪个不是 IP SAN 的优势？C<br> A 带宽扩展方便<br> B 构建成本低<br> C 传输距离远<br> D 传输效率高<br> 127.下列关于 II 型（宿主型）虚拟化描述正确的是（）D<br> A. VMM 运行在 Guest Machine 中<br> B. VMM 直接运行在 Host Machine 上<br> C. VMM 运行在 Guest OS 上<br> D. VMM 运行在 Host OS 上<br> 128.以下关于 KVM 和 Xen 描述正确的是（多选）AC<br> A. Xen 虚拟机可以转换成 KVM 虚拟机<br> B. Domain 0 和 Domain U 是 KVM 中的概念<br> C. KVM 和 Xen 都是开源的 Hypervisor<br> D. KVM 和 Xen 可以运行在同一个 Host OS 中<br> 129.安装华为 FusionCompute 时，推荐将 VRM 部署在哪种存储上？D<br> A. NAS<br> B. FC SAN<br> C. IP SAN<br> D. 本地磁盘<br> 130.以下关于模板描述不正确的是（）D<br> A. 虚拟机克隆为模板后，虚拟机还存在<br> B. 使用模板部署虚拟机时，可自定义参数<br> C. 将模板转为虚拟机之后，模板不再存在<br> D. 模板可以跨虚拟化平台使用<br> 131.在云计算中相同类型不同型号的硬件可以组成一个资源池。B<br> A.TRUE<br> B.FALSE<br> 132.以下关于华为虚拟交换机描述正确的是( ) C<br> A、智能网卡的虚拟交换功能也是由华为虚拟交换机提供的<br> B、华为虚拟交换机就是开源的 open vSmitch<br> C、华为分布式交换机若有多个虚拟端口，每个端口都具有各自的属性<br> D、华为虚拟交换机分为标准虚拟交换机和分布式虚拟交换机<br> 133.下列关于热迁移和冷迁移的描述不正确的是( )。D<br> A、热迁移是将运行状态的虚知机从一台主机迁移到另一台王机，迁移过程中业务不会发生<br> 中断<br> B、在性能测试-可靠性测试中，有针对虚拟机迁移的测试，包括热迁移、冷迁移、迁移时长、<br> 业务中断时长.<br> C、冷迁移是将停止状态的虚知机从一台主机迁移到另-台主机，迁移过程中业务会发生中断<br> D、热迁移和冷迁移都会迁移内存数据和磁盘数据<br> 134 在华为 FunsionCompute ，关于虚拟机迁移描述不正确的是 B<br> A 源主机和目的主机之间通信正常<br> B 目的存储为不同存储设备<br> C 虚拟机状态为“运行中” D 目的主机须有足够的资源<br> 135 在华为 FunsionCompute 以下关于主机存储接口描述不正确的是 C<br> A 支持手动添加和批量添加两种方式来添加接口<br> B 通过添加多个存储接口，可以实现存储的多路径传输<br> C 存储接口的 IP 地址可以与管理平面处于同一网段<br> D 本地硬盘和 FC SAN 不用添加存储接口就可以本机实现存储设备的对接<br> 136.虚拟机一般虚拟机配置信息和磁盘文件组成，用户可以通过移动两个文件来实现虚拟机<br> 在不同的物理主机上运行。以上描述体现了云计算的哪些特点？（多选）ABCD<br> A．分区<br> B． 隔离<br> C． 独立<br> D．封装<br> 137.以下不属于 KVM（Kernel-Based Virtual Machine）管理工具的是（）A<br> A．QEMU<br> B． Virsh 指令集<br> C． Virt-Manager<br> D．Libvirt<br> 138.以下关于虚拟化描述正确的是（）C<br> A. 虚拟化和非虚拟化不能同时在一个数据中心中存在<br> B. 在物理机上能运行的应用一定也可以在虚拟机上运行<br> C. 虚拟化可以提高硬件资源的统一性<br> D. 使用不同类型虚拟化技术的虚拟机间能够互相转换<br> 139.在计算虚拟化中，为虚拟机分配 CPU 和内存的是（多选）AB<br> A．Hypervisor<br> B． VMM<br> C． Guest OS<br> D．Host OS<br> 140.KVM 虚拟机可以通过图形化界面创建，也可以使用命令行创建 A<br> A．True<br> B． False<br> 141.使用虚拟化技术可以将一台物理服务器虚拟成多台虚拟机，从而提升了物理服务器的硬<br> 件性能。B<br> A．True<br> B． False<br> 142.在 Linux 虚拟机中。能够实现对逻辑卷进行管理的是 B<br> A OVM<br> B LVM<br> C PVM<br> D DVM<br> 143.在华为 FusionCompute 中，以下关于端口组和安全组描述不正确的是 D<br> A 一张虚拟机网卡连接端口组的一个虚拟端口，一张虚拟机网卡关联一个安全组<br> B 端口组是 DVS 上一个或多个虚拟端口的集合，而安全组是一条或多条规则的集合<br> C． 一个 DVS 可以有多个端口组，一个 VM 可以受多个安全组保护<br> D．安全组是基于端口组来保护虚拟机的<br> 144.NAS 支持以下哪些网络文件共享协议（多选）AB<br> A CIFS<br> B NFS<br> C NTFS<br> D FTP<br> 145.交换机根据用途可分为接入交换机、汇聚交换机和核心交换机，虚拟交换机属于汇聚交<br> 换机 B<br> A True<br> B False<br> 146.在实际工作中，VLAN 能实现的功能是哪个（）A<br> A 属于相同 VLAN 的虚拟机机 IXUS 使用相同地址段的 IP 地址，否则无法正常通信<br> B 两个部门的虚拟机使用了不同的 VLAN 以后，相互之间不能再通信<br> C 属于相同 VLAN 的虚拟机可以使用不同地址段的 IP 地址，并能使用广播发现彼此<br> D 属于不同 VLAN 的虚拟机可以使用相同的 IP 地址，且不会发生地址冲突<br> 147.如果两个虚拟机能够 ping 通彼此，在通讯的过程中一定会使用到的网络设备是（）A<br> A. 分布式虚拟机交换机<br> B. 物理交换机<br> C. 物理网卡<br> D. 虚拟网卡<br> 148.在 KVM 中，虚拟机网卡连接物理网络的方式有两种，分别是（）和（）A<br> A 桥接、地址转换<br> B 地址转换、直通<br> C 桥接、直通<br> D 直通、桥接<br> 149.在华为 FusionCompute 中，以下关于安全组和规则描述不正确的是（）A<br> A 安全组规则的变更需要手动应用到安全组内的虚拟机<br> B 必须先创建安全组，才能添加规则<br> C 安全组在未添加规则前，默认拒绝所有<br> D 删除安全组的前提是安全组内无虚拟机<br> 150.利用模板快速部署虚拟机时，不需要安装操作系统，也不需要进行相关配置，因此会节<br> 省大量时间与精力 A<br> A True<br> B False<br> 151.在华为 FusionCompute 中，以下关于 CPU 资源 QoS 描述不正确的是（）B<br> A. CPU 预留定义了多个虚拟机竞争物理 CPU 资源的时候分配的最低计算资源<br> B. CPU 限额定义多个虚拟机在竞争物理 CPU 资源时按优先级分配计算资源<br> C. CPU 份额定义多个虚拟机在竞争物理 CPU 资源时按比例分配计算资源<br> D. CPU 预留只在个虚拟机竞争计算资源的时候才发挥作用，如果没有竞争情况发生，<br> 有需求 虚拟机可以独占物理 CPU 资源<br> 152.在华为 FusionCompute 中，以下对内存复用描述不正确的是 C<br> A. 管理员可以随时开启或关闭内存复用功能<br> B. 关闭内存复用功能后所有虚拟机的内部总和小于等于实际可用物理内存总和<br> C. 使用内存复用会使虚拟机性能下降<br> D. 关闭内存复用要求集群下所有主机的内存复用率小于等于 100%<br> 153.以下关于安全组应用场景描述不正确的是（）A<br> A. 通过设置安全组规则，可以对虚拟机中的文件夹进行权限控制<br> B. 通过设置安全组规则，可以实现只允许特定 IP 地址对虚拟机进行远程登录<br> C. 通过设置安全组规则，可以保护虚拟机不被访问<br> D. 通过设置安全组规则，可以使虚拟机无法访问 FTP 服务器<br> 154.一下关于快照的描述不正确的是（）B<br> E． 一台虚拟机可以创建多个快照，使用快照恢复虚拟机时，会导致其后的快照失效<br> F． 快照既可以保存虚拟机设置，也可以保存虚拟机磁盘的数据<br> G．一台主机上的所有虚拟机只能同时创建一个内存快照<br> H．快照可以保存虚拟机内存的状况<br> 155.使用同一个 Window 模板快速部署虚拟机时，生成的 SID 可能会一致。从而导致安装一<br> 些特殊软件时会失效 A<br> A. True<br> B. False<br> 156.在 OpenStack 解决方案中，负载提供持久化块存储的模块是哪一个？D<br> A Swift<br> B Glance<br> C Nova<br> D Cinder<br> 157.在华为 FusionCompute 中，多台虚拟机同时对同一个共享磁盘进行写操作时，为了防止<br> 数据丢失，需要保证应用软件对磁盘的访问控制 A<br> A. True<br> B. False<br> 158.以下关于华为 FusionCompute HA 描述不正确的是 B<br> A 虚拟机的数据如果保存在共享存储内，发生故障时保存的数据不会丢失<br> B 该功能支持虚拟机故障后自动重启<br> C 系统周期检测虚拟机状态，当物理服务器故障引起虚拟机故障时，系统可以将虚拟<br> 机迁移到其他物理服务器重新启动，保证虚拟机能够快速恢复<br> D 管理员可以根据虚拟机的重要程度，设置不同的 HA 策略<br> 159.在华为 FusionCompute 中将端口组 vlan ID 设为 10 代表了（多选）CD<br> A 对经过该端口组带有 VLAN 10 标签的数据帧去标签后进行转发<br> B 对经过该端口组带有 VLAN 10 标签的数据帧进行改标签为 VLAN ID 后进行转发<br> C 对经过该端口组带有非 VLAN 10 标签的数据帧进行丢弃<br> D 对经过该端口组带没有 VLAN 标签的数据帧打上 VLAN 10 的标签后进行转发<br> 160.在华为 FusionCompute 中，一下关于 IMC 功能描述不正确的是（）D<br> A 集群内 CNA 主机 CPU 型号不一致时建议开启 IMC 功能<br> B 开启 IMC 不能确保虚拟机在不同型号 CPU 的主机间迁移成功，需根据实际场景确定<br> C IMC 仅支持从低版本 CPU 功能集向高版本迁移<br> D 集群内 CNA 主机内存主频不一致时建议开启 IMC 功能<br> 161.在华为 FusionCompute 中，虚拟机内部删除数据后，磁盘大小不会自动缩减，下次用户<br> 再写入时，会利用这些内部释放出来的空间 A<br> A. True<br> B. False<br> 162.在华为 FusionCompute 中，使用 IP SAN 创建磁盘的操作包括</li>
<li>创建存储资源</li>
<li>在主机上添加存储端口</li>
<li>添加数据存储</li>
<li>创建磁盘<br>正确的操作顺序是 D<br>A.1-3-4-2<br>B.4-2-1-4<br>C.1-2-3-4<br>D.2-1-3-4<br>163.华为 FusionCompute 可以在虚拟机运行过程中感知全局物理资源的使用情况，并通过智<br>能调度算法，计算出适合虚拟机运行的最佳主机，并通过热迁移等手段将虚拟机运行在最佳<br>主机上，从而提升全局业务体验 A<br>A True<br>B False<br>164.常见的外挂存储解决方案有 BD<br>A．DAS<br>B． NAS<br>C． NFS<br>D．SAN<br>165.SSD 盘属于机械类硬盘，具有读写速度快、功耗小、重量轻等优点，但其有使用寿命的<br>限制 B<br>A、True<br>B、False<br>166.以下 RAID 级别中，磁盘空间利用率最高的是 A<br>A、RAID 0<br>B、RAID 6<br>C、RAID 1<br>D、RAID 5<br>167.用户在华为公有云上哪申请了一块云硬盘，该服务模式属于 A<br>A．IaaS<br>B． DaaS<br>C． PaaS<br>D．SaaS<br>168.以下 VLAN 的作用描述不正确的是 B<br>A．增强网络的安全性<br>B． 提高物理交换机接口带宽<br>C． 隔离广播域<br>D．提高网络的健壮性<br>169.CPU 资源 QoS 和内存复用技术都是综合运用不同策略对资源进行合理分配 A<br>A．True<br>B． False<br>170.华为 FusionCompute DRS 规则能够实现以下哪个需求 C<br>A．Windows 虚拟机发生蓝屏后，系统自动将其重启<br>B． 集群中的某个主机不可用是，运行在该主机上的虚拟机自动迁移到奇台主机上<br>C． 要求某虚拟机运行在特定的主机上<br>D．虚拟机配置不满足业务需求时，管理系统自动为该虚拟机增加 CPU 资源<br>171.以下不适合提高内存复用比的场景是 A<br>A．商用场景下内存复用已经达到 150%<br>B． 降低客户硬件采购成本<br>C． 在保证性能的同时，客户要求单台主机部署最大数量的虚拟机<br>D．虚拟机内存利用率较低<br>172.在华为 FusionCompute 中，开启计算资源调度自动化功能后，虚拟机发生迁移的原因可<br>能是（多选） ACD<br>A．windows 虚拟机发生蓝屏并且处理策略为“HA 虚拟机”<br>B． 运行在虚拟机上的应用程序崩溃<br>C． 管理员根据系统提示手动迁移<br>D．系统根据调度策略自动迁移<br>173.虚拟 NUMA 的包括哪些 （多选）ABCD<br>A．负载均衡，在调度过程中考虑 node 关联性，已经 node 与物理 node 对应关系，最<br>大限度保证 VCPU 访问本地内容<br>B． 场地放置，查看虚拟机 NUMA 拓扑，选择物理 node 方式 VCPU 和内存，便 nide 中<br>VCPU 与内存关系与物理实际一直<br>C． 拓扑呈现，虚拟机颞部识别到 NUMA，使用 GuestOS 及应用 NUMA 优化功能生效<br>D．动态迁移，当 VCPU 与物理 node 亲和关系发生变化是，触发其对应 Vnode 内存进行<br>迁移<br>174.雾计算（fog computig）是一种分布式计算模型，将云计算的概念扩展到网络边缘，以<br>支持移动和物联网和地理分布式应用。以下关于雾计算的说法不正确的是 C<br>A．雾计算可以在网络边缘快速生成大数据、减少延迟<br>B． 雾计算可以实现数据短暂缓存，减少网络压力<br>C． 雾计算比云计算提供更高可靠性的网络和物理设备安全<br>D．雾计算可以减少核心 Internet 中消耗的贷款，限制数据向本地网络的移动<br>175.下列选项中不属于人工智能的要素的是 B<br>A. 计算能力<br>B. 感性分析<br>C. 大数据<br>D. 场景<br>176.人工智能是研究、开发用于模拟延伸和扩展人工智能的概念、方法、技术及应用系统的<br>一门新的技术科学，以下关于人工智能说法错误的是 B<br>A. 人工智能没有人类的意识所特有的能动创造力<br>B. 人工智能是物品通过网络相互连通进行信息交互的技术<br>C. 人工智能没有社会性<br>D. 是无意识的机械的物理的过程<br>177.在华为 FusionCompute 中将端口组 VLAN ID 设置为 0 代表 D<br>A．将通过该端口组的数据帧的 vlan 标签设置为 0<br>B． 只允许带有 vlan 0 标签的数据帧通过该端口组<br>C． 允许 0 个带有 vlan 标签的数据帧通过该端口组<br>D．对通过本端口组的数据帧不做任何修改<br>178.若华为 FusionCompute 中，以下关于计算资源调度的衡量因素描述不正确的是 D<br>A．设为”CPU”时，满足 CPU 条件即触发调度策略<br>B． 设为”内存”时，满足内存条件即触发调度策略<br>C． 设为”CPU 和内存”时，满足 CPU 或内存条件即触发调度策略<br>D．设为”CPU 和内存”时，满足 CPU 及内存条件才触发调度策略<br>179.在华为 FusionCompute 中，使用裸设备映射类型数据存储的虚拟机不支持（）（多选）<br>ACD<br>A. 快照<br>B. CPU 热添加<br>C. 存储精简配置<br>D. 存储热迁移<br>180.以下关于虚拟化和云计算关系描述正确的是（多选） BCD<br>A、设有云计算，虚似化就没有存在的价值<br>B、虚拟化是一种技术，云计算是一种服务模式，虚拟化推动了云计算的发展<br>C、没有虚拟化，云计算就没有存在的价值<br>D、虚拟化是实现云计算的重要技术之一<br>181.以下属于虚拟化技术出现及发展的主要驱动力是（）C<br>A、互联网的出现<br>B、降低硬件资源的故障率<br>C、充分利用硬件资源<br>D、提高硬件资源的辨识度<br>182.虚拟化分为计算虚拟化、存储虚拟化和网络虚拟化，对应云计算的云主机，云存储，云<br>网络 B<br>A、对<br>B、错<br>183.虚拟化的特点包括分区，隔离，封装和独立 A<br>A、对<br>B、错<br>184.以下哪些选项属于 KVM（多选） AC<br>A、Libvirt<br>B、Domain 0<br>C、QEMU<br>D、ESXI<br>185.以下选项属于开源虚拟化技术的是（）C<br>A、FusionCompute<br>B、vSphere<br>C、KVM<br>D、Hyper-v</li>
<li>下列选项中，关于云计算按需自助服务特点描述正确的是（）C<br> A、云计算服务提供商只需要将所有的服务准备好即可，剩余工作完全由用户自己完成<br> B、用户在使用云计算的过程中，需要自己解决所有的问题<br> C、用户确定了自己需要的云计算服务后，可以独自完成云计算资源的申请<br> D、用户在使用云计算资源时，完全不需要和服务提供商交代<br> 187 计算虚拟化技术可以提高应用程序可靠性的原因是（多选）ABCD<br> A、 承载应用程序的虚拟机和硬件解耦，可以使用虚拟机在多个物理主机间迁移<br> B、 使用计算机虚拟化技术可以自动将承载应用程序的虚拟机分配到资源充足的物理主机<br> C、 使用计算虚拟化技术可以使多个应用同时运行在一台物理主机上<br> D、 使用计算虚拟化技术可以自动调整虚拟化规格<br> 188 在华为的 FusionCompute 中，虚拟机的系统盘无法解绑定 A<br> A、 True<br> B、 False<br> 189 以下关于分布式存储描述正确的是（）C<br> A、 分布式存储的磁盘来自于 x86 架构的磁盘阵列<br> B、 分布式存储的磁盘来自于个人 PC<br> C、 分布式存储的磁盘来自于 x86 架构的服务器<br> D、 分布式存储的磁盘来自于 x86 架构的虚拟机<br> 190 以下关于 RAID 的描述正确的是（多选）AC<br> A、 RAID6 与 RAID5 相比，数据恢复能力更强，但磁盘的读写能力下降<br> B、 当一块磁盘出现损坏后，RAID5 中的其他磁盘仍能正常工作，磁盘 I/O 性能不受影响<br> C、 RAID 是通过在多个磁盘上并发读写数据来提高存储系统的 I/O 性能<br> D、 RAID 可以看作是由两个或更多个磁盘组成的存储空间，其可用容量为各磁盘容量之和<br> 191 RAID 6 在 RAID 5 的基础上增强了磁盘的容错能力，可以允许 2 块磁盘出现故障，但<br> 需要的磁盘数量不得少于 4 块 A<br> A、 True<br> B、 False<br> 192 下列描述中，符合虚拟化封装特点的是（多选）ABD<br> A、 虚拟机的配置文件中会包含 CPU 类型、数量等信息<br> B、 虚拟机可以从一台物理主机迁移到另外一台物理主机<br> C、 一台物理主机上可以同时运行多台虚拟机<br> D、 如果一个虚拟机有多个硬盘，每个硬盘都会产生一个对应的磁盘文件<br> 193 在华为 FusionCompute 中，为虚拟机安装的 Tools 与虚拟机使用的操作系统类型和版本<br> 无关 B<br> A、 True<br> B、 False<br> 194 为 FusionCompute 中，以下哪个选项不属于 CPU 资源 QoS 参数？ D<br> A、 CPU 资源份额<br> B、 CPU 资源限制<br> C、 CPU 资源预留<br> D、 CPU 资源复用<br> 195 关于开启 NUMA 功能的主要目的，描述正确的是（）A<br> A、 最优化虚拟机的内存访问性能<br> B、 最大化物理主机 CPU 的计算能力<br> C、 最大化物理机内存的复用率<br> D、 最大化虚拟机的 vCPU 的计算能力<br> 196 为 FusionSphere 中，磁盘精简配置能够实现的功能是（多选）ABCD<br> A、 虚拟存储精简配置与操作系统、硬件完全无关，因此只要使用虚拟镜像管理系统，就能<br> 实现磁盘精简配置<br> B、 当前不支持 NTFS 格式的虚拟机磁盘回收<br> C、 提供虚拟磁盘空间监控和回收功能<br> D、 提供数据存储容量预警，可以设置阈值，当存储容量超过阈值时产生警告<br> 197 FusionCompute 中，为多台主机添加共享存储时，下列操作正确的是（多选）ABCD<br> A、在关联存储设备时需勾选所有主机<br> B、在添加数据存储时勾选对应的主机<br> C、当共享存储类型为 IP SAN 时，确保主机的存储网络和存储的业务接口相通<br> D、在初始化存储资源时需勾选所有主机<br> 198 NUMA 的描述中不正确的是（）B<br> A、 Guest NUMA 就是通过向虚拟机呈现 NUMA 结构，使 Guest OS 及其内部应用识别<br> NUMA 结构，以达到提升应用性能的目的<br> B、 NUMA 技术使得 CPU 访问同 Node 中内存速度和访问其他 Node 中内存速度相近<br> C、 Host NUMA 主要提供 CPU 负载均衡机制，解决 CPU 资源分配不平衡引起的 VM 性能<br> 瓶颈问题<br> D、 Host NUMA 保证 VM 访问本地物理内存，减少了内存访问延迟，可以提升 VM 性能<br> 199 为 FusionCompute 中，以下关于模板格式描述不正确的是（）C<br> A、.ovf 是虚拟机的描述文件，.vhd 是虚拟机的磁盘文件<br> B、虚拟机模板格式分为为 ova 和 ovf 两种<br> C、ovf 格式的模板只包含一个 ovf 文件和一个 vhd 文件<br> D、格式的模板导出后只包含一个文件<br> 200 为 FusionCompute 中，发现一台 Windows 虚拟机的 IP 地址为 0.0.0.0，有可能的原因是<br> （）D<br> A、 该虚拟机的 IP 地址为手动设置<br> B、 该虚拟机的 IP 地址被手动设置为 0.0.0.0<br> C、 该虚拟机的 IP 地址为 DHCP 分配<br> D、 该虚拟机未安装 Tools<br> 201 为 FusionCompute 中，关于裸设备硬件描述不正确的是（）B<br> A、 使用裸设备映射的磁盘性能最好<br> B、 操作系统建议安装在使用了裸设备映射功能的磁盘上<br> C、 一个使用了裸设备映射的数据存储智能对应 SAN 存储上的一个 LUN<br> D、 一个使用了裸设备映射的数据存储只能对应一个磁盘<br> 202 为 FusionCompute 中，每台虚拟机的虚拟网卡连接在虚拟交换机的端口上，为了方便用<br> 户同时对多个端口进行配置和管理，将具有相同网络属性的端口划分到同一个端口组下 A<br> A、 True<br> B、 False<br> 203 用中的内存交换是指将内存虚拟或外部存储给虚拟机使用，将虚拟机上暂时不用的数据<br> 存放到外部存储上，当系统需要使用这些数据时，再与预留在内存上的数据进行交换 A<br> A、 True<br> B、 False<br> 204 为 FusionCompute 中，以下关于存储相关概念描述不正确的是（）C<br> A、 一台物理存储设备可以作为存储资源<br> B、 存储设备对应的物理存储中的逻辑单元，例如 LUN<br> C、 数据存储可以是 IP SAN、FC SAN、NAS 等<br> D、 VHD 是虚拟机磁盘文件格式<br> 205 为 FusionCompute 中，可以为 CNA 主机创建快照。B<br> A、 True<br> B、 False<br> 206 usionCompute 中执行虚拟机更改主机热迁移操作，以下描述不属于其限制条件的是（）<br> D<br> A、 虚拟机的状态必须为“运行中”<br> B、 目的主机不能处于维护模式<br> C、 不能挂载“共享”类型的磁盘<br> D、 虚拟机不能使用“裸设备”类型的数据存储<br> 207 usionCompute 中，管理员将 CNA 主机的两个网卡通过主备模式绑定，绑定后传输速率<br> 等于两个网口的传输速率之和。B<br> A、 True<br> B、 False</li>
<li>关于云计算的广泛网络接入特性描述正确的是（）。【多选】ABCD<br> A. 通过网络，用户可以通过不同终端使用自购的云计算资源<br> B. 通过网络，用户可以在任意时间段使用自购的云计算资源<br> C. 通过网络，用户可以随时查看自购的云计算资源状态<br> D. 通过网络，用户可以在不同地点使用自购的云计算资源</li>
<li>当物理主机上的一台虚拟机发生了故障，不会影响该物理主机上的其他虚拟机，这属于<br> 虚拟化技术的哪个特点？A<br> A. 隔离<br> B. 分区<br> C. 独立<br> D. 封装</li>
<li>虚拟化适用于以下哪些场景？【多选】ABD<br> A. 某公司共有十个业务系统，承载这些业务的主机资源利用率不足 20%<br> B. 某科研机关使用定制化操作系统来保证科研成果的机密性<br> C. 某企业需要高负荷、密集型计算环境<br> D. 某单位员工日常使用办公桌面应用高度相似</li>
<li>以下关于 Virt-manager 描述正确的是（）。【多选】BD<br> A. Virt-manager 是一款 KVM 虚拟机管理命令集<br> B. Virt-manager 是一款开源的 KVM 虚拟机管理工具<br> C. Virt-manager 是一款商用的 KVM 虚拟机管理工具<br> D. Virt-manager 是一款 KVM 虚拟机图形化管理工具</li>
<li>在 NAS 环境中，多台主机同时对一个文件进行写操作会带来数据一致性问题。A<br> A. True<br> B. False</li>
<li>如果虚拟机 A 和虚拟机 B 运行在不同的物理服务器上，在通信的过程中一定会用到的<br> 物理设备是哪个？ABCD<br> A. 虚拟网卡<br> B. 虚拟交换机<br> C. 物理交换机<br> D. 物理网卡</li>
<li>一个虚拟机可以同时有多个虚拟网卡，对应不同的虚拟交换机 A<br> A. True<br> B. False</li>
<li>在华为 FusionCompute 中，以下关于模板格式描述不正确的是（）。A<br> A. Ovf 格式的模板中只包含一个 ovf 文件和一个 vhd 文件<br> B. Ova 格式的模板导出后只包含一个文件<br> C. 虚拟机模板格式分为 ova 和 ovf 两种<br> D. .ovf 是虚拟机的描述文件，.vhd 是虚拟机的磁盘文件</li>
<li>以下创建虚拟机模板方式不正确的是（）。D<br> A. 模板克隆为模板<br> B. 虚拟机克隆为模板<br> C. 虚拟机转为模板<br> D. 快照转为模板</li>
<li>虚拟机热迁移是指在虚拟机关机的状态下，将同一个集群中的虚拟机从一台物理服务器<br> 移动至另一台物理服务器。B<br> A. True<br> B. False</li>
<li>在华为 FusionCompute 中，以下关于虚拟机快照恢复描述不正确的是（）。C<br> A. 使用虚拟机已有的快照可以将虚拟机的数据恢复至快照创建时刻的状态<br> B. 若虚拟机在创建快照后，删除了虚拟机网卡所在端口组，则在使用该快照还原虚拟机时，<br> 被删端口组也会恢复<br> C. 若虚拟机的某个磁盘模式为“独立-持久”或“独立-非持久”，则使用快照还原虚拟机时，<br> 不对该磁盘的数据进行恢复<br> D. 虚拟机可以存在多个快照</li>
<li>在 FusionCompute 中，可以给虚拟机设置的 QoS 参数不包括：A<br> A. GPU<br> B. 磁盘 IOPS<br> C. 内存<br> D. 网络<br> E. CPU</li>
<li>利用模板快速部署虚拟机时，生成的虚拟机配置信息与模板保持一致 A<br> A. True<br> B. False</li>
<li>声音识别、图像识别、情感陪护机器人都是人工智能的应用 A<br> A. True<br> B. False</li>
<li>以下关于大数据与云计算的描述的是（）。D<br> A. 云计算是指无法再一定时间范围内用常规软件工具进行捕捉、管理和处理的数据集合<br> B. 大数据是一种按量付费的模式，这种模式提供可用的、便携的、按需的网络访问<br> C. 云计算无法作用大数据处理的底层计算资源<br> D. 大数据可以作用云计算的一类服务，供用户按需选择</li>
<li>在华为 FusionCompute 中，用户使用 VNC 登录虚拟机后发现不能正常操作，存在卡死<br> 的现象（如无法打开文件等），造成此故障最优可能的原因是（）。C<br> A. 虚拟机损坏<br> B. 业务链路不稳定<br> C. 管理链路不稳定<br> D. 存储链路不稳定</li>
<li>在华为 FusionCompute 中，关于“角色”描述正确的是（）。A<br> A. 如果一个“用户”拥有多个“角色”，其拥有的“操作权限”取决于优先级最高的“角<br> 色”<br> B. 一个“角色”可拥有一个或多个不同的“操作系统”<br> C. “角色”的“操作权限”不可以被修改<br> D. 一个“用户”只能拥有一个“角色”</li>
<li>在华为 FusionCompute 中，虚拟机绑定 USB 设备后，哪些功能将受到影响？【多选】<br> CD<br> A. 虚拟机资源扩容<br> B. 虚拟机重启<br> C. 虚拟机热迁移<br> D. 集群调度策略</li>
<li>在华为 FusionCompute 中为虚拟机绑定磁盘时，若要实现以下要求，虚拟机创建快照时，<br> 不对该磁盘进行快照，使用快照恢复虚拟机时，也不对该磁盘进行还原，同时要求所有数据<br> 永久写入该磁盘，则应该选择哪种模式的磁盘?B<br> A. 独立-非持久<br> B. 独立-持久<br> C. 独立<br> D. 从属</li>
<li>在华为 FusionCompute 中，虚拟机所使用的内存资源和 CPU 资源只能由同一集群提供，<br> 因此，虚拟机实际可使用计算资源的最大限度不能超过该集群内所有主机可提供资源的总和。<br> B<br> A. True<br> B. False</li>
<li>在华为 FusionCompute 中，若绑定网口中只有一个物理网口，则该物理网口不能被直接<br> 移除 A<br> A. True<br> B. False</li>
<li>在华为 FusionCompute 中，以下关于安全组规则的描述不正确的是（）。D<br> A. 一个虚拟机有多块网卡时，可以为每一块网卡配置安全组<br> B. 在创建安全组且添加规则后，虚拟机才能与外界互通<br> C. 位于同一个安全组的所有虚拟机网卡都将使用该安全组规则进行访问控制<br> D. 一个安全组的本质就是规则的集合</li>
<li>在华为 FusionCompute 中，如果 Windows 虚拟机发生蓝屏，系统可以执行哪些操作？<br> 【多选】ACD<br> A. HA 虚拟机<br> B. 使用快照恢复虚拟机<br> C. 重启虚拟机<br> D. 不处理</li>
<li>在华为 FusionCompute 中，关于登录虚拟机方式描述正确的是（）。【多选】AD<br> A. 虚拟机没有 IP 地址，管理员也可以通过 VNC 登录，所以 VNC 摆脱了对网络的依赖<br> B. 如果虚拟机的操作系统为 windows，管理员可以通过远程桌面登录虚拟机<br> C. 管理员可以通过 VNC 登录安装了任何操作系统的虚拟机<br> D. 如果虚拟机的操作系统为 Linux，管理员可以通过远程桌面登录虚拟机</li>
<li>在华为 FusionCompute 中，要使虚拟机可以再不同 CPU 型号的 CNA 主机间迁移，需开<br> 启的功能是（）。B<br> A. 集群 GuestNUMA 策略<br> B. 集群 IMC 策略<br> C. 集群 I/O 环适配<br> D. 集群 HANA 优化</li>
<li>在华为 FusionCompute 中，以下关于虚拟机存储热迁移描述不正确的是（）。B<br> A. 存储热迁移可以在不同的存储设备之间进行<br> B. 存储热迁移可以在不同的虚拟磁盘之间进行<br> C. 存储热迁移可以在不同的存储资源之间进行<br> D. 存储热迁移可以在不同的数据存储之间进行</li>
<li>在华为 FusionCompute 中，集群的资源由主机及其相关联的存储和网络资源构成 A<br> A. True<br> B. False<br> 235、云计算的可量化服务指的是按照使用时间和使用量对客户收费。A<br> A、TRUE<br> B、FALSE<br> 236、云计算是互联网和计算技术发展的产物，因此云计算一定离不开网络（）A<br> A、TRUE<br> B、FALSE<br> 237、在华为 FusionCompute 中，创建了一个 Linux 操作系统的虚拟机，此场景中，host OS<br> 运行在（）B<br> A、VNA<br> B、CNA<br> C、VRM<br> D、Linux 虚拟机<br> 238、KVM 虚拟化架构中包括 KVM 模块、QEMU 和 Libvirt，以下关于这些模块描述不正确的<br> 是（）C<br> A、KVM 模块主要负责 Vcpu 的创建和虚拟内存的分配<br> B、KVM+QEMU 可以构成一套虚拟化解决方案<br> C、Libvirt+QEMU 可以构成一套虚拟化解决方案<br> D、QEMU 主要负责 I/O 操作模拟<br> 239、虚拟机一般都有对应的配置文件，记录额该虚拟机的规格、名称等信息。A<br> A、TRUE<br> B、FALSE<br> 240、下列描述不正确的是（）A<br> A、每一个文件系统块对应物理磁盘上的一个非连续区域<br> B、文件存储在文件系统上，并由文件系统映射到文件系统块上<br> C、文件系统块对应 LVM 的逻辑区域<br> D、逻辑区域通过 LVM 映射到磁盘的物理区域<br> 241、在华为 FusionCompute 中，VRM 使用的管理 VLAN ID 不可更改。B<br> A、TRUE<br> B、FALSE<br> 242.使用了 virtio 后，windows 虚拟机的网卡速率为 10Gbps A<br> A、TRUE<br> B、FALSE<br> 243.在华为 FusionCompute 中，内存复用功能是在哪里开启？D<br> A．主机<br> B．操作系统<br> C．虚拟机<br> D．集群</li>
<li>在华为 FusionCompute 中，当虚拟机处于“运行中”或“已停止”状态时，用户都可<br> 以增减虚拟机的 vCPU 数量 B<br> A、TRUE<br> B、FALSE</li>
<li>在华为 FusionCompute 中，DRS 会根据以下哪些因素进行虚拟机迁移？（多选）AD<br> A.内存<br> B.I/O<br> C.网络流量<br> D.CPU<br> 246.以下关于 CPU 资源和内存资源 Qos 描述不正确的是 D<br> A．内存资源 QOS 用于保证关键业务虚拟机能够得到足够的内存资源<br> B.CPU 份额和 CPU 预留只在各虚拟机竞争计算资源时才发挥作用<br> C.虚拟机的 CPU QoS 用于保证虚拟机的计算资源得到合理分配<br> D.只有开启内存复用开关后才能使用内存资源 QoS<br> 247.随着“互联网”的被重视已经大数据、云计算的兴起、相关技术更是如雨后春笋般进入<br> 大家的视野中，其中被广泛应用和重视的就是 Docker，下列关于 Docker 的说法不正确的是<br> B<br> A．Docker 可以打包应用的底层环境，保证各应用在进行迁移后仍然可以正常运行<br> B．Docker 需要在宿主机或者宿主机操作系统上创建虚拟层、虚拟操作系统等，然后再进行<br> 安装<br> C.Docker 与其他虚拟机技术的相比，Docker 的启动速度更快<br> D.Docker 利用容器来运行，容器是从 Image 创建的运行实例<br> 248.以下关于华为 FusionCompute 架构描述不正确的是（）D<br> A．CAN 为虚拟机提供了计算资源<br> B．VRM 可以运行在 CAN 上，也可以单独物理机部署<br> C．VRM 为管理员提供了管理 portal<br> D．CAN 可以管理集群网络、存储和计算资源<br> 249.华为 FusionCompute 支持批量添加啊主机，管理员按照系统提供的模板填写主机信息并<br> 一次性导入（）A<br> A、TRUE<br> B、FALSE<br> 250.华为 FusionCompute 支持的存储资源类型有（）（多选）ABCDE<br> A．FusionStorage<br> B．Advanced SAN<br> C．NAS<br> D．IP SAN<br> E．FC SAN<br> 251.使用统一按照攻击部署华为 FusionCompute 后，IT 会自动创建一个集群，管理员可以对<br> 该集群做哪些操作？（多选）BC<br> A．移动到指定集群文件夹<br> B．修改名称<br> C．增加描述信息<br> D．导出到本地<br> 252.用户购买的云服务中，包含了应用程序运行环境，但没有应用程序和相关数据。这种模<br> 式属于（）B<br> A、SaaS<br> B、PaaS<br> C、NaaS<br> D、IaaS<br> 253．以下选项中无法体现云计算按需自助服务特性的是（）D<br> A、工程师根据自己的需求在华为公有云购买了一台云服务器<br> B、工程师将自己购买的云服务器 CPU 从 2 个升级为 4 个<br> C、工程师将自己购买的云服务器的操作系统从 Linux 更改为 Windows<br> D、工程师在云服务器到期前一周收到了服务器提供商的通知短信<br> 254.一下哪种操作系统可以将磁盘格式化位 NTFS？B<br> A．Linux<br> B. Windows<br> C.uvp<br> D.Unix</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Linux配置与管理FTP服务</title>
    <url>/Linux%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AE%A1%E7%90%86FTP%E6%9C%8D%E5%8A%A1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>FTP用于在Internet上控制文件的双向传输。同时，它也是一个应用程序。基于不同的操作系统有不同的FTP应用程序，而所有这些应用程序都遵循同一种协议以传输文件。在FTP的使用中，用户经常遇到两个概念：“下载”和“上传”下载文件就是从远程主机复制文件到自己的电脑上💻；上传文件就是将自己电脑上💻的文件复制到远程计算机。</p>
<h1 id="任务一"><a href="#任务一" class="headerlink" title="任务一"></a>任务一</h1><p><code>配置企业文件下载服务器</code><br>某公司视频网站处于经营初期，为了提高公司的知名度，争取更多的用户资源，预把自己拥有的视频资源分享给互联网用户。具体要求如下<br><strong>(1)</strong>配置FTP匿名用户的主目录为/var/ftp/anon,下载带宽限制为100KB/S.<br><strong>(2)</strong>建立一个名为abc、口令为xyz的FTP账户，下载带宽限制为500KB/S.<br><strong>(3)</strong>设置FTP服务器，同时登录到FTP服务器的最大链接数为100；每个IP最大链接数为3；用户空闲时间超过限值为5分钟。<br><strong>(4)</strong>服务器IP地址为192.168.131.129<br>任务实施</p>
<h2 id="设置IP地址"><a href="#设置IP地址" class="headerlink" title="设置IP地址"></a>设置IP地址</h2><p>使用<code>setup</code>或者<code>vim /etc/sysconfig/network-scripts/ifcfg-eth0</code>来修改服务器的IP地址，然后使用<code>service network restart</code>重启网络服务。</p>
<h2 id="安装vsftpd文件"><a href="#安装vsftpd文件" class="headerlink" title="安装vsftpd文件"></a>安装vsftpd文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y vsftpd #安装vsftpd</span><br><span class="line">rpm -qa |grep vsftpd #查询安装信息</span><br></pre></td></tr></table></figure>



<h2 id="建立匿名用户主目录以及abc用户"><a href="#建立匿名用户主目录以及abc用户" class="headerlink" title="建立匿名用户主目录以及abc用户"></a>建立匿名用户主目录以及abc用户</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir &#x2F;var&#x2F;ftp&#x2F;anon</span><br><span class="line">useradd -s &#x2F;sbin&#x2F;nologin abc #建立用户不允许本地登录</span><br><span class="line">passwd abc</span><br></pre></td></tr></table></figure>

<p>|<br>| - | - |</p>
<h2 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h2><p>编辑配置文件前首先使用<code>cp -p /etc/vsftpd/vsftpd.conf /etc/vsftpd/vsftpd.conf.bak</code>命令备份配置文件,然后使用<code>vim /etc/vsftpd/vsftpd.conf</code>命令编辑vsftpd配置文件，主要修改的内容如下:<br><code>注意</code>有的是需要修改的,有的是需要添加的</p>
<p>anonymous_enable=yes<br>anon_root=/var/ftp/anon<br>anon_max_rate=100000<br>local_enable=yes<br>local_max_rate=500000<br>max_clinets=100<br>max_per_ip=3<br>connect_timeout=300</p>
<h2 id="配置vsftpd在系统中运行"><a href="#配置vsftpd在系统中运行" class="headerlink" title="配置vsftpd在系统中运行"></a>配置vsftpd在系统中运行</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chkconfig --levels 2335 vsftpd on #开机运行</span><br><span class="line">service vsftpd restart #重启服务</span><br></pre></td></tr></table></figure>

<p>|<br>| - | - |</p>
<h2 id="了解配置文件"><a href="#了解配置文件" class="headerlink" title="了解配置文件"></a>了解配置文件</h2><p>anonymous_enable=yes #允许匿名用户登录<br>local_enable=yes #用户本地用户登录<br>write_enable=yes #允许本地用户具有写的权限<br>local_umask=022<br>#设置本地用户的文件生成掩码为022，默认为077；文件写入格式<br>anon_mkdir_write_enable=yes #允许匿名用户具有写的权限<br>dirmessage_enable=yes #激活上传/下载日子，当远程用户更改时提示<br>ascii_download_enable=yes #允许用户用ASCII格式来上传/下载文件<br>ftp_banner=welcome to you! #用户登录时提示欢迎词<br>userlist_enable=yes<br>#用户列表是否启用,当用户加入到/etc/vsftpd/ftpusers文件时，用户将不能访问FTP服务</p>
<p>经过测试abc用户和匿名用户均可访问FTP服务器资源。</p>
<h1 id="任务二"><a href="#任务二" class="headerlink" title="任务二"></a>任务二</h1><p><code>配置企业内部文件FTP配额</code><br>背景某工厂制造加工企业，接到一笔较大的生产订单，需要多部分联合开发配合完成，部门之间需要交换公共文件，同时也需要部门之间有各自保密的文件。<br><strong>(1)</strong>新建一个分区，10GB空间，ext3文件系统，挂载到/ftp下，作为FTP服务器数据存放的地方。<br><strong>(2)</strong>四个部门：dep1、dep2、dep3、dep4，分别对应目录<code>/ftp/dep1,/ftp/dep2,/ftp/dep3,/ftp/dep4</code>.另外设定一个公共目录/ftp/public<br><strong>(3)</strong>五个用户:admin,user1,user2,user3,user4。user1,user2,user3,user4对应的部门分别是dep1,dep2,dep3,dep4,他们只能访问属于自己部门的目录和public目录。admin管理员用户可以访问服务器上的任意一个目录。<br><strong>(4)</strong>用户访问权限控制:user1,user2,user3,user4在所能访问的目录，具有上传文件、下载文件的功能，但是不具有删除文件、更改文件权限等功能。admin管理员对所有目录有文件上传、下载、删除、权限更改等功能。<br><strong>(5)</strong>对每个部门定制一个quota，设置该账户的文件配额为1000个，磁盘配额为2GB。<br><strong>(6)</strong>禁止匿名用户访问</p>
<h2 id="磁盘分区与挂载"><a href="#磁盘分区与挂载" class="headerlink" title="磁盘分区与挂载"></a>磁盘分区与挂载</h2><p>增加一块硬盘，然后使用下面命令进行分区，并把分区挂载情况写入/etc/fstab</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fdisk &#x2F;dev&#x2F;sdb</span><br><span class="line">mkfs.ext3 &#x2F;dev&#x2F;sdb1</span><br><span class="line">mkdir &#x2F;ftp</span><br><span class="line">mount &#x2F;dev&#x2F;sdb1 &#x2F;ftp -o usrquota,grpquota #挂载分区</span><br></pre></td></tr></table></figure>

<p>|<br>| - | - |</p>
<p>使用<code>vim /etc/fstab</code>命令设置开机自动挂载,在文件最后增加如下内容</p>
<p>|</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<p>|</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;dev&#x2F;sdb1 &#x2F;ftp ext3 defaults,usrquota,grpquota 0 0</span><br></pre></td></tr></table></figure>

<p>|<br>| - | - |</p>
<h2 id="建立用户与用户组并设置权限"><a href="#建立用户与用户组并设置权限" class="headerlink" title="建立用户与用户组并设置权限"></a>建立用户与用户组并设置权限</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groupadd dep1</span><br><span class="line">groupadd dep2</span><br><span class="line">groupadd dep3</span><br><span class="line">groupadd dep4</span><br><span class="line">groupadd market</span><br><span class="line">useradd -G dep1,market user1</span><br><span class="line">useradd -G dep2,market user2</span><br><span class="line">useradd -G dep3,market user3</span><br><span class="line">useradd -G dep4,market user4</span><br><span class="line">useradd -G dep1,dep2,dep3,dep4,market admin</span><br><span class="line">passwd user1</span><br><span class="line">passwd user2</span><br><span class="line">passwd user3</span><br><span class="line">passwd user4</span><br><span class="line">passwd admin</span><br><span class="line">mkdir &#x2F;ftp&#x2F;dep1</span><br><span class="line">mkdir &#x2F;ftp&#x2F;dep2</span><br><span class="line">mkdir &#x2F;ftp&#x2F;dep3</span><br><span class="line">mkdir &#x2F;ftp&#x2F;dep4</span><br><span class="line">mkdir &#x2F;ftp&#x2F;public</span><br><span class="line">chown user1:dep1 &#x2F;ftp&#x2F;dep1</span><br><span class="line">chown user2:dep2 &#x2F;ftp&#x2F;dep2</span><br><span class="line">chown user3:dep3 &#x2F;ftp&#x2F;dep3</span><br><span class="line">chown user4:dep4 &#x2F;ftp&#x2F;dep4</span><br><span class="line">chown admin:market &#x2F;ftp&#x2F;public</span><br><span class="line">chmod 770 &#x2F;ftp&#x2F;dep1</span><br><span class="line">chmod 770 &#x2F;ftp&#x2F;dep2</span><br><span class="line">chmod 770 &#x2F;ftp&#x2F;dep3</span><br><span class="line">chmod 770 &#x2F;ftp&#x2F;dep4</span><br><span class="line">chmod 770 &#x2F;ftp&#x2F;public</span><br></pre></td></tr></table></figure>

<p>|<br>| - | - |</p>
<p>最终新建的用户、用户组、文件夹以及权限如下图所示<br><a href="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/ftp.png" target="_blank" rel="noopener"><img src="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/ftp.png" alt=""></a></p>
<h2 id="创建quota，配置磁盘配额"><a href="#创建quota，配置磁盘配额" class="headerlink" title="创建quota，配置磁盘配额"></a>创建quota，配置磁盘配额</h2><p>使用<code>setenforce 0</code>关闭SELinux</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">quotacheck -cuvg &#x2F;dev&#x2F;sdb1</span><br><span class="line">quotaon -a</span><br><span class="line">edquota -g dep1</span><br></pre></td></tr></table></figure>

<p>|<br>| - | - |</p>
<p><a href="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/edquota.png" target="_blank" rel="noopener"><img src="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/edquota.png" alt=""></a><br>使用<code>edquota -p dep1 -g dep2 dep3 dep4</code>命令把quota属性设置套用到其余用户组。</p>
<h2 id="编辑配置文件-1"><a href="#编辑配置文件-1" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h2><p>使用<code>vim /etc/vsftpd/vsftpd.conf</code>修改或添加如下几处内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">anonymous_enable&#x3D;NO</span><br><span class="line">local_root&#x3D;&#x2F;ftp</span><br><span class="line">user_config_dir&#x3D;&#x2F;etc&#x2F;vsftpd&#x2F;ftp_config_dir</span><br><span class="line">chroot_list_file&#x3D;&#x2F;etc&#x2F;vsftpd&#x2F;chroot_list</span><br></pre></td></tr></table></figure>

<p>|<br>| - | - |</p>
<h2 id="建立用户独立文件"><a href="#建立用户独立文件" class="headerlink" title="建立用户独立文件"></a>建立用户独立文件</h2><p>使用<code>mkdir /etc/vsftpd/ftp_config_dir</code>命令建立每个用户独立文件存放的目录。使用<code>vim /etc/vsftpd/ftp_config_dir/user1</code>命令建立用户配置文件，内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmds_allowed&#x3D;ABOR,ACCT,APPE,CWD,CDUP,HELP,LIST,MODE,MDTM,NOOP,NLST,PASS,PASV,PORT,PWD,QUIT,REIN,RETR,SITE,SIZE,STOR,STAT,STOU,STRU,SYST,TYPE,USER</span><br></pre></td></tr></table></figure>

<p>|<br>| - | - |</p>
<p>使用命令<code>cd /etc/vsftpd/ftp_config_dir</code>进入到目录下，然后使用<code>cp user1 user2</code>,<code>cp user1 user3</code>,<code>cp user1 user4</code>复制配置文件</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>使用windows作为客户端来进行验证，在资源管理器的地址栏或者，浏览器的地址栏中输入<code>ftp://192.168.131.129</code>可以看到以下内容<br><a href="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/2.png" target="_blank" rel="noopener"><img src="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/2.png" alt=""></a>这里显示让我们输入账户以及密码才可以登陆。无法使用匿名用户访问<br>或者当使用cmd命令行输入<code>ftp 192.168.131.129</code>尝试用匿名用户登陆显示登陆失败。<br><a href="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/3.png" target="_blank" rel="noopener"><img src="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/3.png" alt=""></a><br>这是因为设置了禁止匿名用户访问所以才会这样，因此应该使用之前建立的用户登陆。为了区分登陆分别在/home/user1<del>4的文件夹下创建user1</del>user4文件夹。并且在/ftp/dep1<del>4目录下创建名为1</del>4的文件。<br>当各个部门用户登陆成功后分别会显示一个对应自己用户名字的文件夹<a href="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/1.png" target="_blank" rel="noopener"><img src="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/1.png" alt=""></a>当管理员admin用户登陆成功后显示如下所示内容。<a href="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/admin.png" target="_blank" rel="noopener"><img src="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/admin.png" alt=""></a><br>下面测试使用cmd命令行的方式来进行登陆ftp服务器进行文件的上传以及下载。</p>
<h3 id="user1-4"><a href="#user1-4" class="headerlink" title="user1~4"></a>user1~4</h3><p><a href="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/user1.png" target="_blank" rel="noopener"><img src="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/user1.png" alt=""></a><br>因为操作都一样所以就截了一张图<br>查看windows客户端下载的文件<br><a href="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/windows.png" target="_blank" rel="noopener"><img src="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/windows.png" alt=""></a><br><code>1~4</code>和<code>public</code>均为从服务器上下载下来的文件，<br>查看Linux服务器被上传的文件<br><a href="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/Linux.png" target="_blank" rel="noopener"><img src="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/Linux.png" alt=""></a><br>测试客户端是否能删除文件<br><a href="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/delete.png" target="_blank" rel="noopener"><img src="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/delete.png" alt=""></a>如图显示是无法删除的，到此为止测试各个部门的上传下载以及删除权限已经测试完毕。<br>测试用户的配额是否配置成功❓<br>可以搞一个这里搞一个centos的系统镜像来测试，大小为4.16GB.最终发现是无法放入的</p>
<h3 id="admin"><a href="#admin" class="headerlink" title="admin"></a>admin</h3><p><a href="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/admin1.png" target="_blank" rel="noopener"><img src="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/admin1.png" alt=""></a><br>这里管理员用户对于四个部门的目录均具有上传、下载、删除的权限，理所当然对于公共目录public也同样具有最高的权限。</p>
<h1 id="任务三"><a href="#任务三" class="headerlink" title="任务三"></a>任务三</h1><p><code>配置vsftp虚拟用户访问</code></p>
<h2 id="安装相关文件"><a href="#安装相关文件" class="headerlink" title="安装相关文件"></a>安装相关文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install pam* -y</span><br><span class="line">yum install db4* -y</span><br></pre></td></tr></table></figure>

<p>|<br>| - | - |</p>
<h2 id="建立用户"><a href="#建立用户" class="headerlink" title="建立用户"></a>建立用户</h2><p>建vsftpd服务宿主用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd vsftpdadmin -s &#x2F;sbin&#x2F;nologin</span><br></pre></td></tr></table></figure>

<p>|<br>| - | - |</p>
<p>建立vsftpd服务的宿主用户用来替换root用户，并不需要登录所以指定不可用shell。</p>
<p>建立FTP虚拟宿主账户</p>
<p>|</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd ftpuser -s &#x2F;sbin&#x2F;nologin</span><br></pre></td></tr></table></figure>

<p>|<br>| - | - |</p>
<h2 id="配置vsftpd-conf文件"><a href="#配置vsftpd-conf文件" class="headerlink" title="配置vsftpd.conf文件"></a>配置vsftpd.conf文件</h2><p>使用vim命令进行编辑，编辑前记得备份使用<code>cp /etc/vsftpd/vsftpd.conf /etc/vsftpd/vsftpd.conf.bak</code>来备份，vsftpd主配置文件，主要修改下面部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">anonymous_enable&#x3D;NO </span><br><span class="line">chroot_list_enable&#x3D;YES </span><br><span class="line">chroot_list_file&#x3D;&#x2F;etc&#x2F;vsftpd&#x2F;chroot_list</span><br></pre></td></tr></table></figure>

<p>|<br>| - | - |</p>
<p><code>anonymous_enable=NO</code>不允许匿名用户访问，默认为YES,<code>chroot_list_enable=YES</code>不允许FTP用户离开自己的主目录,<code>chroot_list_file=/etc/vsftpd/chroot_list</code>搭配上面一行使用的，这条是锁定用户只能登录家目录的位置，如果不开启用户登录时就会报500 OOPS的错误。</p>
<p>注意/etc/vsftpd/chroot_list本身是不存在的，需要自己手动创建。往里面输入账户一行一个</p>
<p>文件内具体代码的意义&gt; local_enable=YES #允许本地用户访问</p>
<blockquote>
<p>write_enable=YES #允许写入<br>local_umask=022 #上传后文件的掩码<br>dirmessage_enable=YES #开启目录标语<br>xferlog_enable=YES #开启日志<br>connect_from_port_20=YES #设定连接端口<br>xferlog_std_format=YES #设定vsftpd服务日子保存路径<br>idle_session_timeout=600 #会话超时时间<br>async_abor_enable=YES #支持异步传输功能<br>ascii_upload_enable=YES #支持ASCII模式上传功能<br>ascii_download_enable=YES #支持ASCII模式的下载功能<br>ftpd_banner=Welcome to blah FTP service. #FTP登录欢迎语<br>chroot_local_user=YES #禁止本地用户登录自己的FTP主目录<br>pam_service_name=vsftpd #设定pam服务下vsftpd的验证配置文件名<br>userlist_enable=YES #拒绝登录用户名单</p>
</blockquote>
<p>userlist_deny=NO</p>
<p>TCP_wrappers=YES #限制主机对VSFTP服务器的访问<br>tcp_wrapper=YES<br>chroot_local_user=NO<br>guest_enable=YES #设定启用虚拟用户功能<br>guest_username=ftpuser #指定虚拟用户的宿主用户<br>virtual_use_local_privs=YES #设定虚拟用户的权限符合其宿主用户<br>user_config_dir=/etc/vsftpd/vconf #设定虚拟用户个人vsftp的配置文件存放路径</p>
<h2 id="建立日志文件并修改权限"><a href="#建立日志文件并修改权限" class="headerlink" title="建立日志文件并修改权限"></a>建立日志文件并修改权限</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch &#x2F;var&#x2F;log&#x2F;vsftpd.log</span><br><span class="line">chown vsftpdadmin.vsftpdadmin &#x2F;var&#x2F;log&#x2F;vsftpd.log</span><br></pre></td></tr></table></figure>

<p>|<br>| - | - |</p>
<h2 id="建立虚拟用户文件"><a href="#建立虚拟用户文件" class="headerlink" title="建立虚拟用户文件"></a>建立虚拟用户文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir &#x2F;etc&#x2F;vsftpd&#x2F;vconf</span><br><span class="line">touch &#x2F;etc&#x2F;vsftpd&#x2F;vconf&#x2F;vir_user</span><br></pre></td></tr></table></figure>

<p>|<br>| - | - |</p>
<h2 id="建立虚拟用户"><a href="#建立虚拟用户" class="headerlink" title="建立虚拟用户"></a>建立虚拟用户</h2><p>使用<code>vim /etc/vstfpd/vconf/vir_user</code>命令来编辑虚拟用户文件，添加如下内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">virtualuser #账号</span><br><span class="line">123456      #密码</span><br></pre></td></tr></table></figure>

<p>|<br>| - | - |</p>
<p>使用<code>vim /etc/vsftpd/chroot_list</code>命令来锁定用户目录的配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">virtualuser</span><br><span class="line">virtual2</span><br></pre></td></tr></table></figure>

<p>|<br>| - | - |</p>
<h2 id="生成数据库"><a href="#生成数据库" class="headerlink" title="生成数据库"></a>生成数据库</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db_load -T -t hash -f &#x2F;etc&#x2F;vsftpd&#x2F;vconf&#x2F;vir_user &#x2F;etc&#x2F;vsftpd&#x2F;vconf&#x2F;vir_user.db</span><br></pre></td></tr></table></figure>

<p>|<br>| - | - |</p>
<h2 id="设置数据文件的访问权限"><a href="#设置数据文件的访问权限" class="headerlink" title="设置数据文件的访问权限"></a>设置数据文件的访问权限</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 600 &#x2F;etc&#x2F;vsftpd&#x2F;vconf&#x2F;vir_user</span><br><span class="line">chmod 600 &#x2F;etc&#x2F;vsftpd&#x2F;vconf&#x2F;vir_user.db</span><br></pre></td></tr></table></figure>

<p>|<br>| - | - |</p>
<h2 id="修改-etc-pam-d-vsftpd内容"><a href="#修改-etc-pam-d-vsftpd内容" class="headerlink" title="修改/etc/pam.d/vsftpd内容"></a>修改/etc/pam.d/vsftpd内容</h2><p>使用<code>vim /etc/pam.d/vsftpd</code>命令编辑文件，内容如下所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#%PAM-1.0</span><br><span class="line">auth sufficient pam_userdb.so db&#x3D;&#x2F;etc&#x2F;vsftpd&#x2F;vconf&#x2F;vir_user</span><br><span class="line">account sufficient pam_userdb.so db&#x3D;&#x2F;etc&#x2F;vsftpd&#x2F;vconf&#x2F;vir_user</span><br></pre></td></tr></table></figure>

<p>|<br>| - | - |</p>
<p><strong>备注</strong>：auth是对于用户的用户名口令进行验证，account是对于用户的账户有哪些权限、哪些限制进行验证，sufficent表示充分条件，pam_userdb.so表示该条审核将调用库函数pam_userdb.so进行。db=/etc/vsftpd/vconf/vir_user指定验证库函数将到这个指定的数据库中调用数据进行验证。</p>
<h2 id="创建用户的配置文件"><a href="#创建用户的配置文件" class="headerlink" title="创建用户的配置文件"></a>创建用户的配置文件</h2><p>使用<code>vim /etc/vsftpd/vconf/virtualuser</code>创建用户配置文件。输入如下所示内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_root&#x3D;&#x2F;home&#x2F;share</span><br><span class="line">anonymous_enable&#x3D;NO</span><br><span class="line">write_enable&#x3D;YES</span><br><span class="line">local_umask&#x3D;0333</span><br><span class="line">anon_umask&#x3D;0777</span><br><span class="line">file_open_mode&#x3D;0777</span><br><span class="line">anon_upload_enable&#x3D;YES</span><br><span class="line">anon_mkdir_write_enable&#x3D;YES</span><br><span class="line">anon_other_write_enable&#x3D;YES</span><br><span class="line">cmds_allowed&#x3D;STOR,FEAT,REST,ABOR,CWD,LIST,MDTM,NLST,PASS,PASV,PORT,PWD,QUIT,RMD,RNFR,SIZE,TYPE,USER,ACCT,APPE,CDUP,HELP,MODE,NOOP,REIN,STAT,STOU,STRU,SYST,RETR</span><br><span class="line">idle_session_timeout&#x3D;600</span><br><span class="line">data_connection_timeout&#x3D;120</span><br><span class="line">max_clients&#x3D;10</span><br><span class="line">max_per_ip&#x3D;5</span><br><span class="line">local_max_rate&#x3D;1048576</span><br></pre></td></tr></table></figure>

<p>|<br>| - | - |</p>
<h2 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h2><p>使用<code>service vsftpd restart</code>或者<code>/etc/init.d/vsftpd restart</code></p>
<h2 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h2><h1 id="任务四"><a href="#任务四" class="headerlink" title="任务四"></a>任务四</h1><p><code>部署专家级FTP服务器</code></p>
<h2 id="配置默认的vsftpd服务器"><a href="#配置默认的vsftpd服务器" class="headerlink" title="配置默认的vsftpd服务器"></a>配置默认的vsftpd服务器</h2><ol>
<li><p>挂载系统光盘</p>
<blockquote>
<p>mount /dev/cdrom /mnt</p>
</blockquote>
</li>
<li><p>安装vsftpd<br>在此，使用rpm的安装方式来安装，安装包放在系统光盘的Packages目录中</p>
<blockquote>
<p>rpm -ivh /mnt/Packages/vsftpd-2.2.2-11.el6_4.1.x86_64.rpm</p>
</blockquote>
</li>
<li><p>查看vsftpd配置文件</p>
<blockquote>
<p>grep -v “#” /etc/vsftpd/vsftpd.conf</p>
</blockquote>
<p><a href="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/grep.png" target="_blank" rel="noopener"><img src="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/grep.png" alt=""></a></p>
</li>
<li><p>在系统中允许</p>
<blockquote>
<p>chkconfig –levels 235 vsftpd on<br>service vsftpd restart</p>
</blockquote>
</li>
</ol>
<h2 id="配置匿名用户访问和下载权限"><a href="#配置匿名用户访问和下载权限" class="headerlink" title="配置匿名用户访问和下载权限"></a>配置匿名用户访问和下载权限</h2><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><blockquote>
<p>service vsftpd start</p>
</blockquote>
<p>测试前关闭selinux和防火墙</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service iptables stop</span><br><span class="line">setenforce 0</span><br></pre></td></tr></table></figure>

<p>|<br>| - | - |</p>
<p>在客户机中测试用文件夹方式访问<a href="ftp://192.168.131.129/">ftp://192.168.131.129</a>.</p>
<p><a href="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/pub.png" target="_blank" rel="noopener"><img src="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/pub.png" alt=""></a></p>
<h3 id="测试匿名用户的上传和下载权限"><a href="#测试匿名用户的上传和下载权限" class="headerlink" title="测试匿名用户的上传和下载权限"></a>测试匿名用户的上传和下载权限</h3><p><code>注意:</code>使用匿名账户ftp登录(无密)，查看现在所有的工作目录为/，这个/并不是服务器的根目录，而是匿名用户自己的家目录，使用ls命令发现里面有一个pub文件。</p>
<p><a href="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/pub1.png" target="_blank" rel="noopener"><img src="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/pub1.png" alt=""></a></p>
<p>匿名用户的家目录就是服务器上的/var/ftp目录。在服务器上建立一个可供下载的文件。使用<code>echo &quot;hello world&quot;&gt;/var/ftp/1.txt</code>新建一个内容为hello world的文件。回到客户机上使用<code>get 1.txt</code>命令下载文件。</p>
<p><a href="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/get.png" target="_blank" rel="noopener"><img src="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/get.png" alt=""></a>可以在客户机上查看到一个1.txt的文件。在客户机上把下载的文件重命名一下，来测试上传。<a href="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/put.png" target="_blank" rel="noopener"><img src="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/put.png" alt=""></a>上传时被拒绝，因为匿名用户默认只能下载而不能上传。测试系统的用户的上传权限，这里可以使用<code>useradd upload</code>新建一个upload用户，使用<code>passwd upload</code>来设置用户的密码。再次用客户机进行测试，用upload登录并上传11.txt文件，文件上传成功。<a href="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/put1.png" target="_blank" rel="noopener"><img src="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/put1.png" alt=""></a>使用<code>ls -l /home/upload</code>命令查看上传文件的权限为644(因为配置文件中local_umask=022)</p>
<h3 id="配置匿名用户拥有完全权限"><a href="#配置匿名用户拥有完全权限" class="headerlink" title="配置匿名用户拥有完全权限"></a>配置匿名用户拥有完全权限</h3><p>1.修改配置文件</p>
<p>可以在配置文件中加入<code>anon_mkdir_write_enable=YES</code>和<code>anon_upload_enable=YES</code>使匿名用户具有上传删除的权限。</p>
<p>注意当不知道如何配置要添加或者修改哪些选项时。可以使用man来找到答案<code>man vsftpd.conf</code>,查找与anon相关内容，找到anon_other_write_enable它的默认值是NO,所以设置为YES就可以允许上传、创建目录、并且删除、重命名等操作。</p>
<p><a href="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/a.png" target="_blank" rel="noopener"><img src="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/a.png" alt=""></a></p>
<p>2.效果验证</p>
<p>使用<code>service vsftpd reload</code>命令重新加载配置，然后在客户机上再次用匿名用户进行测试。</p>
<p><a href="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/b.png" target="_blank" rel="noopener"><img src="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/b.png" alt=""></a></p>
<p>发现还是无法上传和删除文件，回到服务器后查看ftp目录的权限后发现它没有写的权限，所以是无法上传和删除的。</p>
<p>3.修改权限</p>
<p>选择暴力方法使用<code>chmod 777 /var/ftp</code>将权限设为最大，然后回到客户机登录发现直接报错了。因为我们把/ftp这个目录权限设为最大，这样匿名用户就可以为所欲为了。为了避免类事情的发生为安全起见所以vsfptd设置了不允许登录。</p>
<p><a href="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/c.png" target="_blank" rel="noopener"><img src="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/c.png" alt=""></a></p>
<p>4.正确配置文件夹的权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 755 &#x2F;var&#x2F;ftp #把权限改为默认的755</span><br><span class="line">cd &#x2F;var&#x2F;ftp 	#进入ftp目录</span><br><span class="line">mkdir anon		#在目录下新建目录</span><br><span class="line">chmod 777 anon  #修改目录权限</span><br><span class="line">cp 1.txt anon	#复制文件到anon目录下</span><br><span class="line">cd anon			#进入anon目录</span><br><span class="line">ls -l			#查看1.txt的权限</span><br><span class="line">chmod 666 test.txt #修改文件权限为可写</span><br></pre></td></tr></table></figure>

<p>|<br>| - | - |</p>
<p>5.测试</p>
<p>回到客户机来测试能否删除1.txt文件和上传新的文件。</p>
<p><a href="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/d.png" target="_blank" rel="noopener"><img src="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/d.png" alt=""></a></p>
<h2 id="配置登录用户禁锢在家目录"><a href="#配置登录用户禁锢在家目录" class="headerlink" title="配置登录用户禁锢在家目录"></a>配置登录用户禁锢在家目录</h2><p>vsftp用户登录系统后，当前目录一般为家目录，用户的各种操作均在此目录中实现，但是搭建的vsftpd服务器默认并不是我们想要的这样，用户是可以随意切换到系统中的其他目录中去的，这样就给系统的安全带来了很大的隐患。</p>
<h3 id="测试用户权限"><a href="#测试用户权限" class="headerlink" title="测试用户权限"></a>测试用户权限</h3><p>使用upload用户登录到服务器，测试是否可以切换目录。</p>
<p><a href="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/e.png" target="_blank" rel="noopener"><img src="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/e.png" alt=""></a></p>
<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>修改配置文件去掉<code>&quot;chroot_local_user=YES&quot;</code>前的注释符号#</p>
<h3 id="重启服务-1"><a href="#重启服务-1" class="headerlink" title="重启服务"></a>重启服务</h3><p>可以使用<code>service vsftpd reload</code>命令重启服务器使刚才的配置生效。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在客户机使用upload用户登录，切换到根目录然后使用ls命令来查看文件发现并不能看到根目录下的内容，只能看到自己家目录下的内容。</p>
<p><a href="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/f.png" target="_blank" rel="noopener"><img src="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/f.png" alt=""></a></p>
<h2 id="配置实现现在某些用户访问"><a href="#配置实现现在某些用户访问" class="headerlink" title="配置实现现在某些用户访问"></a>配置实现现在某些用户访问</h2><blockquote>
<p>vsftp服务和samba服务不一样，在samba服务中系统和samba用户是分开的，而在vsftp服务中，只要是系统默认用户就是vsftp用户。也就是说只要能够登录系统就可以登录vsftp服务器，这样做显然是不太合理的。</p>
</blockquote>
<p>1.查看配置vsftpd配置的相关文件</p>
<p>在<code>/etc/vsftpd</code>目录下有一个user_list文件，使用cat命令来查看文件中的内容，发现都是拒绝登录vsftp服务器的用户。所以谁不可以登录就把账号写进这个文件中。</p>
<p>2.添加拒绝账户到文件中</p>
<p>使用<code>vim /etc/vsftpd/user_list</code>命令编辑文件在最后一行加入upload账户用以拒绝访问upload登录ftp服务器。然后重启服务</p>
<p>3.效果验证</p>
<p>回到客户机用upload登录，会显示失败。<a href="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/g.png" target="_blank" rel="noopener"><img src="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/g.png" alt=""></a></p>
<p>备注这里登录失败的原因是应为把upload写进了user_list这个文件中，这个拒绝用户登录之所以生效是因为<code>/etc/vsftpd/vsftpd.conf</code>配置文件中默认有“user_list_enalbe=YES”这行设置，如果把此配置改成“user_list_enable=YES”那么就只有写进user_list文件中的用户才可以登录。</p>
<h2 id="配置虚拟用户FTP访问"><a href="#配置虚拟用户FTP访问" class="headerlink" title="配置虚拟用户FTP访问"></a>配置虚拟用户FTP访问</h2><p>在vsftp服务器中，系统用户就是vsftp用户,那么vsftp账户也能够登录系统，为了系统安全考虑，运维人员往往需要只建立vsftp用户，而不希望登录系统，这时就需要用到vsftp服务器的虚拟账户功能。</p>
<h3 id="新建虚拟用户名文件"><a href="#新建虚拟用户名文件" class="headerlink" title="新建虚拟用户名文件"></a>新建虚拟用户名文件</h3><p>使用<code>vim /etc/vsftpd/vuser</code>命令创建用于存放虚拟用户的文件。文件中奇数行为用户名，偶数行为密码。先在创建两个名分别为Tom和Jack,密码为qwe123的虚拟用户。</p>
<h3 id="将文件转换成数据库文件"><a href="#将文件转换成数据库文件" class="headerlink" title="将文件转换成数据库文件"></a>将文件转换成数据库文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;etc&#x2F;vsftpd</span><br><span class="line">db_load -T -thash -f vuser vuser.db</span><br></pre></td></tr></table></figure>

<p>|<br>| - | - |</p>
<p>参数-T指定转换后的文件类型为hash，参数-f指定转换后的文件名为vuser.db。可以使用<code>file vuser.db</code>来查看文件的类型。</p>
<p><a href="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/h.png" target="_blank" rel="noopener"><img src="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/h.png" alt=""></a></p>
<h3 id="修改用户文件权限"><a href="#修改用户文件权限" class="headerlink" title="修改用户文件权限"></a>修改用户文件权限</h3><p>为了安全，不能让其他用户拥有vuser和vuser.db文件的任何权限。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 600 &#x2F;etc&#x2F;vsftpd&#x2F;vuser</span><br><span class="line">chmod 600 &#x2F;etc&#x2F;vsftpd&#x2F;vuser.db</span><br></pre></td></tr></table></figure>

<p>|<br>| - | - |</p>
<h3 id="创建虚拟用户的映射账户"><a href="#创建虚拟用户的映射账户" class="headerlink" title="创建虚拟用户的映射账户"></a>创建虚拟用户的映射账户</h3><p>虚拟用户创建之后，要给虚拟用户映射到一个系统账号，使用<code>useradd -d /opt/vuser -s /sbin/nologin vuser</code>命令新建一个虚拟用户的映射账号vuser,指定宿主目录为<code>/opt/vuser</code>,并指定不能登录系统。</p>
<h3 id="配置用户认证信息"><a href="#配置用户认证信息" class="headerlink" title="配置用户认证信息"></a>配置用户认证信息</h3><p>使用<code>vim /etc/pam.d/vsftpd.vu</code>命令为虚拟用户创建pam认证模块，名字为vsftpd.vu。在认证文件中加入如下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auth required pam_userdb.so db&#x3D;&#x2F;etc&#x2F;vsftpd&#x2F;vuser</span><br><span class="line">account required pam_userdb.so db&#x3D;&#x2F;etc&#x2F;vsftpd&#x2F;vuser</span><br></pre></td></tr></table></figure>

<p>|<br>| - | - |</p>
<p>这里的vuser其实是vuser.db,这里省略了.db，否则会报错。</p>
<h3 id="开启虚拟用户访问"><a href="#开启虚拟用户访问" class="headerlink" title="开启虚拟用户访问"></a>开启虚拟用户访问</h3><p>使用<code>vim /etc/vsftpd/vsftpd.conf</code>编辑配置文件，在文件的最后添加如下内容，注释掉<code>pam_service_name=vsftpd</code>。如下图所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">guest_enable&#x3D;YES</span><br><span class="line">guest_username&#x3D;vuser</span><br><span class="line">pam_service_name&#x3D;vsftpd.vu</span><br></pre></td></tr></table></figure>

<p>|<br>| - | - |</p>
<p><a href="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/i.png" target="_blank" rel="noopener"><img src="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/i.png" alt=""></a></p>
<h3 id="效果验证"><a href="#效果验证" class="headerlink" title="效果验证"></a>效果验证</h3><p>使用<code>service vsftpd restart</code>命令重启服务，用客户机进行测试。分别使用Tom和Jack登录并上传文件</p>
<p><a href="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/j.png" target="_blank" rel="noopener"><img src="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/j.png" alt=""></a></p>
<p>使用<code>ls -l /opt/vuser</code>命令查看上传的文件的属主,发现属主均为vuser。</p>
<p><a href="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/k.png" target="_blank" rel="noopener"><img src="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/k.png" alt=""></a></p>
<h2 id="配置虚拟用户拥有不同的文件权限"><a href="#配置虚拟用户拥有不同的文件权限" class="headerlink" title="配置虚拟用户拥有不同的文件权限"></a>配置虚拟用户拥有不同的文件权限</h2><h3 id="开启单独配置文件功能"><a href="#开启单独配置文件功能" class="headerlink" title="开启单独配置文件功能"></a>开启单独配置文件功能</h3><p>打开vsftpd.conf配置文件，加入以下一行内容，告诉配置文件在vu_dir目录下找用户的单独权限配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user_config_dir&#x3D;&#x2F;etc&#x2F;vsftpd&#x2F;vu_dir</span><br></pre></td></tr></table></figure>

<p>|<br>| - | - |</p>
<h3 id="建立用户权限文件"><a href="#建立用户权限文件" class="headerlink" title="建立用户权限文件"></a>建立用户权限文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;etc&#x2F;vsftpd&#x2F;vu_dir #新建vu_dir目录</span><br><span class="line">cd &#x2F;etc&#x2F;vsftpd&#x2F;vu_dir #进入vu_dir目录</span><br><span class="line">touch Jack</span><br></pre></td></tr></table></figure>

<p>|<br>| - | - |</p>
<p>使用man命令发现anon_umask(匿名上传)的默认权限为600，如国要改变Jack的上传权限为644的话，就把这个值设置为022即可。使用<code>vim Jack</code>命令编辑文件在文件中写入<code>anon_umask=022</code></p>
<h3 id="效果验证-1"><a href="#效果验证-1" class="headerlink" title="效果验证"></a>效果验证</h3><p>重启服务后，用客户机登录Jack上传一个新的文件。</p>
<p><a href="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/l.png" target="_blank" rel="noopener"><img src="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/FTP/l.png" alt=""></a></p>
]]></content>
  </entry>
</search>
